<!DOCTYPE html>

<html lang="en">



<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Xenos Army Builder — updated mins from attachment</title>
  <link rel="stylesheet" href="styles.css">

  <!-- Inline styles migrated to styles.css -->
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore-compat.js"></script>
  <script>
    window.XENOS_FIREBASE_CONFIG = {
      apiKey: "AIzaSyCU1-OZq-HFPjGUtDkOnykD7HhZDuxYuIc",
      authDomain: "army-builder-a6f09.firebaseapp.com",
      projectId: "army-builder-a6f09",
      storageBucket: "army-builder-a6f09.firebasestorage.app",
      messagingSenderId: "303583993851",
      appId: "1:303583993851:web:6ee3a610db69a3b323755e",
      measurementId: "G-1DWFSZT8VB"
    };
  </script>

</head>



<body>

  <div class="container">

    <header style="text-align:center;margin-bottom:16px">

      <h1 style="font-size:30px;color:#000;margin:0;">

        Xenos Army Builder

      </h1>

      

      <nav class="topbar">
        <a href="#" data-tab="home" onclick="event.preventDefault(); setActiveTab('home')">Home</a>
        <a href="#" data-tab="reference" onclick="event.preventDefault(); setActiveTab('reference')">Reference</a>
        <a href="#" data-tab="lists" onclick="event.preventDefault(); setActiveTab('lists')">Lists</a>
        <a href="#" data-tab="roster" onclick="event.preventDefault(); setActiveTab('roster')">Roster</a>
        <div class="account-wrap"><button id="auth-btn" class="btn btn-sm" onclick="openLoginModal()">Login</button></div>
      </nav>
      <div id="status-banner" class="warn" style="display:none"></div>

    </header>



    <div class="tabs" style="display:none"></div>



    <div id="content" class="tab-content card" style="padding:16px;"></div>

  </div>



  <div id="modal-root"></div>



  <script>

    // ---------- Auth ----------
      let currentUserId = null;
      let currentUserName = '';
      let currentUserIsGoogle = false;
      let firebaseApp = null;
      let firebaseAuth = null;
      let firebaseDb = null;
      function loadUser(){ try{ const raw=localStorage.getItem('xenos_current_user'); if(raw){ const u=JSON.parse(raw); currentUserId=u.id||null; currentUserName=u.name||''; currentUserIsGoogle=!!u.google; } }catch(e){} }
      function saveUserSession(){ try{ const u={ id: currentUserId, name: currentUserName, google: currentUserIsGoogle }; localStorage.setItem('xenos_current_user', JSON.stringify(u)); refreshAuthButton(); }catch(e){} }
      function initCloudIfAvailable(){ if(firebaseApp || !window.XENOS_FIREBASE_CONFIG || !window.firebase || !window.firebase.initializeApp) return; try{ firebaseApp = firebase.initializeApp(window.XENOS_FIREBASE_CONFIG); firebaseAuth = firebase.auth(); firebaseDb = firebase.firestore(); }catch(e){ firebaseApp=null; firebaseAuth=null; firebaseDb=null; } }
      function storageKey(suffix){ const uid=currentUserId||'default'; return `xenos_${uid}_${suffix}`; }
      function refreshAuthButton(){ const btn=document.getElementById('auth-btn'); if(!btn) return; if(currentUserId){ btn.textContent = `Logout (${currentUserName||'User'})`; btn.onclick = handleLogout; } else { btn.textContent = 'Login'; btn.onclick = openLoginModal; } }
      function openLoginModal(){ initCloudIfAvailable(); const root=document.getElementById('modal-root'); const hasGoogle=!!firebaseAuth; const googleBlock = hasGoogle ? `<div style="margin-top:8px;display:flex;flex-direction:column;gap:8px"><button class="btn btn-green" style="width:100%" onclick="googleLogin()">Sign in with Google</button></div>` : `<div class="small muted" style="margin-top:8px">Google login is not configured in this build.</div>`; root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">Login</h3><div class="small muted">Sign in with Google to sync lists across devices or use a local account.</div>${googleBlock}<div class="small muted" style="margin-top:8px">Local account</div><div style="margin-top:8px"><input id="login-name" class="mini-input" placeholder="Username"/></div><div style="margin-top:8px"><input id="login-pass" type="password" class="mini-input" placeholder="Password"/></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button class="btn" onclick="closeModal()">Cancel</button><button class="btn btn-green" onclick="commitLogin()">Login</button></div></div></div>`; const inp=document.getElementById('login-name'); if(inp) setTimeout(()=>inp.focus(),0); }
      async function ensureArgon2(){ if(window.argon2) return true; const urls=['https://unpkg.com/argon2-browser/dist/argon2-bundled.min.js','https://cdn.jsdelivr.net/npm/argon2-browser/dist/argon2-bundled.min.js']; for(const u of urls){ try{ const s=document.createElement('script'); s.src=u; document.head.appendChild(s); await new Promise(r=>{ s.onload=r; s.onerror=r; }); if(window.argon2) return true; }catch(e){} } return !!window.argon2; }
      function genSalt(len){ const n=Math.max(8, Number(len||16)); const bytes=new Uint8Array(n); try{ crypto.getRandomValues(bytes); }catch(e){ for(let i=0;i<n;i++) bytes[i]=Math.floor(Math.random()*256); } return bytes; }
      function readUserRecord(id){ try{ const raw=localStorage.getItem('xenos_user_'+id); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
      function writeUserRecord(id, rec){ try{ localStorage.setItem('xenos_user_'+id, JSON.stringify(rec)); }catch(e){} }
      async function commitLogin(){ const inp=document.getElementById('login-name'); const pinp=document.getElementById('login-pass'); const name=(inp&&inp.value||'').trim(); const pass=(pinp&&pinp.value||''); if(!name){ alert('Enter a username'); return; } if(!pass){ alert('Enter a password'); return; } const id = name.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); const okLib = await ensureArgon2(); if(!okLib){ alert('Login unavailable: Argon2 library failed to load. Check network and try again.'); return; } const existing=readUserRecord(id); if(existing && existing.hash){ try{ const ok = await window.argon2.verify({ pass, encoded: existing.hash }); if(!ok){ alert('Incorrect password'); return; } }catch(e){ alert('Login failed'); return; } } else { try{ const res = await window.argon2.hash({ pass, salt: genSalt(16), type: window.argon2.ArgonType.Argon2id, time: 3, mem: 4096, parallelism: 1, hashLen: 32 }); writeUserRecord(id, { id, name, hash: res.encoded }); }catch(e){ alert('Could not create user'); return; } }
        currentUserId=id||'user'; currentUserName=name; currentUserIsGoogle=false; closeModal(); saveUserSession(); await loadSavedLists(true); loadState(true); selectedListIds=[]; setActiveTab('home'); renderContent(); }
      function handleLogout(){ currentUserId=null; currentUserName=''; currentUserIsGoogle=false; if(firebaseAuth){ try{ firebaseAuth.signOut(); }catch(e){} } saveUserSession(); selectedListIds=[]; currentListId=null; selectedArmy='Select Army'; armyFormations=[]; builderMeta={ name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 }; setActiveTab('home'); renderContent(); }
      function isMobileDevice(){ return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); }
      function checkRedirectResult(){ 
        if(!firebaseAuth) return; 
        firebaseAuth.getRedirectResult().then(function(result){ 
          if(result.user){ handleLoginSuccess(result.user); } 
        }).catch(function(error){ 
          console.error(error); 
          // Only alert if we think this was a real login attempt? 
          // We can't really know, but if getRedirectResult throws, it's usually meaningful.
          if (error.code !== 'auth/popup-closed-by-user') {
             alert('Login Redirect Error: ' + error.message);
          }
        }); 
      }
      function handleLoginSuccess(user){
        currentUserId=user.uid; 
        currentUserName=user.displayName||user.email||'Google User'; 
        currentUserIsGoogle=true; 
        closeModal(); 
        saveUserSession(); 
        loadSavedLists(true); 
        loadState(true); 
        selectedListIds=[]; 
        setActiveTab('home'); 
        renderContent();
      }
      async function googleLogin(){ 
        initCloudIfAvailable(); 
        if(!firebaseAuth){ alert('Google login unavailable: Firebase not initialized'); return; } 
        const provider=new firebase.auth.GoogleAuthProvider(); 
        
        // 1. Mobile strategy: Always redirect
        if(isMobileDevice()){ 
          try{ 
            await firebaseAuth.signInWithRedirect(provider); 
            return; 
          }catch(e){ 
            alert('Google Redirect Login failed: '+e.message); 
            console.error(e);
            return;
          } 
        } 
        
        // 2. Desktop strategy: Popup -> Fallback to Redirect
        try{ 
          const res=await firebaseAuth.signInWithPopup(provider); 
          const user=res && res.user; 
          if(!user) return; 
          handleLoginSuccess(user);
        }catch(e){ 
          console.log('Popup failed, trying redirect...', e);
          if(e.code==='auth/popup-blocked'||e.code==='auth/popup-closed-by-user'||e.code==='auth/cancelled-popup-request'){ 
            try{ 
              await firebaseAuth.signInWithRedirect(provider); 
            }catch(e2){ 
              alert('Login failed: '+e2.message); 
            } 
          } else { 
            alert('Google login failed: '+e.message); 
          } 
        } 
      }

    // ---------- State ----------

      let activeTab = 'home';

      let selectedArmy = 'Select Army';

      let selectedFormationName = 'Select a Formation';

      let armyFormations = [];

      let editContext = null;
      let dataStatus = { loaded:false, warriorUpgrades:0, loading:false, failed:false };
      let builderMeta = { name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 };
      let savedLists = [];
      let currentListId = null;
      let listsSortBy = 'createdAt';
      let listsSortDir = 'desc';
      let selectedListIds = [];
      async function loadSavedLists(migrate){ const key=storageKey('saved_lists'); let raw=localStorage.getItem(key); if(!raw && migrate){ const legacy=localStorage.getItem('xenos_saved_lists'); if(legacy){ raw=legacy; localStorage.setItem(key, legacy); } } let fromCloud=false; initCloudIfAvailable(); if(currentUserId && currentUserIsGoogle && firebaseDb){ try{ const doc=await firebaseDb.collection('users').doc(currentUserId).get(); if(doc && doc.exists){ const data=doc.data()||{}; if(Array.isArray(data.savedLists)){ raw=JSON.stringify(data.savedLists); fromCloud=true; localStorage.setItem(key, raw); } } }catch(e){} } savedLists = raw? JSON.parse(raw):[]; savedLists = (savedLists||[]).map(x=>({ ...x, id: x.id || String(Date.now()+Math.random()), createdAt: x.createdAt || Date.now(), updatedAt: x.updatedAt || x.createdAt || Date.now() })); if(currentUserId && currentUserIsGoogle && firebaseDb && !fromCloud){ try{ await firebaseDb.collection('users').doc(currentUserId).set({ savedLists }, { merge:true }); }catch(e){} } }
      async function persistSavedLists(){ const key=storageKey('saved_lists'); try{ localStorage.setItem(key, JSON.stringify(savedLists)); }catch(e){} initCloudIfAvailable(); if(currentUserId && currentUserIsGoogle && firebaseDb){ try{ await firebaseDb.collection('users').doc(currentUserId).set({ savedLists }, { merge:true }); }catch(e){} } }
      loadUser(); initCloudIfAvailable(); checkRedirectResult(); refreshAuthButton(); loadSavedLists(true);

      let referenceView = 'main';
      let referenceDetail = { army:null, unitId:null };
      let referenceWeapon = null;
      let referenceFilter = '';
      let referenceQuery = '';
      let referenceShowUpgrades = false;
      let armyRulesFaction = 'Tyranids';

      const APP_SCHEMA_VERSION = 1;
      function saveState(){ const s={ version: APP_SCHEMA_VERSION, activeTab, selectedArmy, selectedFormationName, armyFormations, builderMeta, currentListId }; localStorage.setItem(storageKey('state'), JSON.stringify(s)); autoSaveList('state-change'); }
      function migrateState(s){ const out={ version: APP_SCHEMA_VERSION, activeTab:'home', selectedArmy: s.selectedArmy||'Select Army', selectedFormationName: s.selectedFormationName||'Select a Formation', armyFormations: Array.isArray(s.armyFormations)? s.armyFormations:[], builderMeta: s.builderMeta||builderMeta, currentListId: s.currentListId||null }; return out; }
      function loadState(migrate){ const key=storageKey('state'); let raw=localStorage.getItem(key); if(!raw && migrate){ const legacy=localStorage.getItem('xenos_state'); if(legacy){ raw=legacy; localStorage.setItem(key, legacy); } }
        if(!raw) return; let s=JSON.parse(raw); if(!s.version || s.version!==APP_SCHEMA_VERSION){ const m=migrateState(s); if(!m) return; s=m; } activeTab='home'; selectedArmy=s.selectedArmy||'Select Army'; selectedFormationName=s.selectedFormationName||'Select a Formation'; armyFormations=Array.isArray(s.armyFormations)?s.armyFormations:[]; builderMeta = s.builderMeta || builderMeta; currentListId = s.currentListId || null; }



      // ---------- Armies & formations (mins updated per attached Excel) ----------

      const ARMIES = {
        "Select Army": { formations: [] },
        "Tyranids": { formations: ["Synaptic Swarm","Assault Swarm","Bio-Titan Swarm"] }
      };

      let UNIT_DEFAULT_MODELS = { 'hive-tyrant':1, 'tyranid-warrior':3, 'termagant':6, 'hormagaunt':6, 'genestealer':6, 'harpy':1, 'mycetic-spores':1, 'carnifex':1, 'exocrine':1, 'dominatrix':1 };
      let UNIT_MAX_MODELS = { 'termagant':12, 'hormagaunt':12, 'genestealer':12 };
      let UNIT_BROOD_STEP = { 'termagant':3, 'hormagaunt':3, 'genestealer':3 };
      let UNIT_BROOD_POINTS = {};

      let WEAPON_CONSTRAINTS = {};
      function slugToName(s){ return String(s||'').split('_').map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(' '); }
      async function loadWeaponConstraints(){ return; }
      function masterLSKey(key){ return 'army_master_'+String(key||''); }
      function loadMasterFromLocalStorage(key){ try{ const raw=localStorage.getItem(masterLSKey(key)); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
      function saveMasterToLocalStorage(key, ref){ try{ if(!ref) return; localStorage.setItem(masterLSKey(key), JSON.stringify(ref)); }catch(e){} }
      async function loadConsolidatedArmyMaster(armyArg){ try{ const key=armyKey(armyArg||selectedArmy); try{ const old=localStorage.getItem('oraks'); if(old && !localStorage.getItem('orks')){ localStorage.setItem('orks', old); } }catch(e){} const urls=[`data/armies/${key}/master.json`,`data/${String(key).charAt(0).toUpperCase()+String(key).slice(1)}Master.json`]; let json=loadMasterFromLocalStorage(key); if(armyArg==='Tyranids') json=null; if(!json){ for(const u of urls){ try{ const r=await fetch(u,{cache:'no-store'}); if(r&&r.ok){ json=await r.json(); saveMasterToLocalStorage(key,json); break; } }catch(e){} } } if(!json) return null; const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const normUpgrade=(n)=>String(n||'').toLowerCase().replace(/\(.*?\)/g,'').replace(/^upgrade to\s+/,'').trim(); const roster=json.unit_roster||{}; const DEV_WL=new Set(["hive_tyrant","tyranid_warrior_brood","mycetic_spores","termagant_brood","hormagaunt_brood","genestealer_brood","lictor_brood","carnifex_brood","zoanthrope_brood","biovore_brood"]); Object.keys(roster).forEach(key=>{ if(armyArg==='Tyranids' && !DEV_WL.has(key)) { delete roster[key]; return; } const id=norm(key); const m=roster[key]||{}; const det=Number(m.detachment_size||1); if(det>1) UNIT_DEFAULT_MODELS[id]=det; const s=m.stats||{}; const base=UNIT_BASE[id]||{}; UNIT_BASE[id]={ points: m.points??base.points, movement: s.move??base.movement, save: s.save??base.save, CAF: s.caf??base.CAF, morale: s.morale??base.morale, wounds: s.wounds??base.wounds }; const ups=(m.upgrades||[]); UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:UNIT_BASE[id].CAF, baseWounds:UNIT_BASE[id].wounds, specialRules:(m.special_rules||[]) }; ups.forEach((u,i)=>{ const name=u.name||u.description||''; const points=u.cost||u.points||0; const entry={ id:u.id||('u_master_'+id+'_'+i), name, points, desc:u.limit||u.description||'', type:(/swap/i.test(name)? (/(1\s*per\s*3)/i.test(name)?'WEAPON_SWAP_LIMITED':'WEAPON_SWAP') : 'MODEL_UPGRADE'), replaces: slugToName(u.replaces||''), grants: slugToName(u.grants||''), detachmentSize: u.detachmentSize||undefined }; const normName=normUpgrade(entry.name); const hasUp=(UNIT_LOADOUTS[id].upgrades||[]).some(x=>normUpgrade(x.name)===normName); const hasPsy=(UNIT_LOADOUTS[id].psychicPowers||[]).some(x=>normUpgrade(x.name)===normName); if(!hasUp && !hasPsy) UNIT_LOADOUTS[id].upgrades.push(entry); }); }); const lib=json.weaponLibrary||json.weapons||{}; Object.entries(lib).forEach(([slug,def])=>{ const name=WEAPON_SLUG_TO_NAME[slug]||slugToName(slug); WEAPON_LIBRARY[name]=WEAPON_LIBRARY[name]||{ range:def.range||'-', dice:def.dice||'-', toHit:def.toHit||def.tohit||'-', AP:def.ap??'-', traits: Array.isArray(def.traits)?def.traits.join('; '):(def.traits||''), points: WEAPON_POINTS[name]??(def.points||0) }; }); const b=json.broodSizes||json.unitBroodSizes||{}; Object.keys(b).forEach(k=>{ const id=norm(k); const d=b[k]||{}; const init=Number(d.initial_brood_size||UNIT_DEFAULT_MODELS[id]||1); const max=Number(d.max_brood_size||init); const step=Number(d.upgrade_increment||1); const cost=Number(d.upgrade_cost_per_increment||0); UNIT_DEFAULT_MODELS[id]=init; UNIT_MAX_MODELS[id]=max; UNIT_BROOD_STEP[id]=step; UNIT_BROOD_POINTS[id]=cost; if(max>init){ UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; const exists=(UNIT_LOADOUTS[id].upgrades||[]).some(u=>u.type==='BROOD_SIZE'); if(!exists){ UNIT_LOADOUTS[id].upgrades=(UNIT_LOADOUTS[id].upgrades||[]).concat([{ id:'u_bsize_'+id, name:`Increase the Brood size by ${step}`, points: cost, type:'BROOD_SIZE', modelsDelta: step, maxModels: max }]); } } }); const cons=json.weaponConstraints||{}; Object.keys(cons).forEach(k=>{ const id=norm(k); const rules=cons[k]||[]; const entry={ mutexPairs:[], disableWhenUpgrade:{} }; rules.forEach(r=>{ const opts=(r.options||[]).map(slugToName); if(r.type && r.type.indexOf('MUTUALLY_EXCLUSIVE')>-1){ for(let i=0;i<opts.length;i++){ for(let j=i+1;j<opts.length;j++){ entry.mutexPairs.push([opts[i],opts[j]]); } } } if(r.hide_when_upgrade){ Object.entries(r.hide_when_upgrade||{}).forEach(([up,list])=>{ entry.disableWhenUpgrade[up]=(entry.disableWhenUpgrade[up]||[]).concat((list||[]).map(slugToName)); }); } }); WEAPON_CONSTRAINTS[id]=entry; }); return json; }catch(e){ return null; } }



      // Min/Max values exactly from attachment:

      // Synaptic Swarm: Compulsory Synapse max1 min1, Core max3 min3; Optional Synapse max2, Core max6; Special Biotitan or Flyer max1

      // Assault Swarm: Compulsory Synapse max1 min1, Core max3 min3, Transport max1 min0; Optional Synapse max2, Core max6, Flyer max2

      // Bio-Titan Swarm: Compulsory Biotitan max3 min3; Optional Biotitan max3

      const FORMATIONS = {
        "Synaptic Swarm": {
          compulsory:[{type:"Synapse",label:"Synapse",max:1,min:1},{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Synapse",label:"Synapse Optional",max:2,min:0},{type:"Core",label:"Core Optional",max:6,min:0}],
          special:{type:"Special",label:"Biotitan or Flyer",max:1,allowedTypes:["Biotitan","Flyer"]}
        },
        "Assault Swarm": {
          compulsory:[{type:"Synapse",label:"Synapse",max:1,min:1},{type:"Core",label:"Core",max:3,min:3},{type:"Transport",label:"Transport",max:1,min:0}],
          optional:[{type:"Synapse",label:"Synapse Optional",max:2,min:0},{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0}],
          special:null
        },
        "Bio-Titan Swarm": {
          compulsory:[{type:"Biotitan",label:"Biotitan",max:3,min:3}],
          optional:[{type:"Biotitan",label:"Biotitan Optional",max:3,min:0}],
          special:null
        },
        "Warhost": {
          compulsory:[{type:"Synapse",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0},{type:"Transport",label:"Transport Optional",max:2,min:0}],
          special:{type:"Special",label:"Super-heavy",max:1,allowedTypes:["Biotitan"]}
        },
        "Aspect Warrior Shrine": {
          compulsory:[{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0}],
          special:null
        },
        "Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"Support",label:"Support",max:1,min:1},{type:"Core",label:"Core",max:1,min:1}],
          optional:[{type:"Transport",label:"Transport",max:1,min:0},{type:"Core",label:"Core Optional",max:6,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Support",label:"Support Optional",max:1,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0},{type:"HeavyArmor",label:"Heavy Armor",max:1,min:0}],
          special:{type:"Special",label:"Titan/Knight or Air/Artillery/Bastion",max:1,allowedTypes:["Biotitan","Knight","AirSupport","Artillery","Bastion"]}
        },
        "Speed Freaks": {
          compulsory:[{type:"Flyer",label:"Flyer",max:2,min:1},{type:"Core",label:"Core",max:3,min:2}],
          optional:[{type:"Flyer",label:"Flyer Optional",max:2,min:0},{type:"Transport",label:"Transport Optional",max:2,min:0}],
          special:null
        },
        "Blood Axes Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:2,min:2}],
          optional:[{type:"Support",label:"Support",max:1,min:0},{type:"Core",label:"Core Optional",max:1,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0}],
          special:{type:"Special",label:"One of Air Support/Heavy Armor/Artillery",max:1,allowedTypes:["AirSupport","HeavyArmor","Artillery"]},
          rules:["Sneaky Now: Each mob must take a Nob if able to.","Taktiks: All units gain Outflank and must deploy using the special rule."]
        },
        "Snakebites Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"BattleTank",label:"Battle Tank",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:1,min:1}],
          optional:[{type:"Core",label:"Core Optional",max:2,min:0},{type:"Vanguard",label:"Vanguard Optional",max:2,min:0},{type:"Support",label:"Support Optional",max:2,min:0}],
          special:{type:"Special",label:"One of Battle Tank/Core/Vanguard",max:1,allowedTypes:["BattleTank","Core","Vanguard"]},
          rules:["Primitive: May not take any detachment of size 2 or more unless it also has Clan(Snakebites).","Wierdboy Shamans: While at least 1 Wierdboy in this formation, generate +2 dice for Psychic Powers."]
        },
        "Craftworld Defenders Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:2,min:2},{type:"Support",label:"Support",max:1,min:1}],
          optional:[{type:"Core",label:"Core Optional",max:2,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Support",label:"Support Optional",max:1,min:0}],
          special:{type:"Special",label:"One of Artillery/Air Support",max:1,allowedTypes:["Artillery","AirSupport"]},
          rules:["Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports."]
        },
        "Aspect Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:3,min:3}],
          optional:[{type:"Vanguard",label:"Vanguard Optional",max:3,min:0},{type:"Transport",label:"Transport",max:2,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0}],
          special:{type:"Special",label:"One of Air Support/Knight",max:1,allowedTypes:["AirSupport","Knight"]},
          rules:["Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports."]
        },
        "Strike Warhost": {
          compulsory:[{type:"BattleTank",label:"Battle Tank",max:3,min:3}],
          optional:[{type:"BattleTank",label:"Battle Tank Optional",max:3,min:0},{type:"Support",label:"Support",max:1,min:0},{type:"Core",label:"Core",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0}],
          special:{type:"Special",label:"Two of Air Support/Heavy Armor",max:1,allowedTypes:["AirSupport","HeavyArmor"]},
          rules:["Wraithgate Assault: All models must have Move >10\" or be mounted in a Transport; all detachments gain Forward Deployment.","Tank Commander: One model from a Compulsory detachment must be upgraded with Commander for +10 pts."]
        },
        "Engines of Vaul Warhost": {
          compulsory:[{type:"Biotitan",label:"Titan",max:1,min:1}],
          optional:[{type:"Biotitan",label:"Titan Optional",max:1,min:0},{type:"HeavyArmor",label:"Heavy Armor",max:2,min:0},{type:"Knight",label:"Knight",max:3,min:0}],
          special:{type:"Special",label:"One of Air Support/Artillery",max:1,allowedTypes:["AirSupport","Artillery"]}
        },
        "Wraith Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Support",label:"Support",max:2,min:2}],
          optional:[{type:"Support",label:"Support Optional",max:2,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"Core",label:"Core",max:1,min:0},{type:"Artillery",label:"Artillery",max:2,min:0}],
          special:{type:"Special",label:"One of Air Support/Heavy Armor/Knight",max:1,allowedTypes:["AirSupport","HeavyArmor","Knight"]},
          rules:["Wraith Constructs: Compulsory Core detachments must be filled with Wraithlords or Wraithguard only; HQ must be Farseer or Warlock only.","Dire Needs: All models increase Tactical Strength by 1 when contesting an Objective with Wraithguard or Wraithlord also contesting."]
        }
      };



      // ---------- Unit registry ----------

      const ARMY_UNIT_LIST = {}; const ARMY_SLOT_FILTERS = {};
      function buildArmyUnitsFromMaster(ref, armyName){ try{ const roster=ref&&ref.unit_roster||{}; const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const mapRole=(r)=>{ const s=String(r||'').toUpperCase().replace(/\s+/g,''); const lut={ SYNAPSE:'Synapse', CORE:'Core', FLYER:'Flyer', BIOTITAN:'Biotitan', TITAN:'Biotitan', SUPERHEAVY:'Biotitan', TRANSPORT:'Transport', HQ:'HQ', SUPPORT:'Support', VANGUARD:'Vanguard', BATTLETANK:'BattleTank', HEAVYARMOR:'HeavyArmor', AIRSUPPORT:'Flyer', ARTILLERY:'Artillery', BASTION:'Bastion', KNIGHT:'Knight', INFANTRY:'Core' }; return lut[s]||'Core'; }; const synapseKeys=new Set(['hive_tyrant','tyranid_warrior_brood']); const list=[]; Object.keys(roster).forEach(key=>{ const m=roster[key]||{}; let type = mapRole(m.role); if(synapseKeys.has(key)){ type = 'Synapse'; } list.push({ id: norm(key), name: m.name||slugToName(key), slotType: type }); }); const key=armyKey(armyName||selectedArmy); ARMY_UNIT_LIST[key]=list; const filt={ Synapse: list.filter(u=>u.slotType==='Synapse').map(u=>u.id), Core: list.filter(u=>u.slotType==='Core').map(u=>u.id), Flyer: list.filter(u=>u.slotType==='Flyer').map(u=>u.id), Biotitan: list.filter(u=>u.slotType==='Biotitan').map(u=>u.id), Transport: list.filter(u=>u.slotType==='Transport').map(u=>u.id), HQ: list.filter(u=>u.slotType==='HQ').map(u=>u.id), Support: list.filter(u=>u.slotType==='Support').map(u=>u.id), Vanguard: list.filter(u=>u.slotType==='Vanguard').map(u=>u.id), BattleTank: list.filter(u=>u.slotType==='BattleTank').map(u=>u.id), HeavyArmor: list.filter(u=>u.slotType==='HeavyArmor').map(u=>u.id), AirSupport: list.filter(u=>u.slotType==='AirSupport').map(u=>u.id), Artillery: list.filter(u=>u.slotType==='Artillery').map(u=>u.id), Bastion: list.filter(u=>u.slotType==='Bastion').map(u=>u.id), Knight: list.filter(u=>u.slotType==='Knight').map(u=>u.id) }; ARMY_SLOT_FILTERS[key]=filt; }catch(e){} }

      async function ensureArmyMaster(armyName){ const key=armyKey(armyName); if((ARMY_UNIT_LIST[key]||[]).length) return; const ref=await loadConsolidatedArmyMaster(armyName); if(ref) buildArmyUnitsFromMaster(ref, armyName); }
      async function preloadAllArmyMasters(){ const list=Object.keys(ARMIES).filter(a=>a!=='Select Army'); await Promise.all(list.map(a=>ensureArmyMaster(a))); }



      /* SLOT_FILTERS handled dynamically via ARMY_SLOT_FILTERS */



      // ---------- Minimal stats/loadouts (unchanged) ----------
      const UNIT_BASE = {

        'hive-tyrant':{points:100,movement:'5"',save:'4+',CAF:'+10',morale:'2+',wounds:2},

        'tyranid-warrior':{points:60,movement:'5"',save:'5+',CAF:'+5',morale:'3+',wounds:1},

        'hormagaunt':{points:0,movement:'6"',save:'-',CAF:'+0',morale:'4+',wounds:1},
        'genestealer':{points:40,movement:'6"',save:'6+',CAF:'+6',morale:'3+',wounds:1},

        'termagant':{points:30,movement:'5"',save:'-',CAF:'+0',morale:'4+',wounds:1},

        'carnifex':{points:150,movement:'6"',save:'3+',CAF:'+0',morale:'3+',wounds:3},
        'mycetic-spores':{points:20,movement:'-',save:'-',CAF:'+0',morale:'-',wounds:0}
      };



      const WEAPON_LIBRARY = {
        "Venom Cannon":{range:'14"',dice:2,toHit:'5+',AP:-2,traits:'Anti-Tank',points:15},
        "Barbed Strangler":{range:'10"',dice:1,toHit:'4+',AP:0,traits:'Light AT; Blast (3")',points:5},
        "Lash Whip & Bone Sword":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend; Parry',points:0},
        "Fleshborer":{range:'6"',dice:1,toHit:'5+',AP:0,traits:'',points:0},
        "Rending Claws":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Death Spitter":{range:'24"',dice:2,toHit:'5+',AP:0,traits:'',points:5},
        "Scything Talons":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Bone Swords":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Pyroacid Launcher":{range:'15"',dice:2,toHit:'4+',AP:-2,traits:'Light AT; Ignore Cover',points:0},
        "Spore Launcher":{range:'20"',dice:1,toHit:'5+',AP:-1,traits:'Blast (3"); Spore Launcher',points:0},
        "Stranglewebs":{range:'6"',dice:1,toHit:'5+',AP:0,traits:'Web; Pinning',points:3},
        "Devourer":{range:'8"',dice:2,toHit:'5+',AP:0,traits:'',points:1},
        "Bio-Plasma":{range:'8"',dice:1,toHit:'4+',AP:-1,traits:'Light AT',points:5},
        "Bio-Plasmic Cannon":{range:'22"',dice:4,toHit:'4+',AP:-3,traits:'Anti-Tank; Blast (3")',points:0},
        "Bio Cannon":{range:'22"',dice:6,toHit:'5+',AP:-3,traits:'Anti-Tank',points:0},
        "Warp Pulse":{range:'20"',dice:'-',toHit:'Auto',AP:-4,traits:'Beam; Armorbane',points:0},
        "Spore Cysts":{range:'6"',dice:12,toHit:'6+',AP:0,traits:'Light',points:0},
        "Stranglethorn Cannon":{range:'22"',dice:4,toHit:'4+',AP:0,traits:'Light AT; Blast (5")',points:0},
        "Drool Cannon":{range:'8"',dice:3,toHit:'4+',AP:-1,traits:'Template; Ignore Cover',points:0},
        "Flesh Hooks":{range:'6"',dice:1,toHit:'4+',AP:0,traits:'Light; Ignore Cover; Attract (1)',points:0},
        "Flensing Whips":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0}
      };
      const WEAPON_POINTS = { 'Venom Cannon':15, 'Barbed Strangler':5, 'Lash Whip & Bone Sword':0, 'Fleshborer':0, 'Death Spitter':5, 'Rending Claws':0, 'Devourer':1, 'Stranglewebs':3, 'Bone Swords':0, 'Pyroacid Launcher':0, 'Spore Launcher':0 };



      const UNIT_LOADOUTS = {

        'hive-tyrant':{

          baseCAF:'+10', baseWounds:2,

          weapons:[

            {id:'w_lashbone',name:'Lash Whip & Bone Sword',src:'Lash Whip & Bone Sword',base:true},

            {id:'w_venom',name:'Venom Cannon',src:'Venom Cannon',base:false},

            {id:'w_barbed',name:'Barbed Strangler',src:'Barbed Strangler',base:false}

          ],

          upgrades:[

            {id:'u_wings',name:'Add Wings',points:20,desc:'Movement profile 10"; Winged'},

            {id:'u_swarm',name:'Upgrade to Swarm Lord',points:25,desc:'CAF becomes +14; Wounds = 3; removes Venom/Barbed'}

          ],

          psychicPowers:[

            {id:'p_horror',name:'The Horror',points:15,desc:'Psychic power that induces fear'},{id:'p_catalyst',name:'Catalyst',points:15,desc:'Grants Feel No Pain to nearby brood'}

          ],

          specialRules:[

            "Commander",

            "Invulnerable Save (5+)",

            "Synapse (12”)",

            "Psychic Scream"

          ]

        },

        'tyranid-warrior':{
          baseCAF:'+5', baseWounds:1,
          weapons:[
            {id:'w_default',name:'Death Spitter',src:'Death Spitter',base:true},
            {id:'w_st',name:'Scything Talons',src:'Scything Talons',base:true}
          ],
          upgrades:[
            {id:'u_war_boneswords',name:'Replace Scything Talons with Bone Swords',points:3,type:'WEAPON_SWAP',replaces:'Scything Talons',grants:'Bone Swords',limit:'Per model'},
            {id:'u_war_barbed',name:'Replace Death Spitter with Barbed Strangler',points:15,type:'WEAPON_SWAP_LIMITED',replaces:'Death Spitter',grants:'Barbed Strangler',detachmentSize:3,limit:'1 per 3 models'},
            {id:'u_war_venom',name:'Replace Death Spitter with Venom Cannon',points:15,type:'WEAPON_SWAP_LIMITED',replaces:'Death Spitter',grants:'Venom Cannon',detachmentSize:3,limit:'1 per 3 models'}
          ],
          psychicPowers:[], specialRules:["Bulky","Synapse (6”)","Implacable"]
        },

        'termagant':{
          
          baseCAF:'+0', baseWounds:1,
          
          weapons:[{id:'w_flesh',name:'Fleshborer',src:'Fleshborer',base:true}],
          
          upgrades:[], psychicPowers:[], specialRules:["Instinct: Hunt"]
          
        },
        
        'genestealer':{
          baseCAF:'+6', baseWounds:1,
          weapons:[{id:'w_rend',name:'Rending Claws',src:'Rending Claws',base:true}],
          upgrades:[{id:'u_broodlord',name:'Broodlord (Model Upgrade)',points:20,type:'MODEL_UPGRADE',desc:'Same statline as Genestealer except: CAF +7; Special rules “Synapse (6”) and “The Horror” for that model only.'}],
          psychicPowers:[], specialRules:['Forward Deployment']
        },
        
        'carnifex':{
          baseCAF:'+7', baseWounds:2,
          weapons:[
            {id:'w_bioplasma',name:'Bio-Plasma',src:'Bio-Plasma',base:true},
            {id:'w_st',name:'Scything Talons',src:'Scything Talons',base:true}
          ],
          upgrades:[], psychicPowers:[], specialRules:['Instinct: Rampage','Armored','Bulky','Implacable','Regenerate']
        },
        'hormagaunt':{ baseCAF:'+0', baseWounds:1, weapons:[{id:'w_horm',name:'Scything Talons',src:'Scything Talons',base:true}], upgrades:[], psychicPowers:[], specialRules:['Instinct: Rampage'] },

        'harpy':{
          baseCAF:'+2', baseWounds:1,
          weapons:[
            {id:'w_stc',name:'Stranglethorn Cannon',src:'Stranglethorn Cannon',base:true},
            {id:'w_spore',name:'Spore Launcher',src:'Spore Launcher',base:true}
          ],
          upgrades:[{id:'u_drool',name:'Replace Stranglethorn Cannon with Drool Cannon',points:0,type:'WEAPON_SWAP',replaces:'Stranglethorn Cannon',grants:'Drool Cannon'}],
          psychicPowers:[], specialRules:['Flyer','Winged','Hover','Interceptor','Jink (5+)']
        },
        'biovore':{
          baseCAF:'+0', baseWounds:1,
          weapons:[
            {id:'w_bio_spore',name:'Spore Launcher',src:'Spore Launcher',base:true}
          ],
          upgrades:[], psychicPowers:[], specialRules:['Instinct: Nest','Bulky']
        },
        'exocrine':{
          baseCAF:'+4', baseWounds:2,
          weapons:[{id:'w_bpc',name:'Bio-Plasmic Cannon',src:'Bio-Plasmic Cannon',base:true},{id:'w_scysts',name:'Spore Cysts',src:'Spore Cysts',base:true}],
          upgrades:[], psychicPowers:[], specialRules:['Instinct: Nest','Armored']
        },
        'mycetic-spores':{
          baseCAF:'+1', baseWounds:1,
          weapons:[{id:'w_flensing',name:'Flensing Whips',src:'Flensing Whips',base:true}],
          upgrades:[{id:'u_bsize_mycetic-spores',name:'Increase the Brood size by 1',points:15,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}],
          psychicPowers:[], specialRules:['Deep Strike','Large Assault Transport (8)','Drop Pod']
        },
        'dominatrix':{
          baseCAF:'+12', baseWounds:4,
          weapons:[{id:'w_bio_can',name:'Bio Cannon',src:'Bio Cannon',base:true},{id:'w_warp',name:'Warp Pulse',src:'Warp Pulse',base:true},{id:'w_scysts_dom',name:'Spore Cysts',src:'Spore Cysts',base:true}],
          upgrades:[], psychicPowers:[], specialRules:['Invulnerable Save (2+)','Synapse (24”)','Psychic Scream','Catalyst','Regenerate','The Horror']
        }

      };



      const WEAPON_SLUG_TO_NAME = { death_spitter:'Death Spitter', barbed_strangler:'Barbed Strangler', venom_cannon:'Venom Cannon', scything_talons:'Scything Talons', bone_swords:'Bone Swords', spore_launcher:'Spore Launcher', pyroacid_launcher:'Pyroacid Launcher', stranglewebs:'Stranglewebs', devourer:'Devourer', bio_plasma:'Bio-Plasma', bio_plasmic_cannon:'Bio-Plasmic Cannon', bio_cannon_dominatrix:'Bio Cannon', warp_pulse:'Warp Pulse', spore_cysts_dominatrix:'Spore Cysts', stranglethorn_cannon:'Stranglethorn Cannon', drool_cannon:'Drool Cannon', flesh_hooks:'Flesh Hooks', flensing_whips:'Flensing Whips' };

      async function loadWeaponsData(){ return; }

      // ---------- Helpers ----------
      function armyKey(name){ const n=String(name||'').toLowerCase(); if(n.includes('tyranid')) return 'tyranids'; if(n.includes('eldar')) return 'eldar'; if(n.includes('ork')) return 'orks'; return 'tyranids'; }
      function clearPDFCache(){ try{ const keys=[]; for(let i=0;i<localStorage.length;i++){ const k=localStorage.key(i); if(k && k.startsWith('pdf_cache_')) keys.push(k); } keys.forEach(k=>localStorage.removeItem(k)); alert('PDF cache cleared'); }catch(e){} }
      function exportCurrentArmyMaster(){ return; }
      function importArmyMaster(){ return; }
      async function linkArmyMasterFile(){ return; }
      async function saveMasterNow(){ return; }

      async function loadMasterRef(){ return null; }
      function formatDateTime(ts){ if(!ts) return '-'; const d=new Date(ts); if(!d || !d.getTime) return '-'; const t=d.getTime(); if(!(t>0)) return '-'; try{ return d.toLocaleString(); }catch(e){ return String(d); } }
      function applyMasterBroodDefaults(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const det=Number(data.detachment_size||1); if(det>1){ UNIT_DEFAULT_MODELS[appId]=det; const ups=data.upgrades||[]; let step=UNIT_BROOD_STEP[appId]||0; let max=UNIT_MAX_MODELS[appId]||det; let cost=UNIT_BROOD_POINTS[appId]||0; ups.forEach(u=>{ const name=u.name||u.description||''; const mStep=(name.match(/Increase\s+Brood\s+size\s+by\s+(\d+)/i)||[])[1]; const mMax=(name.match(/Max\s+(\d+)/i)||[])[1]; if(mStep){ const n=Number(mStep); step = step>0 ? Math.min(step,n) : n; } if(mMax){ max=Number(mMax); } if(/Increase\s+Brood\s+size/i.test(name) && u.cost!=null){ cost=Number(u.cost); } }); if(appId==='termagant'){ step=3; } UNIT_BROOD_STEP[appId]=step; UNIT_MAX_MODELS[appId]=max; UNIT_BROOD_POINTS[appId]=cost; UNIT_LOADOUTS[appId] = UNIT_LOADOUTS[appId] || { weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; const hasB=(UNIT_LOADOUTS[appId].upgrades||[]).some(u=>u.type==='BROOD_SIZE'); if(!hasB && max>det){ UNIT_LOADOUTS[appId].upgrades=(UNIT_LOADOUTS[appId].upgrades||[]).concat([{ id:'u_bsize_'+appId, name:`Increase the Brood size by ${step}`, points: cost, type:'BROOD_SIZE', modelsDelta: step, maxModels: max }]); } } }); }catch(e){} }
      function applyUpgradeConstraintsFromMaster(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const ups=(data.upgrades||[]); const load=(UNIT_LOADOUTS[appId]||{}); const libWeps=(load.weapons||[]); const rangedNames=libWeps.filter(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; const r=String(s.range||''); return !(r==='Melee' || r==='-' ); }).map(w=>w.name);
        const findUpId=(substr)=>{ const u=(load.upgrades||[]).find(x=> (x.name||'').toLowerCase().includes(substr.toLowerCase())); return u && u.id; };
        ups.forEach(u=>{ const text=String(u.name||'').toLowerCase(); if(text.includes('swarm lord') && text.includes('no ranged')){ const upId=findUpId('swarm'); if(upId && rangedNames.length){ WEAPON_CONSTRAINTS[appId] = WEAPON_CONSTRAINTS[appId] || { mutexPairs:[], disableWhenUpgrade:{} }; WEAPON_CONSTRAINTS[appId].disableWhenUpgrade[upId] = rangedNames.slice(); } } }); });
        WEAPON_CONSTRAINTS['hive-tyrant'] = WEAPON_CONSTRAINTS['hive-tyrant'] || { mutexPairs:[], disableWhenUpgrade:{} };
        const ht = WEAPON_CONSTRAINTS['hive-tyrant'];
        const pair = ['Venom Cannon','Barbed Strangler'];
        const hasPair = (ht.mutexPairs||[]).some(([a,b])=> (a===pair[0] && b===pair[1]) || (a===pair[1] && b===pair[0]));
        if(!hasPair){ ht.mutexPairs.push(pair); }
      }catch(e){} }
      function countCoreUpgradeTotal(fIdx, excludeSection, excludeIndex, namePattern){ try{ const f=armyFormations[fIdx]; if(!f) return 0; const re=new RegExp(namePattern,'i'); let total=0; [['compulsory','Core'],['optional','Core']].forEach(([sec,type])=>{ const arr=f[sec]||[]; arr.forEach((slot,si)=>{ if(slot.type!==type) return; if(sec===excludeSection && si===excludeIndex) return; const u=(slot.units||[])[0]; if(!u) return; (u.upgrades||[]).forEach(up=>{ if(re.test(up.name||'')) total += Number(up.count||1); }); }); }); return total; }catch(e){ return 0; } }
      function runValidation(ref){ const issues=[]; window._latestValidationIssues = issues; const unitsMap={ 'hive-tyrant':'hive_tyrant','tyranid-warrior':'tyranid_warrior_brood','termagant':'termagant_brood','hormagaunt':'hormagaunt_brood','genestealer':'genestealer_brood','carnifex':'carnifex_brood','exocrine':'exocrine_brood','harpy':'harpy_brood','mycetic-spores':'mycetic_spores','dominatrix':'dominatrix' }; const roster=ref.unit_roster||{}; Object.entries(unitsMap).forEach(([appId,refKey])=>{ const m=roster[refKey]; if(!m) return; const base=UNIT_BASE[appId]||{}; if(m.points!=null && base.points!=null && Number(base.points)!==Number(m.points)){ issues.push(appId+': points '+base.points+' ≠ '+m.points); } const det = Number(m.detachment_size||0); const def = Number(UNIT_DEFAULT_MODELS[appId]||0); if(det && def && det!==def){ issues.push(appId+': detachment/default size '+def+' ≠ '+det); } const s=m.stats||{}; const norm=(v)=>String(v||'').trim(); const cmp=(kApp,kRef,label)=>{ const a=norm(base[kApp]); const b=norm(s[kRef]); if(a&&b&&a!==b) issues.push(appId+': '+label+' '+a+' ≠ '+b); }; cmp('movement','move','move'); cmp('save','save','save'); cmp('CAF','caf','CAF'); cmp('morale','morale','morale'); cmp('wounds','wounds','wounds'); });  const wRef = { 'Barbed Strangler':{range:'10"'}, 'Venom Cannon':{range:'14"'}, 'Fleshborer':{range:'6"'}, 'Devourer':{range:'8"'}, 'Stranglewebs':{range:'6"'} }; Object.entries(wRef).forEach(([name,expect])=>{ const cur=WEAPON_LIBRARY[name]||{}; if(!cur.range) issues.push('Weapon '+name+' missing in library'); else if(expect.range && String(cur.range) !== String(expect.range)) issues.push('Weapon '+name+' range '+cur.range+' ≠ '+expect.range); }); const warriorUps=(UNIT_LOADOUTS['tyranid-warrior']&&UNIT_LOADOUTS['tyranid-warrior'].upgrades)||[]; const findUp=(n)=>warriorUps.find(u=>(u.name||'').toLowerCase().includes(n.toLowerCase())); const bsw=findUp('Bone Swords'); const bstr=findUp('Barbed Strangler'); const vc=findUp('Venom Cannon'); if(bsw && (bsw.points||0)!==3) issues.push('Warrior Boneswords cost '+(bsw.points||0)+' ≠ 3'); if(bstr && (bstr.points||0)!==15) issues.push('Warrior Barbed Strangler cost '+(bstr.points||0)+' ≠ 15'); if(vc && (vc.points||0)!==15) issues.push('Warrior Venom Cannon cost '+(vc.points||0)+' ≠ 15'); const tUps=(UNIT_LOADOUTS['termagant']&&UNIT_LOADOUTS['termagant'].upgrades)||[]; const tFind=(gr)=>tUps.find(u=>(u.grants||'')===gr); const tStr=tFind('Stranglewebs'); const tDev=tFind('Devourer'); if(!tStr) issues.push('Termagant Stranglewebs upgrade missing'); else if((tStr.points||0)!==3) issues.push('Termagant Stranglewebs cost '+(tStr.points||0)+' ≠ 3'); if(!tDev) issues.push('Termagant Devourer upgrade missing'); else if((tDev.points||0)!==1) issues.push('Termagant Devourer cost '+(tDev.points||0)+' ≠ 1'); if(issues.length){ console.warn('[Validator]',issues); } else { console.info('[Validator] No mismatches'); } }

      function formationUnits(f){ let arr=[]; ['compulsory','optional'].forEach(k=> (f[k]||[]).forEach(s=> arr=arr.concat(s.units||[]))); if(f.special) arr=arr.concat(f.special.units||[]); return arr; }
      function totalModelsInFormation(f){ return formationUnits(f).reduce((s,u)=> s + Number(u.models||u.baseModels||1), 0); }
      function mostExpensiveUnitAcrossList(){ const all=(armyFormations||[]).flatMap(ff=> formationUnits(ff)); let max=null, mp=0; all.forEach(u=>{ const p=unitPoints(u); if(p>mp){ mp=p; max=u; } }); return max; }
      function validateFormationRules(){ const issues=window._latestValidationIssues||[]; (armyFormations||[]).forEach(f=>{ if(f.name==='Goff Warband'){ if(totalModelsInFormation(f)<25) issues.push('Goff Warband: at least 25 models required'); } else if(f.name==='Evil Sunz Warband'){ const bad=formationUnits(f).some(u=>{ const mv=((UNIT_BASE[u.id]&&UNIT_BASE[u.id].movement)||'').match(/(\d+)/); const n=mv?Number(mv[1]):0; return n<8; }); if(bad) issues.push('Evil Sunz Warband: all models must have Move 8+ or be embarked'); } else if(f.name==='Snakebites Warband'){ const bad=formationUnits(f).some(u=>{ const base=(UNIT_DEFAULT_MODELS[u.id]||u.baseModels||1); return base>=2; }); if(bad) issues.push('Snakebites Warband: no detachments of size 2+'); } else if(f.name==='Bad Moons Warband'){ const mx=mostExpensiveUnitAcrossList(); const present=formationUnits(f).some(u=> mx && u.id===mx.id && unitPoints(u)===unitPoints(mx)); if(!present) issues.push('Bad Moons Warband: most expensive mob must be part of the formation'); } }); window._latestValidationIssues=issues; }
      function requestRender(){ if(requestRender._t) return; requestRender._t = setTimeout(()=>{ requestRender._t=null; renderContent(); },0); }
      function updateStatusBanner(){ const el=document.getElementById('status-banner'); if(!el) return; let msg=''; if(dataStatus.loading){ msg='Loading data…'; } el.style.display = msg ? '' : 'none'; el.textContent = msg || ''; }
      function setActiveTab(t){ activeTab=t; const m=document.getElementById('account-menu'); if(m) m.style.display='none'; const links=document.querySelectorAll('.topbar a[data-tab]'); links.forEach(a=>{ a.classList.toggle('active', a.getAttribute('data-tab')===activeTab); }); requestRender(); }
      function setReferenceView(v){ referenceView=v; updateReferenceHash(); requestRender(); }
      function openReferenceHome(){ referenceView='main'; referenceDetail={ army:null, unitId:null }; referenceShowUpgrades=false; updateReferenceHash(); requestRender(); }
      function openReferenceUnits(){ referenceView='units'; referenceDetail={ army:null, unitId:null }; referenceShowUpgrades=false; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceUnit(army, unitId){ referenceView='unit-detail'; referenceDetail={ army, unitId }; updateReferenceHash(); ensureArmyMaster(army).then(()=>requestRender()); }
      function openReferenceWeapons(){ referenceView='weapons'; referenceWeapon=null; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceWeapon(name){ referenceView='weapon-detail'; referenceWeapon=String(name||''); updateReferenceHash(); requestRender(); }
      function openReferenceDetachments(){ referenceView='detachments'; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceFormations(){ referenceView='formations'; updateReferenceHash(); requestRender(); }
      function setReferenceFilter(val){ referenceQuery=String(val||''); const min=12; const shouldFilter = referenceQuery.length>=min; referenceFilter = shouldFilter ? referenceQuery : ''; clearTimeout(setReferenceFilter._t); setReferenceFilter._t = setTimeout(()=>{ if(shouldFilter || referenceQuery===''){ requestRender(); } try{ const id = referenceView==='units' ? 'ref-unit-search' : (referenceView==='weapons' ? 'ref-weapon-search' : (referenceView==='detachments' ? 'ref-detach-search' : '')); if(id){ const el=document.getElementById(id); if(el && el.focus){ el.focus(); const len = el.value ? el.value.length : 0; try{ el.setSelectionRange(len, len); }catch(e){} } } }catch(e){} }, 200); }
      function commitReferenceFilter(val){ referenceQuery=String(val||''); referenceFilter=referenceQuery; requestRender(); }
      function toggleReferenceUpgrades(){ referenceShowUpgrades=!referenceShowUpgrades; requestRender(); }

      function updateReferenceHash(){ try{ if(referenceView==='main'){ location.hash = '#ref'; } else if(referenceView==='units'){ location.hash = '#ref/units'; } else if(referenceView==='unit-detail'){ location.hash = '#ref/unit/'+encodeURIComponent(referenceDetail.army||'')+'/'+encodeURIComponent(referenceDetail.unitId||''); } else if(referenceView==='weapons'){ location.hash = '#ref/weapons'; } else if(referenceView==='weapon-detail'){ location.hash = '#ref/weapon/'+encodeURIComponent(referenceWeapon||''); } else if(referenceView==='detachments'){ location.hash = '#ref/detachments'; } else if(referenceView==='formations'){ location.hash = '#ref/formations'; } else if(referenceView==='army-rules'){ location.hash = '#ref/army-rules/'+encodeURIComponent(armyRulesFaction||''); } }catch(e){} }
      function applyReferenceHash(){ try{ const h=(location.hash||'').replace(/^#/, ''); const parts=h.split('/'); if(parts[0]!=='ref'){ return; } setActiveTab('reference'); if(parts.length===1 || !parts[1]){ openReferenceHome(); return; } if(parts[1]==='units'){ openReferenceUnits(); return; } if(parts[1]==='unit'){ const army=decodeURIComponent(parts[2]||''); const unit=decodeURIComponent(parts[3]||''); openReferenceUnit(army, unit); return; } if(parts[1]==='weapons'){ openReferenceWeapons(); return; } if(parts[1]==='weapon'){ const name=decodeURIComponent(parts[2]||''); openReferenceWeapon(name); return; } if(parts[1]==='detachments'){ openReferenceDetachments(); return; } if(parts[1]==='formations'){ openReferenceFormations(); return; } if(parts[1]==='army-rules'){ armyRulesFaction = decodeURIComponent(parts[2]||'Tyranids'); openReferenceArmyRules(); return; } openReferenceHome(); }catch(e){} }
      function toggleAccountMenu(e){}
      function openProfile(){ alert('Profile coming soon'); }

      function unitsFor(slotType){ const key=armyKey(selectedArmy); const list=ARMY_UNIT_LIST[key]||[]; if(slotType==='Special') return list; const ids=((ARMY_SLOT_FILTERS[key]||{})[slotType])||[]; return list.filter(u=>ids.includes(u.id)); }

      const SLOT_ICON_IMAGES = { 'Tyranids': { Synapse:'Images/Synapse.png', HQ:'Images/Synapse.png', Core:'Images/Core.png', Flyer:'Images/Flyer.jpg', Biotitan:'Images/Biotitan.png', Transport:'Images/Transport.png' } };
      function slotIcon(t){ const fallback={Synapse:'🧠',Core:'🛡️',Flyer:'✈️',Biotitan:'🕷️',Transport:'🚚',HQ:'💀',Support:'📦'}; const icons=SLOT_ICON_IMAGES[selectedArmy]; const url=icons&&icons[t]; return url? `<img src="${url}" class="slot-icon" alt="${t}"/>` : (fallback[t]||'⬢'); }
      function slotIcons(types){ return (types||[]).map(slotIcon).join(''); }



      // ---------- Formation & slot management ----------

      function handleArmySelection(val){ selectedArmy=val; selectedFormationName='Select a Formation'; armyFormations=[]; loadConsolidatedArmyMaster(val).then(ref=>{ if(ref){ window._lastMasterRef = ref; applyMasterBroodDefaults(ref); applyUpgradeConstraintsFromMaster(ref); buildUpgradeEffectsFromMaster(ref); buildArmyUnitsFromMaster(ref, val); } renderContent(); saveState(); }); }

      function handleFormationSelection(val){ selectedFormationName=val; saveState(); }
      function setBuilderName(val){ builderMeta.name = String(val||'New List'); saveState(); }
      function setBuilderAllegiance(val){ builderMeta.allegiance = String(val||'Loyalist'); saveState(); }
      function setBuilderPoints(val){ const n = Number(val||0); builderMeta.pointsCap = isNaN(n)?builderMeta.pointsCap:n; saveState(); }
      function listModelsCurrent(){ const total=(armyFormations||[]).flatMap(f=>[...f.compulsory,...f.optional].flatMap(s=>s.units||[])).reduce((s,u)=>s+(u.models||u.baseModels||1),0); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${builderMeta.name} — Models</h3><div class="small">Total models: ${total}</div></div></div>`; }
      function sanitizeFormations(arr){ try{ const clean=JSON.parse(JSON.stringify(arr||[])); clean.forEach(f=>{ ([...(f.compulsory||[]), ...(f.optional||[])]).forEach(s=>{ delete s._selectedUnitId; (s.units||[]).forEach(u=>{ delete u._appliedEffects; }); }); if(f.special){ delete f.special._selectedUnitId; (f.special.units||[]).forEach(u=>{ delete u._appliedEffects; }); } }); return clean; }catch(e){ return []; } }
      function saveCurrentList(){ const now=Date.now(); const payload={ id: currentListId || String(now), name: builderMeta.name, gamemode: builderMeta.gamemode, allegiance: builderMeta.allegiance, pointsCap: builderMeta.pointsCap, faction: selectedArmy, formations: sanitizeFormations(armyFormations), createdAt: currentListId ? (savedLists.find(x=>x.id===currentListId)?.createdAt || now) : now, updatedAt: now }; const idx = savedLists.findIndex(x=>x.id===payload.id); if(idx>-1) savedLists[idx]=payload; else savedLists.push(payload); currentListId = payload.id; persistSavedLists(); requestRender(); }
function autoSaveList(reason){ if(selectedArmy==='Select Army') return; const now=Date.now(); const payload={ id: currentListId || String(now), name: builderMeta.name, gamemode: builderMeta.gamemode, allegiance: builderMeta.allegiance, pointsCap: builderMeta.pointsCap, faction: selectedArmy, formations: sanitizeFormations(armyFormations), createdAt: currentListId ? (savedLists.find(x=>x.id===currentListId)?.createdAt || now) : now, updatedAt: now }; const idx=savedLists.findIndex(x=>x.id===payload.id); if(idx>-1) savedLists[idx]=payload; else savedLists.push(payload); currentListId=payload.id; persistSavedLists(); }
      function viewCompact(){ const lines=[]; lines.push(`${builderMeta.name} — ${selectedArmy} — ${builderMeta.pointsCap} pts`); (armyFormations||[]).forEach(f=>{ lines.push(`- ${f.name}: ${formationPoints(f)} pts`); [f.compulsory,f.optional].forEach(arr=>arr.forEach(s=> (s.units||[]).forEach(u=>{ lines.push(`  • ${u.name} (${unitPoints(u)} pts)`);}))); if(f.special) (f.special.units||[]).forEach(u=>lines.push(`  • ${u.name} (${unitPoints(u)} pts)`)); }); const text = lines.join('\n'); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${builderMeta.name} — Compact View</h3><pre class="compact-pre">${text}</pre><div style="display:flex;gap:8px;justify-content:flex-end"><button class="btn" onclick="closeModal()">Close</button><button class="btn btn-green" onclick="navigator.clipboard&&navigator.clipboard.writeText('${text.replace(/'/g,"\\'")}')">Copy</button></div></div></div>`; }
      function deleteCurrentList(){ if(!currentListId){ alert('No saved list to delete'); return; } const idx=savedLists.findIndex(x=>x.id===currentListId); if(idx>-1){ savedLists.splice(idx,1); persistSavedLists(); currentListId=null; alert('Deleted'); } }



      function addFormation(){

        if(!selectedArmy || selectedArmy === 'Select Army'){ alert('Choose an army'); return; }

        if(!selectedFormationName || selectedFormationName === 'Select a Formation'){ alert('Choose a formation'); return; }

        const tpl = FORMATIONS[selectedFormationName];

        if(!tpl){ alert('Formation not available'); return; }

        if(armyFormations.length) armyFormations[armyFormations.length-1].collapsed = true;

        const toSlots = (arr)=> (arr||[]).flatMap(s => Array.from({length: s.max||1}, (_,i) => ({ type:s.type, label:s.label, units:[], _selectedUnitId:'', max:1, min: (s.min>0?1:0), _group:{ type:s.type, label:s.label, index:i+1, groupMin:s.min||0, groupMax:s.max||1 } })));

        const compulsory = toSlots(tpl.compulsory);

        const optional   = toSlots(tpl.optional);

        const special    = tpl.special ? ({...tpl.special, units:[], _selectedUnitId:''}) : null;

        armyFormations.push({ name:selectedFormationName, army:selectedArmy, collapsed:false, compulsory, optional, special });

        selectedFormationName = 'Select a Formation';

        const formSelect = document.getElementById('formation-select');

        if(formSelect) formSelect.value = 'Select a Formation';

        requestRender();
        saveState();

      }



      function removeFormation(idx){ armyFormations.splice(idx,1); requestRender(); saveState(); }
      function toggleCollapse(idx){ armyFormations[idx].collapsed = !armyFormations[idx].collapsed; requestRender(); saveState(); }
      function cloneFormation(idx){ const copy = JSON.parse(JSON.stringify(armyFormations[idx])); copy.name = (copy.name||'Formation') + ' (copy)'; armyFormations.splice(idx+1,0,copy); requestRender(); saveState(); }



      function setSlotSelection(fIdx,section,sIdx,val){ const slot = armyFormations[fIdx][section][sIdx]; if(!slot) return; slot._selectedUnitId = val; if(val){ addUnitToSlot(fIdx,section,sIdx); } }



      function addUnitToSlot(fIdx,section,sIdx){

        const slot = armyFormations[fIdx][section][sIdx];

        if(!slot) return;

        if(!slot._selectedUnitId) return alert('Select a unit');
        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const base = list.find(u=>u.id === slot._selectedUnitId);
        if(!base) return;



        const load = UNIT_LOADOUTS[base.id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[]};

        const weapons = (load.weapons||[]).filter(w=>w.base).map(w=>({ id:w.id, name:w.name, src:w.src, points: (WEAPON_LIBRARY[w.src] && WEAPON_LIBRARY[w.src].points) || 0 }));

        const defaults = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[base.id]) || 1;
        const instance = {
          ...base,
          qty: 1,
          weapons,
          upgrades: [],
          psychic: [],
          notes: [],
          _appliedEffects: {},
          models: defaults,
          baseModels: defaults
        };
        if((slot.units||[]).length){ slot.units[0] = instance; } else { slot.units.push(instance); }

        slot._selectedUnitId = base.id;

        renderContent();
        saveState();

      }



      function addUnitToSpecial(fIdx,unitId){

        const slot = armyFormations[fIdx].special;
        if(!slot) return;

        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const candidate = list.find(u=>u.id===unitId);
        if(!candidate) return alert('Invalid special selection');
        if(slot.allowedTypes && slot.allowedTypes.length && !slot.allowedTypes.includes(candidate.slotType)){ alert('This unit type is not allowed in this special slot'); return; }

        const load = UNIT_LOADOUTS[candidate.id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[]};
        const weapons = (load.weapons||[]).filter(w=>w.base).map(w=>({ id:w.id, name:w.name, src:w.src, points: (WEAPON_LIBRARY[w.src] && WEAPON_LIBRARY[w.src].points) || 0 }));

        const defaults = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[candidate.id]) || 1;
        const instance = {...candidate, qty:1, weapons, upgrades:[], psychic:[], notes:[], _appliedEffects:{}, models: defaults, baseModels: defaults};
        if((slot.units||[]).length){ slot.units[0] = instance; } else { slot.units.push(instance); }
        slot._selectedUnitId = candidate.id;
        renderContent();
        saveState();

      }



      function removeUnit(fIdx,section,sIdx,uIdx){ const slot = armyFormations[fIdx][section][sIdx]; if(!slot) return; slot.units.splice(uIdx,1); slot._selectedUnitId=''; requestRender(); saveState(); }
      function removeSpecialUnit(fIdx,uIdx){ const slot = armyFormations[fIdx].special; if(!slot) return; slot.units.splice(uIdx,1); slot._selectedUnitId=''; requestRender(); saveState(); }



      // ---------- points & render helpers ----------

      function unitPoints(u){
        const base = (UNIT_BASE[u.id] && UNIT_BASE[u.id].points) || 0;
        const ups = (u.upgrades||[]).reduce((s,x)=>{
          const name = String(x.name||'');
          const id = String(x.id||'');
          if(/Increase\s+Brood\s+size/i.test(name) && !id.startsWith('u_bsize_apply_')) return s;
          if(/replace\s+one\s+genestealer\s+w\/\s+broodlord/i.test(name)) return s;
          return s + (x.points||0);
        },0);
        const wep = (u.weapons||[]).reduce((s,x)=>s+(x.points||0),0);
        const psy = (u.psychic||[]).reduce((s,x)=>s+(x.points||0),0);
        return base + ups + wep + psy;
      }

      function formationPoints(f){

        let s=0;

        ['compulsory','optional'].forEach(k => (f[k]||[]).forEach(slot => (slot.units||[]).forEach(u => s += unitPoints(u))));

        if(f.special) (f.special.units||[]).forEach(u => s+= unitPoints(u));

        return s;

      }



      // ---------- Modal & dynamic UI (unchanged behavior) ----------

      function openEditModal(fIdx,section,sIdx,uIdx){ editContext = {fIdx,section,sIdx,uIdx}; window.editContext = editContext; renderModal(); }

      function closeModal(){ editContext=null; window.editContext=null; const root=document.getElementById('modal-root'); if(root) root.innerHTML=''; const last=window._lastFocused; if(last && last.focus){ try{ last.focus(); }catch(e){} } }
      function trapFocus(container){ try{ const focusable=container.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); const first=focusable[0]; const last=focusable[focusable.length-1]; container.addEventListener('keydown', function(e){ if(e.key==='Tab'){ if(focusable.length===0) return; if(e.shiftKey){ if(document.activeElement===first){ e.preventDefault(); last.focus(); } } else { if(document.activeElement===last){ e.preventDefault(); first.focus(); } } } }); }catch(e){} }

      function currentLoadout(id){ return UNIT_LOADOUTS[id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'+0', baseWounds:1, specialRules:[]}; }

      function unitHasUpgrade(unit,upgradeId){ return (unit.upgrades||[]).some(u=>u.id === upgradeId); }

      function weaponConstraintsFor(id){ const r = WEAPON_CONSTRAINTS[id]; return r || { mutexPairs:[], disableWhenUpgrade:{} }; }
      function computeDisabledWeapons(unit, checked, activeUpgrades){ const rules=weaponConstraintsFor(unit.id); const disable=new Set(), hide=new Set(); (rules.mutexPairs||[]).forEach(([a,b])=>{ if(checked.includes(a)) disable.add(b); if(checked.includes(b)) disable.add(a); }); const upsActive = new Set(activeUpgrades||[]); Object.entries(rules.disableWhenUpgrade||{}).forEach(([upId,list])=>{ if(upsActive.has(upId)) list.forEach(n=>{ disable.add(n); hide.add(n); }); }); return { disable, hide }; }
      function enforceWeaponConstraints(){ if(!editContext) return; const {fIdx,section,sIdx,uIdx}=editContext; const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx]; const unit=slot&&slot.units&&slot.units[uIdx]; if(!unit) return; const checked=Array.from(document.querySelectorAll('.modal-weapon-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-name')); const activeUps = Array.from(document.querySelectorAll('.modal-upgrade-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id')).concat(Array.from(document.querySelectorAll('.modal-special-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id'))); const {disable, hide} = computeDisabledWeapons(unit, checked, activeUps); document.querySelectorAll('.modal-weapon-checkbox').forEach(cb=>{ const n=cb.getAttribute('data-name'); const row=cb.closest('tr'); const dis=disable.has(n); cb.disabled = dis; if(row){ row.style.opacity = dis ? 0.5 : ''; row.style.display = hide.has(n) ? 'none' : 'table-row'; } }); }
      function filterWepsByConstraints(unitId, weps, ups){ const rules=weaponConstraintsFor(unitId); let out=weps.slice(); (rules.mutexPairs||[]).forEach(([a,b])=>{ const hasA=out.find(w=>w.name===a); const hasB=out.find(w=>w.name===b); if(hasA&&hasB){ out = out.filter(w=>w.name!==b); } }); Object.entries(rules.disableWhenUpgrade||{}).forEach(([upId,list])=>{ if((ups||[]).some(u=>u.id===upId)) out = out.filter(w=>!list.includes(w.name)); }); return out; }
      const UPGRADE_EFFECTS = {};
      let RULE_NAME_CATALOG = [];
      async function loadTyranidRules(){ return; }
      let RULES_INDEX = {};
      const CROSS_TRAIT_INDEX = {
        'Light':'General-purpose small arms; effective versus infantry',
        'Light AT':'Anti-vehicle light munitions; reduced effectiveness vs heavy armor',
        'Anti-Tank':'Designed to penetrate armored targets',
        'Anti-Infantry':'Optimized to defeat infantry formations',
        'Beam':'Line attack; affects all formations under the line',
        'Armorbane':'Enhanced armor penetration; improves effectiveness vs saves',
        'Ignore Cover':'Targets do not receive cover benefits',
        'Ignores Cover':'Targets do not receive cover benefits',
        'Blast':'Area effect; uses a template size',
        'Torrent':'Short-range stream; continuous effect along a path',
        'Rapid Fire':'Double dice if stationary',
        'Rapid-Fire':'Double dice if stationary',
        'Rend':'Improved damage or penetration on high rolls',
        'Parry':'Force opponent to re-roll one die in close combat',
        'Brutal':'Increases lethality in melee',
        'Unreliable':'May suffer malfunctions or reduced consistency',
        'Arc':'Firing arc restriction; only targets within specified arc',
        'SkyFire':'Can target Flyers; -2 To Hit against non-Flyers',
        'Shieldbane':'',
        'Heavy Barrage':'',
        'Hunger':'',
        'Attract':'',
        'Psychic Power':'',
        'Jink':'Reactive save against shooting attacks',
        'Interceptor':'Can target units arriving from reserves',
        'Flyer':'Aerial movement mode with special engagement rules',
        'Hover':'May operate as ground skimmer this turn',
        'Deep Strike':'Deploy from reserves to a chosen location following placement rules',
        'Infiltrate':'Forward deployment using special placement rules',
        'Winged':'Improved movement and aerial engagement capability',
        'Synapse':'Nearby friendly units auto-pass morale checks except psychic tests',
        'Instinct':'Units outside Synapse must follow their instinct subtype (Hunt/Rampage/Nest)',
        'Hunt':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Rampage':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Nest':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Feel No Pain':'Roll to ignore suffered wounds',
        'Invulnerable Save':'Save roll that ignores AP modifiers',
        'Bulky':'Counts more for transport/movement constraints',
        'Implacable':'Resists falling back; steady advance',
        'Regenerate':'Recover lost wounds during end phase',
        'Drop Pod':'Deploy via descent; assault transport',
        'Commander':'Provides command aura or special order access to nearby units',
        'Void Shields':'Energy shield layers that absorb hits before Wounds; some traits bypass or reduce shields',
        'God-engine':'Titanic construct with unique resilience and rules interactions',
        'Jump Packs':'Enhanced movement; treats as aerial leap with special restrictions'
      };
      function _normKey(s){ return String(s||'').trim().toLowerCase().replace(/_/g,' ').replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,' ').trim(); }
      function renderTraitsCell(val){ const arr = Array.isArray(val) ? val : String(val||'').split(';').map(s=>s.trim()).filter(Boolean); if(!arr.length) return '-'; return arr.map(t=>{ const k=t.split('(')[0].split(':')[0].trim(); const rest=t.slice(k.length); return '<span class="rule-key" data-rule="'+k+'" style="text-decoration:underline;font-style:italic;cursor:pointer" onclick="openRuleDialog(\''+k+'\')">'+k+'</span>'+rest; }).join(', '); }
      function renderRuleText(r){ const txt=String(r||''); const base = txt.split(':')[0].split('(')[0].trim(); const afterBase = txt.slice(base.length); const subtype = txt.includes(':') ? txt.split(':')[1].split('(')[0].trim() : ''; if(subtype){ const tail = txt.slice((base+': '+subtype).length); return '<div class="muted small">- <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+base+'" onclick="openRuleDialog(\''+base+'\')">'+base+'</span>: <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+subtype+'" onclick="openRuleDialog(\''+subtype+'\')">'+subtype+'</span>'+tail+'</div>'; } return '<div class="muted small">- <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+base+'" onclick="openRuleDialog(\''+base+'\')">'+base+'</span>'+afterBase+'</div>'; }
      function getRuleEffect(k){ return RULES_INDEX[_normKey(k)] || ''; }
      function showRulePopover(target, key){ document.querySelectorAll('.rule-popover').forEach(p=>p.remove()); const eff=getRuleEffect(key)||key; const pop=document.createElement('div'); pop.className='rule-popover'; pop.textContent=eff; document.body.appendChild(pop); const rect=target.getBoundingClientRect(); const pad=6; let left=rect.left; let top=rect.bottom + pad; const vw=document.documentElement.clientWidth; const vh=document.documentElement.clientHeight; const pw=pop.offsetWidth||280; const ph=pop.offsetHeight||60; if(left+pw>vw) left=Math.max(8, vw-pw-8); if(top+ph>vh) top=Math.max(8, rect.top-ph-pad); pop.style.left=left+'px'; pop.style.top=top+'px'; function close(){ if(pop && pop.remove) pop.remove(); document.removeEventListener('click', onDoc, true); } function onDoc(e){ if(!pop.contains(e.target) && e.target!==target) close(); } setTimeout(()=>document.addEventListener('click', onDoc, true),0); }
      function openRuleDialog(key){ try{ Array.from(document.querySelectorAll('.rule-popover,.rule-dialog-backdrop')).forEach(el=>el.remove()); }catch(e){} const eff=getRuleEffect(key)||key; const root=document.getElementById('modal-root')||document.body; const wrap=document.createElement('div'); wrap.className='rule-dialog-backdrop'; wrap.style.position='fixed'; wrap.style.inset='0'; wrap.style.background='rgba(0,0,0,.4)'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center'; wrap.style.zIndex='100000'; const box=document.createElement('div'); box.className='rule-dialog'; box.style.background='#163010'; box.style.color='#e6eef8'; box.style.border='1px solid #245017'; box.style.padding='12px'; box.style.borderRadius='8px'; box.style.boxShadow='0 12px 32px rgba(0,0,0,.6)'; box.style.maxWidth='420px'; box.style.width='90%'; const title=document.createElement('div'); title.className='rule-title'; title.style.fontWeight='800'; title.style.marginBottom='6px'; title.textContent=key; const text=document.createElement('div'); text.className='rule-text'; text.style.whiteSpace='pre-wrap'; text.textContent=eff; const btns=document.createElement('div'); btns.style.display='flex'; btns.style.justifyContent='flex-end'; btns.style.gap='8px'; btns.style.marginTop='8px'; const close=document.createElement('button'); close.className='btn btn-sm btn-blue'; close.textContent='Close'; close.onclick=()=>{ if(wrap&&wrap.remove) wrap.remove(); }; btns.appendChild(close); box.appendChild(title); box.appendChild(text); box.appendChild(btns); wrap.appendChild(box); wrap.onclick=(e)=>{ if(e.target===wrap){ wrap.remove(); } }; root.appendChild(wrap); }
      async function initRulesIndex(){ try{ const dict={}; const ref=window._lastMasterRef||{}; const add=(n,e)=>{ if(!n) return; dict[_normKey(n)] = e||''; RULE_NAME_CATALOG.push(String(n||'').toLowerCase()); };
        Object.entries(CROSS_TRAIT_INDEX).forEach(([n,e])=>add(n,e));
        try{ const sr=ref.special_rules_library||{}; Object.entries(sr).forEach(([n,e])=>add(slugToName(n), e)); }catch(e){}
        try{ const orders=ref.unique_orders||{}; Object.values(orders).forEach(o=>add(o.name||slugToName(o.id||''), o.description||o.effect||'')); }catch(e){}
        try{ const fr=(ref.faction_info&&ref.faction_info.faction_rules)||[]; fr.forEach(r=>add(r.name, r.effect||r.description||'')); }catch(e){}
        try{ const mr=await fetch('PDF/MainRules.json',{cache:'no-store'}).then(r=>r.ok?r.json():null); if(mr){ Object.entries(mr.traitLibrary||{}).forEach(([slug,effect])=>add(slug,effect)); Object.values(mr.unit_roster||{}).forEach(u=>{ (u.special_rules||[]).forEach(sr=>add(sr,'')); }); } }catch(e){}
        const lib=ref.weaponLibrary||{}; Object.values(lib).forEach(def=>{ const traits = Array.isArray(def.traits)? def.traits : String(def.traits||'').split(';').map(s=>s.trim()).filter(Boolean); traits.forEach(t=>{ const k=String(t).split('(')[0].split(':')[0].trim(); add(k, dict[_normKey(k)]||''); }); });
        Object.values(UNIT_LOADOUTS||{}).forEach(load=>{ (load.specialRules||[]).forEach(r=>{ const k=String(r).split(':')[0].split('(')[0].trim(); add(k, dict[_normKey(k)]||''); }); (load.psychicPowers||[]).forEach(p=>add(p.name,p.desc||'')); (load.upgrades||[]).forEach(u=>add(u.name,u.desc||'')); });
        RULES_INDEX=dict; }catch(e){ RULES_INDEX={}; } }
      function deriveEffectsFromText(name, desc){ const txt = (name+' '+(desc||'')).toLowerCase(); const rules=[]; const stats={}; RULE_NAME_CATALOG.forEach(n=>{ if(n && txt.includes(n)) rules.push(n.replace(/\(x?\)/i,'')); }); const syn = txt.match(/synapse\s*\(?\s*(\d+)\s*\"?\s*\)?/i); if(/synapse/i.test(txt)){ rules.push('Synapse'+(syn?` (${syn[1]}\")`:'')); } if(/the\s+horror/i.test(txt)) rules.push('The Horror'); if(/winged|flying/i.test(txt)) rules.push('Winged'); if(/feel\s+no\s+pain/i.test(txt)) rules.push('Feel No Pain'); const caf = txt.match(/caf\s*(?:becomes)?\s*\+?(-?\d+)/i); if(caf) stats.CAF = '+'+caf[1]; const w = txt.match(/wounds\s*=?\s*(\d+)/i); if(w) stats.Wounds = Number(w[1]); const mov = txt.match(/movement(?:\s+profile)?\s*(\d+)\"/i); if(mov) stats.Movement = mov[1]+'"'; if(/flying/.test(txt) && stats.Movement) stats.Movement = stats.Movement+' (Flying)'; return { rules, stats }; }
      function buildUpgradeEffects(){ Object.entries(UNIT_LOADOUTS).forEach(([uid,load])=>{ (load.upgrades||[]).forEach(u=>{ UPGRADE_EFFECTS[u.id] = deriveEffectsFromText(u.name||'', u.desc||''); }); }); }
      function buildUpgradeEffectsFromMaster(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const ups=(data.upgrades||[]); const load=(UNIT_LOADOUTS[appId]||{}); ups.forEach(u=>{ const name=String(u.name||u.description||''); const eff=deriveEffectsFromText(name, u.description||''); const match=(load.upgrades||[]).find(x=> (x.name||'').toLowerCase().includes(String(u.name||'').toLowerCase().split(' (')[0]) ); if(match){ UPGRADE_EFFECTS[match.id] = eff; } }); }); }catch(e){} }
      async function ensurePDFJS(){ if(window.pdfjsLib) return; const head=document.head||document.getElementsByTagName('head')[0]; const s=document.createElement('script'); s.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; head.appendChild(s); await new Promise(r=>{ s.onload=r; s.onerror=r; }); const w=document.createElement('script'); w.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; head.appendChild(w); await new Promise(r=>{ w.onload=r; w.onerror=r; }); if(window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) window.pdfjsLib.GlobalWorkerOptions.workerSrc=w.src; }
      async function parsePDFToText(url){ try{ const key='pdf_cache_'+url; const cached=localStorage.getItem(key); if(cached){ return cached; } await ensurePDFJS(); const d=await window.pdfjsLib.getDocument({ url }).promise; let out=''; for(let i=1;i<=d.numPages;i++){ const p=await d.getPage(i); const tc=await p.getTextContent(); out+=tc.items.map(it=>it.str).join(' ')+'\n'; } try{ localStorage.setItem(key,out); }catch(e){} return out; }catch(e){ return ''; } }
      function extractFromPDFText(txt){ const data={ units:{} }; const norm=(s)=>s.toLowerCase(); if(/genestealer\s+brood/i.test(txt)){ data.units['genestealer']={ baseWeapon:{ name:'Rending Claws', traits:'Rend' }, upgrades:[{ id:'u_broodlord', name:'Broodlord (Model Upgrade)', points:20, type:'MODEL_UPGRADE', desc:'CAF +7; Synapse (6\") and The Horror for that model only.' }] }; } if(/hive\s+tyrant/i.test(txt) && /wings/i.test(txt)){ data.units['hive-tyrant']=data.units['hive-tyrant']||{}; const ups=(data.units['hive-tyrant'].upgrades=data.units['hive-tyrant'].upgrades||[]); ups.push({ id:'u_wings', name:'Add Wings', points:20, type:'MODEL_UPGRADE', desc:'Movement profile 10\"; Winged' }); } return data; }
      function applyExtractedData(payload){ Object.entries(payload.units||{}).forEach(([id,info])=>{ UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; if(info.baseWeapon){ const exists=(UNIT_LOADOUTS[id].weapons||[]).some(w=>w.name===info.baseWeapon.name); if(!exists) UNIT_LOADOUTS[id].weapons.unshift({ id:'w_pdf_'+id, name:info.baseWeapon.name, src:info.baseWeapon.name, base:true }); WEAPON_LIBRARY[info.baseWeapon.name]=WEAPON_LIBRARY[info.baseWeapon.name]||{ range:'-', dice:'-', toHit:'-', AP:'-', traits:info.baseWeapon.traits||'', points:0 }; }
        (info.upgrades||[]).forEach(u=>{ const has=(UNIT_LOADOUTS[id].upgrades||[]).some(x=>x.name===u.name); if(!has) UNIT_LOADOUTS[id].upgrades.push(u); UPGRADE_EFFECTS[u.id]=deriveEffectsFromText(u.name,u.desc); });
        const ref=window._lastMasterRef; if(ref && ref.unit_roster){ const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const kMatch=Object.keys(ref.unit_roster).find(k=>norm(k)===id); if(kMatch){ const upArr=ref.unit_roster[kMatch].upgrades = ref.unit_roster[kMatch].upgrades||[]; (info.upgrades||[]).forEach(u=>{ if(!upArr.some(x=>String(x.name||'')===String(u.name||''))) upArr.push({ name:u.name, cost:u.points||0 }); }); const lib=ref.weaponLibrary = ref.weaponLibrary||{}; const slug=(s)=>String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); if(info.baseWeapon){ const wslug=slug(info.baseWeapon.name); lib[wslug]=lib[wslug]||{ range:'-', dice:'-', toHit:'-', ap:'-', traits: [] }; } const key=armyKey(selectedArmy); try{ localStorage.setItem('xenos_master_'+key, JSON.stringify(ref)); }catch(e){} } }
      }); }
      async function ingestPDFDocs(){ try{ const files=['PDF/LI_HiveWar_02.pdf','PDF/LI_Xenos_04.pdf','PDF/Legions Imperialis Rulebook - Optimised.pdf']; for(const f of files){ const t=await parsePDFToText(f); if(t) applyExtractedData(extractFromPDFText(t)); } }catch(e){} }

      async function loadBroodSize(){ return; }

      async function loadWeaponUpgrades(){ return; }



      function onModalUpgradeToggle(){
        const swarmCount = document.getElementById('upcnt-u_swarm');
        const isSwarmActive = swarmCount && Number(swarmCount.value||0)>0;
        const cafBlock = document.getElementById('modal-caf-block');
        const woundsBlock = document.getElementById('modal-wounds-block');
        if(cafBlock) cafBlock.style.display = isSwarmActive ? '' : 'none';
        if(woundsBlock) woundsBlock.style.display = isSwarmActive ? '' : 'none';
        const effectPill = document.getElementById('modal-effect-pill');
        if(effectPill){ if(isSwarmActive) effectPill.textContent = 'Swarm Lord effect: CAF becomes +14; Wounds = 3'; effectPill.style.display = isSwarmActive ? '' : 'none'; }
        enforceWeaponConstraints();
        updateSpecialRulesBlock();
        scheduleUpdateTotals();
      }



      function setModalUnitSizeLabel(models){ const root=document.getElementById('modal-root'); const lbl = root && root.querySelector('.modal-drawer #bsize-label'); if(!lbl) return; const {fIdx,section,sIdx,uIdx}=window.editContext||{}; const slot=(section==='special')?(armyFormations[fIdx]&&armyFormations[fIdx].special):(armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]); const unit=slot&&slot.units&&slot.units[uIdx]; const pts=unit? unitPoints(unit) : ''; lbl.innerHTML = pts!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts + ' PTS</span>') : ('Unit size: ' + models); lbl.setAttribute('data-models', String(models)); }
      function scheduleUpdateTotals(){ try{ requestAnimationFrame(()=>updateModalTotals()); }catch(e){ setTimeout(updateModalTotals,0); } }
      function updateModalTotals(){

        const ptsEl = document.getElementById('modal-total-points');

        if(!ptsEl) return;

        const weBoxes = Array.from(document.querySelectorAll('.modal-weapon-checkbox'));
        const upBoxes = Array.from(document.querySelectorAll('.modal-upgrade-checkbox'));
        const psyBoxes = Array.from(document.querySelectorAll('.modal-psychic-checkbox'));
        const countInputs = Array.from(document.querySelectorAll('.modal-upgrade-count'));

        let total = 0;

        weBoxes.filter(b=>b.checked && b.closest('tr') && b.closest('tr').style.display !== 'none').forEach(b=>{

          const src = b.getAttribute('data-src');

          total += (WEAPON_LIBRARY[src] && WEAPON_LIBRARY[src].points) || 0;

        });

        upBoxes.filter(b=>b.checked).forEach(b=>{

          total += Number(b.getAttribute('data-points') || 0);

        });

        // Add BROOD_SIZE counts (paired with checkboxes)
        countInputs.forEach(inp=>{
          const id = inp.getAttribute('data-upid');
          const checked = upBoxes.some(b=>b.getAttribute('data-id')===id && b.checked);
          if(!checked) return;
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });
        // Add BROOD_SIZE counts from Unit size controls (no checkbox)
        countInputs.filter(inp=> (inp.getAttribute('data-type')||'')==='BROOD_SIZE').forEach(inp=>{
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const id = inp.getAttribute('data-upid') || (inp.id||'').replace('upcnt-','');
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });
        // Add per-model weapon swap counts (rows without data-upid)
        countInputs.filter(inp=>!inp.getAttribute('data-upid')).forEach(inp=>{
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const id = (inp.id||'').replace('upcnt-','');
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });

        // Include special single-model upgrades
        const specialBoxes = Array.from(document.querySelectorAll('.modal-special-checkbox'));
        specialBoxes.filter(b=>b.checked).forEach(b=>{
          const id = b.getAttribute('data-id');
          const inp = document.getElementById('upcnt-'+id);
          const pp = Number((inp && inp.getAttribute('data-points')) || b.getAttribute('data-points') || 0);
          const c = Number((inp && inp.value) || 1);
          total += c * pp;
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });

        psyBoxes.filter(b=>b.checked).forEach(b=>{

          total += Number(b.getAttribute('data-points') || 0);

        });

        if(window.editContext){ const {fIdx,section,sIdx,uIdx}=window.editContext; const slot = (section==='special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx]; const unit = slot && slot.units && slot.units[uIdx]; if(unit){ const models = Number(unit.models || (UNIT_DEFAULT_MODELS[unit.id]||1)); const totalPts = unitPoints(unit); const root=document.getElementById('modal-root'); const lbl = root && root.querySelector('.modal-drawer #bsize-label'); if(lbl){ lbl.innerHTML = 'Unit size: ' + models + ' <span class="cost">' + totalPts + ' PTS</span>'; lbl.setAttribute('data-models', String(models)); }
          const sumEl = document.getElementById('modal-unit-summary'); if(sumEl){ const costEl=document.getElementById('modal-unit-cost'); if(costEl) costEl.textContent = totalPts + ' PTS'; const valBtn=document.getElementById('modal-unit-val'); if(valBtn) valBtn.textContent = String(models); const incLbl=document.getElementById('modal-inc-label'); const baseM=(UNIT_DEFAULT_MODELS[unit.id]||1); if(incLbl) incLbl.textContent = 'Increase by: +' + Math.max(0, models - baseM); } const baseWeps = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base); baseWeps.forEach(bw=>{ const rows = Array.from(document.querySelectorAll(`.modal-upgrade-row[data-replaces="${bw.name}"]`)); rows.forEach(r=>{ const iid=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+iid); if(inp) inp.max = String(models); }); const sum = rows.reduce((s,r)=>{ const id=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+id); const v=Number(inp && inp.value || 0); return s+v; },0); const remain = Math.max(0, models - sum); const cb = Array.from(document.querySelectorAll('.modal-weapon-checkbox')).find(b=>b.getAttribute('data-name')===bw.name); if(cb){ cb.checked = remain>0; } const span = document.getElementById('base-rem-'+bw.id); if(span){ span.textContent = remain>0 ? `(x${remain})` : ''; } }); Array.from(document.querySelectorAll('.modal-upgrade-row')).filter(r=>{ const t=r.getAttribute('data-type')||''; return t.startsWith('WEAPON_SWAP'); }).forEach(r=>{ const iid=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+iid); if(inp) inp.max = String(models); }); } }

        if(window.editContext){ const {fIdx,section,sIdx,uIdx}=window.editContext; const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx]; const unit=slot&&slot.units&&slot.units[uIdx]; if(unit){ const bsize = (unit.upgrades||[]).find(u=> (u.type==='BROOD_SIZE' && String(u.id||'').startsWith('u_bsize_apply_')) ); if(bsize){ total += Number(bsize.points||0); } } }
        ptsEl.textContent = total + ' pts';
        try{ updateBroodSummary(); }catch(e){}
      }
      function updateBroodSummary(){
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        const unit = slot && slot.units && slot.units[uIdx];
        const el = document.getElementById('bsize-summary'); if(!el || !unit) return;
        const baseNames = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base).map(w=>w.name);
        const rows = Array.from(document.querySelectorAll('.modal-upgrade-row')).filter(r=> baseNames.includes(r.getAttribute('data-replaces')||''));
        const items = rows.map(r=>{ const id=r.getAttribute('data-upgrade'); const cnt=Number((document.getElementById('upcnt-'+id)||{}).value||0); const grant=r.getAttribute('data-grants')||''; return {grant,cnt}; }).filter(i=>i.cnt>0);
        const def = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id]) || 1;
        const bInp = document.getElementById('upcnt-u_bsize_fallback_'+unit.id);
        const step = Number(bInp && bInp.getAttribute('data-step') || 1);
        const plus = Number(bInp && bInp.value || 0) * step;
        const models = Math.max(def + plus, Number(unit.models||def));
        const sum = items.reduce((s,i)=>s+i.cnt,0);
        const baseRemain = Math.max(0, models - sum);
        el.textContent = items.length ? `Replacements: ${items.map(i=> `${i.grant} x${i.cnt}`).join(', ')} • Base remaining: ${baseRemain}` : `Base remaining: ${baseRemain}`;
      }

      function bumpUpgradeCount(id, delta){
        const inp = document.getElementById('upcnt-'+id);
        if(!inp) return;
        const row = document.querySelector(`.modal-upgrade-row[data-upgrade="${id}"]`);
        let val = Number(inp.value || 0);
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        const unit = slot && slot.units && slot.units[uIdx];
        const def = unit ? ((UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id])||1) : 1;
        const bInp = unit ? document.getElementById('upcnt-u_bsize_fallback_'+unit.id) : null;
        const step = Number(bInp && bInp.getAttribute('data-step') || 1);
        const plus = Number(bInp && bInp.value || 0) * step;
        const lbl = document.getElementById('bsize-label');
        const lblAttr = lbl && lbl.getAttribute('data-models');
        const lblVal = lblAttr ? Number(lblAttr) : (lbl ? Number(((lbl.textContent||'').match(/\d+/)||[])[0]||def) : def);
        const models = unit ? Math.max(lblVal, def + plus, Number(unit.models||def)) : Math.max(lblVal, def + plus);
        const replaces = row ? (row.getAttribute('data-replaces') || '') : '';
        if(replaces){
          const peers = Array.from(document.querySelectorAll(`.modal-upgrade-row[data-replaces="${replaces}"]`)).map(r=>{ const iid = r.getAttribute('data-upgrade'); const i = document.getElementById('upcnt-'+iid); return { id: iid, val: Number(i && i.value || 0) }; });
          const sumOthers = peers.filter(p=>p.id!==id).reduce((s,p)=>s+p.val,0);
          const allowed = Math.max(0, models - sumOthers);
          val += delta;
          if(val < 0) val = 0;
          if(val > allowed) val = allowed;
          inp.max = String(allowed);
        } else {
          let max = models;
          const typ = row ? (row.getAttribute('data-type')||'') : '';
          const name = row ? (row.getAttribute('data-name')||'') : '';
          if(typ==='MODEL_UPGRADE' && /broodlord/i.test(name)){
            const others = countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord');
            max = val>0 ? 1 : Math.max(0, 1 - others);
          } else if(typ==='MODEL_UPGRADE') {
            max = 1;
          }
          val += delta;
          if(val < 0) val = 0;
          if(val > max) val = max;
          inp.max = String(max);
        }
        inp.value = val;
        const disp = document.getElementById('upval-'+id);
        if(disp) disp.textContent = String(val);
        const rm = document.getElementById('uprm-'+id);
        if(rm) rm.style.display = val>0 ? '' : 'none';
        updateModalTotals(); try{ updateBroodSummary(); }catch(e){}
      }
      window.bumpUpgradeCount = bumpUpgradeCount;
      function onBroodSizeSelect(id, val, selId, selEl){
        const inp = document.getElementById('upcnt-'+id);
        if(!inp) return;
        const v = Number(val||0);
        inp.value = String(v);
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        const unit = slot && slot.units && slot.units[uIdx];
        if(unit){
          const def = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id])||1;
          const step = Number(inp.getAttribute('data-step')||1);
          const models = def + v*step;
          const container = (selEl && selEl.parentElement) || (inp && inp.parentElement);
          const lblEl = container ? container.querySelector('#bsize-label') : document.querySelector('.modal-drawer #bsize-label');
          if(lblEl){ const pts = unit ? unitPoints(unit) : ''; lblEl.innerHTML = pts!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts + ' PTS</span>') : ('Unit size: ' + models); lblEl.setAttribute('data-models', String(models)); } else { setModalUnitSizeLabel(models); }
          setTimeout(()=>{ const contLbl = (container && container.querySelector('#bsize-label')) || document.querySelector('.modal-drawer #bsize-label'); if(contLbl){ const pts2 = unit ? unitPoints(unit) : ''; contLbl.innerHTML = pts2!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts2 + ' PTS</span>') : ('Unit size: ' + models); contLbl.setAttribute('data-models', String(models)); } },0);
          const sel = selEl || document.getElementById(selId || 'bsize-select'); if(sel){ sel.value = String(v); sel.selectedIndex = Number(v); Array.from(sel.options).forEach(o=>{ o.selected = (o.value === String(v)); }); }
          unit.models = models;
          const baseWeps = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base);
          baseWeps.forEach(bw=>{
            const rows = Array.from(document.querySelectorAll('.modal-upgrade-row[data-replaces="'+bw.name+'"]'));
            const inputs = rows.map(r=>{ const iid=r.getAttribute('data-upgrade'); return document.getElementById('upcnt-'+iid); }).filter(Boolean);
            inputs.forEach(inp2=>{ if(inp2) inp2.max = String(models); });
            let sum = inputs.reduce((s,x)=>s+Number(x.value||0),0);
            if(sum>models){
              let over = sum - models;
              for(const x of inputs){ if(over<=0) break; const cur = Number(x.value||0); const dec = Math.min(cur, over); x.value = String(cur - dec); const vb = document.getElementById('upval-'+x.id.replace('upcnt-','')); if(vb) vb.textContent = x.value; over -= dec; }
            }
          });
        }
        updateModalTotals();
        try{ updateBroodSummary(); }catch(e){}
      }
      window.onBroodSizeSelect = onBroodSizeSelect;

      function applyModalUnitSize(){ if(!window.editContext) return; const {fIdx,section,sIdx,uIdx}=window.editContext; const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx]; const unit=slot&&slot.units&&slot.units[uIdx]; if(!unit) return; const input=document.getElementById('modal-models-input'); if(!input) return; let val=Number(input.value||0); const min=Number(input.getAttribute('min')||1); const max=Number(input.getAttribute('max')||val); const step=Number(input.getAttribute('step')||1); if(val<min) val=min; if(val>max) val=max; if(step>1){ const off=(val-min)%step; val=val-off; } unit.models=val; unit.baseModels=min; const inc=Math.max(0, Math.floor((val-min)/step)); const cost=(UNIT_BROOD_POINTS[unit.id]||0); const upId='u_bsize_apply_'+unit.id; unit.upgrades=(unit.upgrades||[]).filter(u=>u.id!==upId); if(inc>0){ unit.upgrades.push({ id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*step, maxModels: (UNIT_MAX_MODELS[unit.id]||max) }); } const sumEl=document.getElementById('modal-unit-summary'); if(sumEl){ sumEl.innerHTML='Unit size: '+unit.models+' <span class="cost">'+unitPoints(unit)+' PTS</span>'; } updateModalTotals(); try{ updateBroodSummary(); }catch(e){} }
      window.applyModalUnitSize = applyModalUnitSize;
      function updateBroodSizeUpgrade(unit){ const min=(UNIT_DEFAULT_MODELS[unit.id]||1); const max=(UNIT_MAX_MODELS[unit.id]||min); const step=(UNIT_BROOD_STEP[unit.id]||1); const inc=Math.max(0, Math.floor((Number(unit.models||min)-min)/step)); const cost=(UNIT_BROOD_POINTS[unit.id]||0); const upId='u_bsize_apply_'+unit.id; unit.upgrades=(unit.upgrades||[]).filter(u=>u.id!==upId); if(inc>0){ unit.upgrades.push({ id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*step, maxModels: max }); } }
      function headerModelBump(delta){ bumpHeaderUnit(delta, document.getElementById('modal-unit-summary')); }
      window.headerModelBump = headerModelBump;
      function bumpHeaderUnit(delta, el){ const cont = (el && (el.closest && el.closest('#modal-unit-summary'))) || document.getElementById('modal-unit-summary'); if(!cont) return; const unitId = cont.getAttribute('data-unit'); const min = Number(cont.getAttribute('data-min')||1); const max = Number(cont.getAttribute('data-max')||min); const step = Number(cont.getAttribute('data-step')||1); const ctx=window.editContext||{}; const {fIdx,section,sIdx,uIdx}=ctx; const slot=(section==='special')? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]); let unit = window._modalUnitRef || (slot&&slot.units&&slot.units[uIdx]); if(!unit || (unitId && unit.id!==unitId)) unit = slot && slot.units && slot.units[uIdx]; if(!unit) return; let cur = Number(unit.models || min); cur += delta * step; if(cur < min) cur = min; if(cur > max) cur = max; unit.models = cur; updateBroodSizeUpgrade(unit); const valBtn = document.getElementById('modal-unit-val'); if(valBtn) valBtn.textContent = String(cur); const costEl = document.getElementById('modal-unit-cost'); if(costEl) costEl.textContent = unitPoints(unit) + ' PTS'; scheduleUpdateTotals(); try{ updateBroodSummary(); }catch(e){} }
      window.bumpHeaderUnit = bumpHeaderUnit;
      function onSpecialUpgradeToggle(id, checked){
        const inp = document.getElementById('upcnt-'+id);
        if(inp){ inp.value = checked ? 1 : 0; }
        const rm = document.getElementById('uprm-'+id);
        if(rm) rm.style.display = checked ? '' : 'none';
        const cb = document.querySelector('.modal-special-checkbox[data-id="'+id+'"]');
        if(cb){ cb.checked = checked; cb.style.display = checked ? 'none' : ''; }
        enforceWeaponConstraints();
        updateSpecialRulesBlock();
        scheduleUpdateTotals();
      }
      function updateSpecialRulesBlock(){
        const cont = document.getElementById('modal-special-rules');
        if(!cont || !window.editContext) return;
        const {fIdx,section,sIdx,uIdx}=window.editContext;
        const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx];
        const unit=slot&&slot.units&&slot.units[uIdx];
        if(!unit) return;
        const lib=currentLoadout(unit.id);
        const base=(lib.specialRules||[]);
        const dyn=[];
        const activeIds = Array.from(document.querySelectorAll('.modal-special-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id'))
          .concat(Array.from(document.querySelectorAll('.modal-upgrade-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id')));
        activeIds.forEach(id=>{ const eff=UPGRADE_EFFECTS[id]; if(eff && (eff.rules||[]).length){ dyn.push(...eff.rules); } });
        const items=base.concat(dyn);
        cont.innerHTML = items.length ? items.map(r=>renderRuleText(r)).join('') : `<div class="muted small">No special rules listed</div>`;
      }



      function saveEditFromModal(){

        if(!editContext) return;

        const {fIdx,section,sIdx,uIdx} = editContext;

        const slot = (section === 'special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx];

        const unit = slot && slot.units && slot.units[uIdx];

        if(!unit) return;
        window._modalUnitRef = unit;
        window._modalUnitRef = unit;

        const weBoxes = Array.from(document.querySelectorAll('.modal-weapon-checkbox'));

        const chosenWeps = weBoxes.filter(b=>b.checked && b.closest('tr') && b.closest('tr').style.display !== 'none').map(b=>{

          const id = b.getAttribute('data-id'); const name = b.getAttribute('data-name'); const src = b.getAttribute('data-src'); const pts = Number(b.getAttribute('data-points')||0);

          return { id, name, src, points: pts };

        });

        const upBoxes = Array.from(document.querySelectorAll('.modal-upgrade-checkbox'));

        let chosenUps = upBoxes.filter(b=>b.checked).map(b=>{

          return { id: b.getAttribute('data-id'), name: b.getAttribute('data-name'), points: Number(b.getAttribute('data-points')||0), desc: b.getAttribute('data-desc')||'', type: b.getAttribute('data-type')||'', replaces: b.getAttribute('data-replaces')||'', grants: b.getAttribute('data-grants')||'', limit: b.getAttribute('data-limit')||'', detachmentSize: Number(b.getAttribute('data-detach')||0) };

        });

        const psyBoxes = Array.from(document.querySelectorAll('.modal-psychic-checkbox'));

        const chosenPsy = psyBoxes.filter(b=>b.checked).map(b=>{

          return { id: b.getAttribute('data-id'), name: b.getAttribute('data-name'), points: Number(b.getAttribute('data-points')||0), desc: b.getAttribute('data-desc')||'' };

        });

        // Read upgrade counts directly from rows and merge into selected upgrades
        const upCounts = Array.from(document.querySelectorAll('.modal-upgrade-count'));
        const countedUps = upCounts.map(inp=>{
          const id = inp.id.replace('upcnt-','');
          const row = document.querySelector(`.modal-upgrade-row[data-upgrade="${id}"]`);
          const scb = document.querySelector(`.modal-special-checkbox[data-id="${id}"]`);
          const cnt = Number(inp.value||0);
          const base = Number(inp.getAttribute('data-points')||0);
          const name = row ? (row.querySelector('strong')?.textContent || '') : (scb ? (scb.getAttribute('data-name') || '') : (inp.getAttribute('data-name') || ''));
          const type = row ? (row.getAttribute('data-type') || '') : (scb ? (scb.getAttribute('data-type') || '') : (inp.getAttribute('data-type') || ''));
          const replaces = row ? (row.getAttribute('data-replaces') || '') : (inp.getAttribute('data-replaces') || '');
          const grants = row ? (row.getAttribute('data-grants') || '') : (inp.getAttribute('data-grants') || '');
          const detach = row ? Number(row.getAttribute('data-detach')||0) : Number(inp.getAttribute('data-detach')||0);
          const obj = { id, name, points: base * cnt, desc: '', type, replaces, grants, limit:'', detachmentSize: detach, count: cnt };
          if(type==='BROOD_SIZE'){ const step = Number(inp.getAttribute('data-step') || (UNIT_BROOD_STEP && UNIT_BROOD_STEP[unit.id]) || 1); obj.modelsDeltaTotal = step * cnt; obj.maxModels = (UNIT_MAX_MODELS && UNIT_MAX_MODELS[unit.id]) || 0; }
          return obj;
        }).filter(u=>u.count>0);
        // merge countedUps into chosenUps (override points/count/models delta)
        countedUps.forEach(cu=>{
          const idx = chosenUps.findIndex(u=>u.id===cu.id);
          if(idx>-1){
            chosenUps[idx] = { ...chosenUps[idx], points: cu.points, count: cu.count, modelsDeltaTotal: cu.modelsDeltaTotal, maxModels: cu.maxModels };
          } else {
            chosenUps.push(cu);
          }
        });

        const mInput = document.getElementById('modal-models-input');
        if(mInput){ let val = Number(mInput.value||0); const min = Number(mInput.getAttribute('min')||1); const max = Number(mInput.getAttribute('max')||val); const step = Number(mInput.getAttribute('step')||1); if(val<min) val=min; if(val>max) val=max; if(step>1){ const offset = (val - min) % step; val = val - offset; } unit.models = val; unit.baseModels = unit.baseModels || min; } else {
          const baseM = (UNIT_DEFAULT_MODELS[unit.id]||unit.baseModels||1);
          const stepM = (UNIT_BROOD_STEP[unit.id]||1);
          const maxM = (UNIT_MAX_MODELS[unit.id]||baseM);
          let curM = Number(unit.models||baseM);
          if(curM<baseM) curM=baseM; if(curM>maxM) curM=maxM;
          unit.models = curM;
          const inc = Math.max(0, Math.floor((curM - baseM)/stepM));
          const cost = (UNIT_BROOD_POINTS[unit.id]||0);
          const upId = 'u_bsize_apply_'+unit.id;
          const entry = { id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*stepM, maxModels: maxM };
          const idx = chosenUps.findIndex(u=>u.id===upId);
          if(idx>-1){ chosenUps[idx] = entry; } else if(inc>0){ chosenUps.push(entry); }
        }

        let weapons;
        const isBrood = (unit.models||1) > 1;
        if(isBrood){
          const baseWeps = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base);
          const grouped = {};
          chosenUps.filter(u=> (u.type==='WEAPON_SWAP' || u.type==='WEAPON_SWAP_LIMITED') && u.replaces).forEach(u=>{ const k=u.replaces; grouped[k]=grouped[k]||[]; grouped[k].push(u); });
          weapons = [];
          baseWeps.forEach(bw=>{ const ups = grouped[bw.name]||[]; let remaining = unit.models||1; ups.forEach(u=>{ const c = Math.max(0, Math.min(remaining, Number(u.count||0))); u.count = c; remaining -= c; if(u.grants && c>0){ const label = c>1 ? `${u.grants} (x${c})` : u.grants; weapons.push({ id:'auto_'+u.id, name: label, src:u.grants, points: 0 }); } }); const baseCount = Math.max(0, remaining); if(baseCount>0){ const baseLabel = baseCount>1 ? `${bw.name} (x${baseCount})` : bw.name; weapons.push({ id: bw.id, name: baseLabel, src: bw.src, points: 0 }); } });
        } else {
          weapons = chosenWeps.slice();
          chosenUps.forEach(u=>{ if(u.type==='WEAPON_SWAP' || u.type==='WEAPON_SWAP_LIMITED'){ if(u.replaces){ weapons = weapons.filter(w=>w.name !== u.replaces); } if(u.grants){ const label = u.count && u.count>1 ? `${u.grants} (x${u.count})` : u.grants; const exists = weapons.some(w=>w.name === label); if(!exists){ weapons.push({ id:'auto_'+u.id, name: label, src:u.grants, points: 0 }); } } } });
        }
        weapons = filterWepsByConstraints(unit.id, weapons, chosenUps);

        unit.weapons = weapons;
        unit.upgrades = chosenUps;
        unit.psychic = chosenPsy;

        const hasSwarm = chosenUps.some(u=>u.id === 'u_swarm');

        if(hasSwarm){

          unit._appliedEffects = unit._appliedEffects || {};

          unit._appliedEffects.swarmLord = { CAF: '+14', Wounds: 3, note: 'Swarm Lord applied: CAF +14; Wounds = 3; Venom/Barbed removed.' };

          unit.weapons = (unit.weapons||[]).filter(w => !['Venom Cannon','Barbed Strangler'].includes(w.name));

          unit.notes = unit.notes || [];

          if(!unit.notes.find(n=>n.startsWith('Swarm Lord:'))) unit.notes.push('Swarm Lord applied: CAF +14; Wounds = 3; Venom/Barbed removed.');

        } else {

          if(unit._appliedEffects && unit._appliedEffects.swarmLord) delete unit._appliedEffects.swarmLord;

          unit.notes = (unit.notes||[]).filter(n=>!n.startsWith('Swarm Lord:'));

        }

        closeModal();

        renderContent();
        saveState();

      }



      function renderModal(){

        const root = document.getElementById('modal-root'); window._lastFocused = document.activeElement; root.innerHTML = ''; if(!editContext) return;

        const {fIdx,section,sIdx,uIdx} = editContext;

        const slot = (section === 'special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx];

        const unit = slot && slot.units && slot.units[uIdx];

        if(!unit) return;

        if(unit.id === 'tyranid-warrior'){ }

        const needBrood = false;

        const lib = currentLoadout(unit.id);

        const instanceWeaponIds = (unit.weapons||[]).map(w=>w.id);

        const instanceUpgradeIds = (unit.upgrades||[]).map(u=>u.id);

        const initialHasSwarm = instanceUpgradeIds.includes('u_swarm') || (unit._appliedEffects && unit._appliedEffects.swarmLord);



        const weaponsHtml = (lib.weapons||[]).map(w=>{

          const stat = WEAPON_LIBRARY[w.src] || {};

          const checked = instanceWeaponIds.includes(w.id) || (w.base && instanceWeaponIds.length===0);

          const pts = stat.points || 0;

          const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td><td class="cost">${pts} pts</td>`;

          const display = initialHasSwarm && (w.name === 'Venom Cannon' || w.name === 'Barbed Strangler') ? 'style="display:none"' : '';

          return `<tr class="modal-weapon-row" data-weapon="${w.name}" ${display}><td style="width:auto"><label style="display:flex;gap:8px;align-items:center"><input type="checkbox" class="modal-weapon-checkbox" data-id="${w.id}" data-name="${w.name}" data-src="${w.src}" data-points="${pts}" ${checked ? 'checked' : ''}/> ${w.name}${w.base && (unit.models||1)>1 ? ' <span id="base-rem-'+w.id+'" class="muted small"></span>' : ''}</label></td>${statCols}</tr>`;

        }).join('');



        const upgradesHtml = (lib.upgrades||[]).map(u=>{

          const checked = instanceUpgradeIds.includes(u.id) || (unit._appliedEffects && unit._appliedEffects.swarmLord && u.id === 'u_swarm');
          const limitModels = (unit.models || u.detachmentSize || 0);
          const isLimited = (u.type === 'WEAPON_SWAP_LIMITED');
          const meetsLimit = !isLimited || (Math.floor(limitModels / 3) >= 1);
          const disabledAttr = meetsLimit ? '' : 'disabled';
          const hint = isLimited ? `<div class="muted small" style="margin-top:4px">Limit: 1 per 3 models${meetsLimit?'':' — requires at least 3 models'}</div>` : '';
          const bsizeHint = u.type==='BROOD_SIZE' ? `<div class="muted small" style="margin-top:4px">Models: ${(unit.models||unit.baseModels||3)} → ${(unit.models||unit.baseModels||3)+(u.modelsDelta||0)}${u.maxModels? ' (max '+u.maxModels+')':''}</div>` : '';

          const baseM = unit.baseModels || ((UNIT_DEFAULT_MODELS && UNIT_DEFAULT_MODELS[unit.id]) || 1);
          const stepM = u.type==='BROOD_SIZE' ? (u.modelsDelta || ((UNIT_BROOD_STEP && UNIT_BROOD_STEP[unit.id]) || 1)) : 1;
          const maxM = u.type==='BROOD_SIZE' ? (u.maxModels || ((UNIT_MAX_MODELS && UNIT_MAX_MODELS[unit.id]) || baseM)) : baseM;
          const count = u.type==='BROOD_SIZE' ? Math.max(0, Math.floor(((unit.models||baseM) - baseM) / stepM)) : 0;
          const maxCount = u.type==='BROOD_SIZE' ? Math.max(0, Math.floor((maxM - baseM) / stepM)) : 0;
          const control = u.type==='BROOD_SIZE' ? `<div style="margin-top:6px;display:flex;gap:6px;align-items:center"><button class="btn btn-xs btn-green" onclick="window.bumpUpgradeCount('${u.id}',1)">+ ${stepM} models (+${u.points||0} pts)</button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${u.points||0}" data-upid="${u.id}" data-step="${stepM}" style="width:0;opacity:0;pointer-events:none"/><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()">✖</button></div>` : '';

          return `<div class="modal-upgrade-row" data-upgrade="${u.id}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-detach="${u.detachmentSize||0}" style="margin-bottom:8px"><label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-upgrade-checkbox" data-id="${u.id}" data-name="${u.name}" data-points="${u.points}" data-desc="${u.desc||''}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-limit="${u.limit||''}" data-detach="${u.detachmentSize||''}" ${checked ? 'checked' : ''} ${disabledAttr} onchange="onModalUpgradeToggle()"/><div><strong>${u.name}</strong> <span class="muted">(+${u.points} pts)</span><div class="muted" style="margin-top:6px">${u.desc||''}</div>${hint}${bsizeHint}${control}</div></label></div>`;

        }).join('');
        const tableUps = (lib.upgrades||[]).filter(u => (u.type||'').startsWith('WEAPON') && u.grants && WEAPON_LIBRARY[u.grants]);
        const tableUpIds = new Set(tableUps.map(u=>u.id));
        const tableUpGrants = new Set(tableUps.map(u=> String(u.grants||'').toLowerCase()));
        let upgradesRowsHtml = tableUps.map(u=>{
          const current = (unit.upgrades||[]).find(x=>x.id===u.id);
          const count = current && current.count ? Number(current.count) : 0;
          const per = (u.type==='WEAPON_SWAP_LIMITED' && (u.detachmentSize||3)) || null;
          let maxCount = u.type==='MODEL_UPGRADE' ? 1 : (per ? Math.floor((unit.models||per)/per) : (u.type==='WEAPON_SWAP'? (unit.models||1) : (u.type==='BROOD_SIZE'? Math.max(0, Math.floor(((UNIT_MAX_MODELS[unit.id]||0)-(UNIT_DEFAULT_MODELS[unit.id]||0)) / (UNIT_BROOD_STEP[unit.id]||1))) : 0)));
          const isBroodlord = /broodlord/i.test(u.name||'');
          if(isBroodlord){ const others = countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord'); maxCount = count>0 ? 1 : Math.max(0, 1 - others); }
          const stat = u.grants ? (WEAPON_LIBRARY[u.grants] || {}) : {};
          const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${stat.traits||''}</td>`;
          const control = u.type==='BROOD_SIZE'
            ? `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs btn-green" onclick="window.bumpUpgradeCount('${u.id}',1)">+ ${(UNIT_BROOD_STEP[unit.id]||1)} models (+${UNIT_BROOD_POINTS[unit.id]??(u.points||0)} pts)</button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${UNIT_BROOD_POINTS[unit.id]??(u.points||0)}" style="width:0;opacity:0;pointer-events:none"/><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()">✖</button></div>`
            : `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${u.id}',-1)">−</button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${u.points||0}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${u.id}',1)" ${count>=maxCount ? 'disabled' : ''}>+</button><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()">✖</button></div>`;
          const displayName = (u.grants||'') || (u.name||'').replace(/^Replace\s+.*\s+with\s+/,'');
          const displayModelName = (u.type==='MODEL_UPGRADE') ? (String(u.name||'').replace(/^Replace\s+.*\s+with\s+/,'').replace(/\(Model Upgrade\)/i,'').trim() || 'Upgrade') : displayName;
          const nameCell = `<td><div style="font-weight:600">${displayModelName}</div><div class="small muted">${u.limit||''}</div>${control}</td>`;
          const basePts = u.type==='BROOD_SIZE' ? (UNIT_BROOD_POINTS[unit.id]??(u.points||0)) : (u.points||0);
          return `<tr class="modal-upgrade-row" data-upgrade="${u.id}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-detach="${u.detachmentSize||0}" data-name="${u.name}">${nameCell}${statCols}<td class="cost">${(count>0? (count*basePts) : basePts)} pts</td></tr>`;
        }).join('');
        if(!upgradesRowsHtml){
          const defM = (UNIT_DEFAULT_MODELS[unit.id]||1), maxM=(UNIT_MAX_MODELS[unit.id]||defM), stepM=(UNIT_BROOD_STEP[unit.id]||0);

          if(unit.id==='termagant'){
            const entries = [
              {id:'u_fb_strangle', name:'Replace Fleshborer with Stranglewebs', pts:3, grants:'Stranglewebs'},
              {id:'u_fb_dev', name:'Replace Fleshborer with Devourer', pts:1, grants:'Devourer'}
            ];
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            entries.forEach(e=>{
              const stat = WEAPON_LIBRARY[e.grants] || {};
              const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${stat.traits||''}</td>`;
              const maxCnt = (unit.models||defM2);
              const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',-1)">−</button><button id="upval-${e.id}" class="btn btn-xs" style="width:28px;justify-content:center">0</button><input id="upcnt-${e.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="0" data-points="${e.pts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',1)">+</button><button id="uprm-${e.id}" class="btn btn-xs btn-red" style="display:none" onclick="document.getElementById('upcnt-${e.id}').value=0; document.getElementById('upval-${e.id}').textContent='0'; updateModalTotals()">✖</button></div>`;
              const nameCell = `<td><div style="font-weight:600">${e.grants}</div>${control}</td>`;
              upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${e.id}" data-type="WEAPON_SWAP" data-replaces="Fleshborer" data-grants="${e.grants}" data-detach="0">${nameCell}${statCols}<td class="cost">${e.pts} pts</td></tr>`;
              tableUpGrants.add(String(e.grants||'').toLowerCase());
            });
          } else if(unit.id==='biovore'){
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            const baseModels = unit.models || defM2;
            const pyroBase = (lib.upgrades||[]).find(x=>/pyrovor/i.test(String(x.name||'')));
            const pyroId = pyroBase ? pyroBase.id : 'u_biovore_pyro';
            const pyroPts = pyroBase ? (pyroBase.points||0) : 0;
            const pyroDet = pyroBase ? (pyroBase.detachmentSize||0) : 0;
            const stat = WEAPON_LIBRARY['Pyroacid Launcher'] || {};
            const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${stat.traits||''}</td>`;
            const maxCnt = baseModels;
            let curCount = 0;
            const existing = (unit.upgrades||[]).find(x=>x.id===pyroId);
            if(existing){
              const stored = Number(existing.count||0);
              curCount = stored>0 ? Math.min(maxCnt, stored) : maxCnt;
            }
            const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${pyroId}',-1)">−</button><button id="upval-${pyroId}" class="btn btn-xs" style="width:28px;justify-content:center">${curCount}</button><input id="upcnt-${pyroId}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="${curCount}" data-points="${pyroPts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${pyroId}',1)">+</button><button id="uprm-${pyroId}" class="btn btn-xs btn-red" style="display:${curCount>0?'':'none'}" onclick="document.getElementById('upcnt-${pyroId}').value=0; document.getElementById('upval-${pyroId}').textContent='0'; updateModalTotals()">✖</button></div>`;
            const nameCell = `<td><div style="font-weight:600">Pyrovore (Pyroacid Launcher)</div><div class="small muted">Each Pyrovore has CAF +4 (Biovore CAF 0).</div>${control}</td>`;
            upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${pyroId}" data-type="WEAPON_SWAP" data-replaces="Spore Launcher" data-grants="Pyroacid Launcher" data-detach="${pyroDet}">${nameCell}${statCols}<td class="cost">${pyroPts} pts</td></tr>`;
            tableUpGrants.add('pyroacid launcher');
          }
        }



        const specialUps = (lib.upgrades||[]).filter(u => {
          const t = String(u.type||'');
          const nameLc = String(u.name||'').toLowerCase();
          const grantLc = String(u.grants||'').toLowerCase();
          if(unit.id==='biovore' && /pyrovor/i.test(nameLc)) return false;
          const isReplace = nameLc.includes('replace');
          const overlapsGrant = (grantLc && tableUpGrants.has(grantLc)) || Array.from(tableUpGrants).some(g=> nameLc.includes(g));
          const weaponLike = t.startsWith('WEAPON') || t==='MODEL_UPGRADE';
          const isBroodSizeName = /increase\s+brood\s+size/i.test(nameLc);
          const isDuplicateBroodlord = /replace\s+one\s+genestealer\s+w\/\s+broodlord/i.test(nameLc);
          return !(
            t.startsWith('WEAPON') || u.type==='BROOD_SIZE' || isBroodSizeName || isDuplicateBroodlord || tableUpIds.has(u.id) || (weaponLike && isReplace && overlapsGrant)
          );
        });
        const specialUpgradesHtml = specialUps.map(u=>{
          const cur=(unit.upgrades||[]).find(x=>x.id===u.id);
          const count=cur&&cur.count?Number(cur.count):0;
          const pts=u.points||0;
          const isBroodlord=/broodlord/i.test(u.name||'');
          const others=isBroodlord? countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord'):0;
          const available=count>0?1:Math.max(0,1-others);
          const disabledAttr = (!count && available===0) ? 'disabled' : '';
          const eff = UPGRADE_EFFECTS[u.id]||{};
          const grants = (eff.rules||[]).length ? `<div class="muted small" style="margin-top:4px">Grants: ${(eff.rules||[]).join('; ')}</div>` : '';
          const statTxt = eff.stats && (eff.stats.CAF||eff.stats.Wounds||eff.stats.Movement) ? `<div class="muted small">Stats: ${[eff.stats.CAF?('CAF '+eff.stats.CAF):'', eff.stats.Wounds?('Wounds '+eff.stats.Wounds):'', eff.stats.Movement?('Move '+eff.stats.Movement):''].filter(Boolean).join('; ')}</div>` : '';
          let extra = '';
          const isPyrovore = unit.id==='biovore' && /pyrovor/i.test(u.name||'');
          if(isPyrovore){
            const baseWeap = WEAPON_LIBRARY['Spore Launcher']||{};
            const pyroWeap = WEAPON_LIBRARY['Pyroacid Launcher']||{};
            const row = (label, s)=>`<tr><td>${label}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`;
            extra = `<div class="muted small" style="margin-top:4px">Weapons change:</div><table class="table" style="margin-top:4px"><thead><tr><th>Profile</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${row('Biovore — Spore Launcher', baseWeap)}${row('Pyrovore — Pyroacid Launcher', pyroWeap)}</tbody></table><div class="muted small" style="margin-top:4px">CAF increases for Pyrovores compared to Biovores (see unit rules for details).</div>`;
          }
          return `<label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-special-checkbox" data-id="${u.id}" data-name="${u.name}" data-type="${u.type||'MODEL_UPGRADE'}" data-points="${pts}" ${count>0?'checked':''} ${disabledAttr} style="display:${count>0?'none':''}" onchange="onSpecialUpgradeToggle('${u.id}', this.checked)"/><div><strong>${u.name}</strong> <span class="muted">(+${pts} pts)</span>${grants}${statTxt}${extra}<button id="uprm-${u.id}" class="btn btn-xs btn-red" style="margin-left:8px;display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; onSpecialUpgradeToggle('${u.id}', false)">✖</button></div></label><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="1" step="1" value="${count}" data-points="${pts}" style="width:0;opacity:0;pointer-events:none"/>`;
        }).join('');

        const psychicHtml = (lib.psychicPowers||[]).map(p=>{

          const checked = (unit.psychic||[]).some(x=>x.id === p.id);

          return `<label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-psychic-checkbox" data-id="${p.id}" data-name="${p.name}" data-points="${p.points||0}" data-desc="${p.desc||''}" ${checked ? 'checked' : ''}/><div><strong>${p.name}</strong> <span class="muted">(+${p.points||0} pts)</span><div class="muted" style="margin-top:6px">${p.desc||''}</div></div></label>`;

        }).join('');



        const baseRules = (lib.specialRules||[]);
        const dyn = [];
        if(unit.id==='hive-tyrant' && (initialHasSwarm || (document.getElementById('upcnt-u_swarm') && Number(document.getElementById('upcnt-u_swarm').value||0)>0))) dyn.push('Swarm Lord: CAF +14; Wounds = 3');
        if(unit.id==='genestealer' && ((document.getElementById('upcnt-u_broodlord') && Number(document.getElementById('upcnt-u_broodlord').value||0)>0) || instanceUpgradeIds.includes('u_broodlord'))){ dyn.push('Synapse (6\")'); dyn.push('The Horror (Broodlord only)'); }
        const specialRulesHtml = (baseRules.concat(dyn)).length ? baseRules.concat(dyn).map(r=>renderRuleText(r)).join('') : `<div class="muted small">No special rules listed</div>`;

        const effectText = initialHasSwarm ? 'Swarm Lord effect: CAF becomes +14; Wounds = 3' : '';

        const baseCAF = lib.baseCAF || (UNIT_BASE[unit.id] && UNIT_BASE[unit.id].CAF) || '';

        const baseWounds = lib.baseWounds || (UNIT_BASE[unit.id] && UNIT_BASE[unit.id].wounds) || '';

        const loadModelsMap = UNIT_DEFAULT_MODELS || {};
        const maxModelsMap = UNIT_MAX_MODELS || {};
        const stepMap = UNIT_BROOD_STEP || {};
        let defModels = loadModelsMap[unit.id] || 1;
        let maxModels = maxModelsMap[unit.id] || defModels;
        let stepModels = stepMap[unit.id] || 1;
        const load = UNIT_LOADOUTS[unit.id] || {};
        const broodUp = (load.upgrades||[]).find(u=>u.type==='BROOD_SIZE');
        if(broodUp){
          if(broodUp.modelsDelta) stepModels = broodUp.modelsDelta;
          if(broodUp.maxModels) maxModels = broodUp.maxModels;
        }
        const adjustable = maxModels>defModels;
        const sizerMin = defModels;
        const sizerMax = maxModels;
        const sizerStep = stepModels;
        const modelCtrl = '';
        const baseM = (UNIT_DEFAULT_MODELS[unit.id]||defModels);
        const curM = unit.models||defModels;
        const headerSummary = adjustable
          ? `<div id="modal-unit-summary" data-unit="${unit.id}" data-min="${sizerMin}" data-max="${sizerMax}" data-step="${sizerStep}" class="slot-meta-row small" style="margin:6px 0 10px;display:flex;flex-direction:column;gap:6px"><div style="display:flex;align-items:center;gap:8px"><span>Unit size:</span><div style="display:flex;gap:6px;align-items:center"><button id="modal-unit-dec" class="btn btn-xs" data-action="unit-dec">−</button><button id="modal-unit-val" class="btn btn-xs" style="width:40px;justify-content:center">${curM}</button><button id="modal-unit-inc" class="btn btn-xs" data-action="unit-inc">+</button></div><span id="modal-unit-cost" class="cost">${unitPoints(unit)} PTS</span><span class="small muted">Max: ${sizerMax}</span></div><div id="modal-inc-label" class="small muted">Increase by: +${sizerStep}</div></div>`
          : `<div id="modal-unit-summary" data-unit="${unit.id}" data-min="${sizerMin}" data-max="${sizerMax}" data-step="${sizerStep}" class="slot-meta-row small" style="margin:6px 0 10px;display:flex;flex-direction:column;gap:6px"><div style="display:flex;align-items:center;gap:8px"><span>Unit size:</span><span class="pill">${curM}</span><span id="modal-unit-cost" class="cost">${unitPoints(unit)} PTS</span><span class="small muted">Max: ${sizerMax}</span></div></div>`;



        root.innerHTML = `

          <div class="modal-backdrop" onclick="closeModal()">

            <div class="modal-drawer" onclick="event.stopPropagation()" style="position:fixed;right:0;top:0" role="dialog" aria-modal="true" aria-labelledby="modal-title">
              <button class="btn btn-sm btn-red" style="position:absolute;right:8px;top:8px" onclick="closeModal()">✖</button>
              <h3 id="modal-title" style="margin:0 0 8px 0">${unit.name} — Edit</h3>
              ${headerSummary}
              <div class="drawer-stack">
                <div>

                  ${(weaponsHtml || upgradesRowsHtml) ? `
                    <div style="margin-bottom:10px">
                      <table class="table"><thead><tr><th>Weapon / Upgrade</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th><th>Cost</th></tr></thead><tbody>${weaponsHtml+upgradesRowsHtml}</tbody></table>
                    </div>
                  ` : ''}>

                  ${modelCtrl}

                  ${specialUps.length ? `
                    <div style="margin-bottom:10px">
                      <label class="small">Unit Upgrades</label>
                      <div style="margin-top:6px">${specialUpgradesHtml}</div>
                    </div>
                  ` : ''}

                  ${unit.id === 'hive-tyrant' ? `

                    <div style="margin-bottom:10px">

                      <label class="small">Psychic Powers</label>

                      <div style="margin-top:6px">${psychicHtml || '<div class="muted">None</div>'}</div>

                    </div>

                  ` : ''}





                </div>



                <div>

                  <div id="modal-effect-pill" class="effect-pill" style="display:${effectText? '': 'none'}">${effectText}</div>



                  <div id="modal-caf-block" style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px;display:${initialHasSwarm ? '' : 'none'}">

                    <div class="small muted">CAF (effective)</div>

                    <div id="modal-caf-value" data-base="${baseCAF}" style="font-weight:700">${initialHasSwarm? '+14' : baseCAF}</div>

                  </div>



                  <div id="modal-wounds-block" style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px;display:${initialHasSwarm ? '' : 'none'}">

                    <div class="small muted">Wounds (effective)</div>

                    <div id="modal-wounds-value" data-base="${baseWounds}" style="font-weight:700">${initialHasSwarm? '3' : baseWounds}</div>

                  </div>



                  <div style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px">

                    <div class="small muted">Special rules</div>

                    <div id="modal-special-rules" style="margin-top:6px">${specialRulesHtml}</div>

                  </div>



                  <div style="margin-top:10px" class="small muted">Upgrades Cost:

                    <div id="modal-total-points" style="margin-top:8px;font-weight:700">0 pts</div>

                  </div>



                  ${unit.notes && unit.notes.length ? `<div class="notes" style="margin-top:10px">${unit.notes.join('; ')}</div>` : ''}

                </div>

              </div>



              <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
                <button class="btn btn-sm btn-red" onclick="closeModal()">Cancel</button>
                <button id="modal-save-btn" class="btn btn-sm btn-blue">Save</button>
              </div>
            </div>
          </div>
        `;
        window.bumpUpgradeCount = bumpUpgradeCount;
        try{ const drawer=document.querySelector('.modal-drawer'); if(drawer){ trapFocus(drawer); setTimeout(()=>{ const first=drawer.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); if(first && first.focus) first.focus(); },0); } }catch(e){}
        (function bindHeaderControls(){ try{ const dec=document.getElementById('modal-unit-dec'); const inc=document.getElementById('modal-unit-inc'); if(dec) dec.addEventListener('click', ()=>window.headerModelBump(-1)); if(inc) inc.addEventListener('click', ()=>window.headerModelBump(1)); }catch(e){} })();

        setTimeout(()=>{ try{ onModalUpgradeToggle(); }catch(e){} try{ updateModalTotals(); }catch(e){} try{ enforceWeaponConstraints(); }catch(e){} try{ updateSpecialRulesBlock(); }catch(e){} }, 0);

        const saveBtn = document.getElementById('modal-save-btn'); if(saveBtn) saveBtn.addEventListener('click', saveEditFromModal, { once:true });



        Array.from(document.querySelectorAll('.modal-weapon-checkbox')).forEach(cb => cb.addEventListener('change', ()=>{ updateModalTotals(); enforceWeaponConstraints(); }));

        Array.from(document.querySelectorAll('.modal-upgrade-count')).forEach(inp => inp.addEventListener('change', updateModalTotals));

        Array.from(document.querySelectorAll('.modal-psychic-checkbox')).forEach(cb => cb.addEventListener('change', updateModalTotals));

        const modalModelsInput = document.getElementById('modal-models-input'); if(modalModelsInput) modalModelsInput.addEventListener('change', ()=>{ onModalUpgradeToggle(); updateModalTotals(); });

      }



      // ---------- Renderers ----------

      function renderContent(){

        const content = document.getElementById('content'); if(!content) return;

        if(activeTab === 'home'){ content.innerHTML = renderHome(); return; }

        if(activeTab === 'lists'){ content.innerHTML = renderLists(); return; }

        if(activeTab === 'army-builder'){ content.innerHTML = renderArmyBuilder(); return; }

        

        if(activeTab === 'reference'){ content.innerHTML = renderReference(); try{ postRenderAdjustments(); }catch(e){} return; }

        if(activeTab === 'roster'){ content.innerHTML = renderRoster(); return; }

      }



      function renderHome(){
        const updatesContent = `
          <div class="muted small" style="margin-bottom:8px">
            <strong>New:</strong> Google Account login is now supported! Log in to enable cloud saves and sync your lists across devices.
          </div>
          <div class="muted small">
            <strong>Update:</strong> Tyranid Warrior Brood size fixed (max 12 per slot).
          </div>
        `;
        
        const welcomeText = `
          <div style="margin-bottom:16px; text-align:center">
            <h2 style="margin:0 0 8px 0; font-size:18px">Welcome to Xenos Army Builder</h2>
            <div class="muted small" style="max-width:400px; margin:0 auto">
              Build and manage your army lists for Xenos Armies. Create detachments, customize units with upgrades, and export your lists for play.
              Log in to save your lists to the cloud and access them from any device.
            </div>
          </div>
        `;

        return `<div style="padding:12px">
          <div class="hero">
            ${welcomeText}
            <button class="btn btn-green hero-cta" onclick="createNewList()">Create List</button>
            <div class="card p-4" style="margin-top:12px"><h3 class="section-title">Updates</h3>${updatesContent}</div>
          </div>
        </div>`;
      }


      function renderReference(){ if(referenceView==='main') return renderReferenceHome(); if(referenceView==='units') return renderReferenceUnits(); if(referenceView==='unit-detail') return renderReferenceUnitDetail(); if(referenceView==='weapons') return renderReferenceWeapons(); if(referenceView==='weapon-detail') return renderReferenceWeaponDetail(); if(referenceView==='detachments') return renderReferenceDetachments(); if(referenceView==='formations') return renderReferenceFormations(); if(referenceView==='army-rules') return renderReferenceArmyRules(); return renderReferenceHome(); }

      function renderCrumbs(parts){ try{ return `<div class="crumbs small muted">` + parts.map((p,i)=>`<span ${p.on?`onclick=\"${p.on}\" style=\"cursor:pointer;text-decoration:underline\"`:''}>${p.label}</span>${i<parts.length-1?' › ':''}`).join('') + `</div>`; }catch(e){ return `<div class="crumbs small muted">Reference</div>`; } }

      function postRenderAdjustments(){ const crumbs=document.querySelector('.crumbs.small.muted'); if(crumbs){ const text=(crumbs.textContent||'').trim(); if(text.startsWith('Reference')){ const parts=text.split('›').map(s=>s.trim()); if(parts.length===1){ crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span>`; } if(parts.length===2){ const tail=parts[1]; crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span> › ${tail}`; } if(parts.length>=3){ const mid=parts[1]; const tail=parts.slice(2).join(' › '); const midAction=(mid==='Units')?"setReferenceView('units')":(mid==='Weapons'?"setReferenceView('weapons')":(mid==='Army Rules'?"setReferenceView('army-rules')":"")); const midSpan=midAction?`<span onclick=\"${midAction}\" style=\"cursor:pointer;text-decoration:underline\">${mid}</span>`:mid; crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span> › ${midSpan} › ${tail}`; } } } if(referenceView==='weapons'){ const table=document.querySelector('.card table.table'); if(table){ const ths=table.querySelectorAll('thead th'); if(ths.length){ ths[ths.length-1].style.display='none'; } const rows=table.querySelectorAll('tbody tr'); rows.forEach(tr=>{ const tds=tr.querySelectorAll('td'); if(tds.length){ tds[tds.length-1].style.display='none'; } }); } } }

      function renderReferenceHome(){
        const icons = {
          units:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm-7 8v-2a5 5 0 0 1 5-5h4a5 5 0 0 1 5 5v2H5Z"/></svg>`,
          weapons:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 21l6-6 3 3-6 6H3Zm9-9 3 3 6-6-3-3-6 6Z"/></svg>`,
          detachments:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 3h8v8H3V3Zm10 0h8v8h-8V3ZM3 13h8v8H3v-8Zm10 5h8v3h-8v-3Z"/></svg>`,
          formations:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2l4 7h-8l4-7Zm-9 20h18l-9-6-9 6Z"/></svg>`
        };
        const tiles=[
          {label:'Units',svg:icons.units,action:"openReferenceUnits()"},
          {label:'Weapons',svg:icons.weapons,action:"openReferenceWeapons()"},
          {label:'Army Rules',svg:icons.units,action:"openReferenceArmyRules()"},
          {label:'Detachments',svg:icons.detachments,action:"openReferenceDetachments()"},
          {label:'Formations',svg:icons.formations,action:"openReferenceFormations()"}
        ];
        const mapSrc = {
          Units: 'Images/rule_icons/units.svg',
          Weapons: 'Images/rule_icons/weapons.svg',
          Detachments: 'Images/rule_icons/detachments.svg',
          Formations: 'Images/rule_icons/formations.svg',
          'Army Rules': 'Images/rule_icons/army_rules.svg'
        };
        const items=tiles.map(t=>`<div class="rb-tile-card" onclick="${t.action}"><div class="rb-tile-header">${t.label}</div><div class="rb-tile-body"><img class="tile-icon-img" src="${mapSrc[t.label]}" alt="${t.label} icon" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"/><div class="tile-icon" style="display:none">${t.svg}</div></div></div>`).join('');
        return `<div style="padding:12px">${renderCrumbs([{label:'Reference'}])}<div class="tile-grid">${items}</div></div>`;
      }

      function renderReferenceUnits(){ const armies=Object.keys(ARMIES).filter(a=>a!=='Select Army'); const filt=String(referenceFilter||'').toLowerCase(); const search=`<div style=\"display:flex;gap:8px;margin-bottom:8px\"><input id=\"ref-unit-search\" class=\"mini-input\" placeholder=\"Search units\" value=\"${referenceQuery}\" oninput=\"setReferenceFilter(this.value)\" onkeydown=\"if(event.key==='Enter'){commitReferenceFilter(this.value)}\"/><button class=\"btn btn-sm\" onclick=\"commitReferenceFilter(document.getElementById('ref-unit-search').value)\">Search</button><button class=\"btn btn-sm\" onclick=\"setReferenceFilter('')\">Clear</button></div>`; const order=['HQ','Synapse','Core','Support','Vanguard','Transport','BattleTank','HeavyArmor','AirSupport','Artillery','Knight','Biotitan','Flyer']; const cols=armies.map(a=>{ const key=armyKey(a); const list=(ARMY_UNIT_LIST[key]||[]); const list2=filt?list.filter(u=>u.name.toLowerCase().includes(filt)):list; const groups=order.map(role=>({ role, items: list2.filter(u=>u.slotType===role) })).filter(g=>g.items.length); const items=groups.length? groups.map(g=>`<div><div class=\"section-sub\">${g.role}</div>${g.items.map(u=>`<div style=\"padding:6px 8px;border-bottom:1px solid #243e46;cursor:pointer\" onclick=\"openReferenceUnit('${a}','${u.id}')\">${u.name}</div>`).join('')}</div>`).join('') : `<div class=\"small muted\" style=\"padding:8px\">No matches</div>`; return `<div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">${a}</div><div>${items}</div></div>`; }).join(''); return `<div style=\"padding:12px\">${renderCrumbs([{label:'Reference',on:'openReferenceHome()'},{label:'Units'}])}${search}<div style=\"display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px\">${cols}</div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"openReferenceHome()\">Back</button></div></div>`; }

      function buildWeaponUsageIndex(){ const usage={}; Object.keys(UNIT_LOADOUTS||{}).forEach(uid=>{ const load=UNIT_LOADOUTS[uid]||{}; (load.weapons||[]).filter(w=>w.base).forEach(w=>{ const name=w.name||w.src; usage[name]=usage[name]||{count:0,units:[]}; usage[name].count+=1; usage[name].units.push(uid); }); }); return usage; }

      function renderReferenceWeapons(){ const filt=String(referenceFilter||'').toLowerCase(); const usage=buildWeaponUsageIndex(); const list=Object.keys(WEAPON_LIBRARY||{}).sort((a,b)=>a.localeCompare(b)); const rows=list.filter(n=>{ if(!filt) return true; const s=WEAPON_LIBRARY[n]||{}; const cat=(s.traits||''); return n.toLowerCase().includes(filt)||String(cat).toLowerCase().includes(filt); }).map(n=>{ const s=WEAPON_LIBRARY[n]||{}; const u=usage[n]||{count:0,units:[]}; return `<tr onclick=\"openReferenceWeapon('${n.replace(/'/g,"\\'")}')\"><td>${n}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td><td class=\"small muted\">${u.count||0}</td></tr>`; }).join('') || `<tr><td colspan=\"7\" class=\"small muted\">No weapons</td></tr>`; const search=`<div style=\"display:flex;gap:8px;margin-bottom:8px\"><input id=\"ref-weapon-search\" class=\"mini-input\" placeholder=\"Search weapons\" value=\"${referenceQuery}\" oninput=\"setReferenceFilter(this.value)\" onkeydown=\"if(event.key==='Enter'){commitReferenceFilter(this.value)}\"/><button class=\"btn btn-sm\" onclick=\"commitReferenceFilter(document.getElementById('ref-weapon-search').value)\">Search</button><button class=\"btn btn-sm\" onclick=\"setReferenceFilter('')\">Clear</button></div>`; return `<div style=\"padding:12px\"><div class=\"crumbs small muted\">Reference › Weapons</div>${search}<div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">Weapons</div><table class=\"table\"><thead><tr><th>Name</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th><th>Used By</th></tr></thead><tbody>${rows}</tbody></table></div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"openReferenceHome()\">Back</button></div></div>`; }

      function renderReferenceWeaponDetail(){ const name=referenceWeapon; const s=WEAPON_LIBRARY[name]||{}; const usage=buildWeaponUsageIndex()[name]||{units:[]}; const unitNames=(usage.units||[]).map(id=>slugToName(id)).join(', '); return `<div style=\"padding:12px\"><div class=\"crumbs small muted\">Reference › Weapons › ${name}</div><div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">${name}</div><div style=\"padding:8px\"><table class=\"table\"><thead><tr><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody><tr><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr></tbody></table><div class=\"section-sub\">Used By</div><div>${unitNames||'<span class=\\"small muted\\">Unknown</span>'}</div></div></div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"setReferenceView('weapons')\">Back to Weapons</button><button class=\"btn\" style=\"margin-left:8px\" onclick=\"openReferenceHome()\">Reference Home</button></div></div>`; }

      function renderReferenceUnitDetail(){ const army=referenceDetail.army; const unitId=referenceDetail.unitId; const key=armyKey(army||selectedArmy); const list=(ARMY_UNIT_LIST[key]||[]); const base=list.find(u=>u.id===unitId)||{name:slugToName(unitId),slotType:'Core'}; const stats=UNIT_BASE[unitId]||{}; const load=UNIT_LOADOUTS[unitId]||{weapons:[],specialRules:[],upgrades:[]}; const weapons=(load.weapons||[]).filter(w=>w.base); const rows=weapons.length? weapons.map(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; return `<tr><td>${w.name}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`; }).join('') : `<tr><td colspan="6" class="small muted">No base weapons</td></tr>`; const rules=(load.specialRules||[]).join(', '); const ups=(load.upgrades||[]); const upsBlock=ups.length?`<div class=\"section-sub\">Upgrades</div><div><button class=\"btn btn-sm\" onclick=\"toggleReferenceUpgrades()\">${referenceShowUpgrades?'Hide':'Show'} Upgrades</button>${referenceShowUpgrades?ups.map(u=>`<div style=\"margin-top:4px\"><strong>${u.name}</strong> <span class=\"muted\">(+${u.points||0} pts)</span><div class=\"muted\">${u.desc||''}</div></div>`).join(''):''}</div>`:''; return `<div style="padding:12px"><div class="crumbs small muted">Reference › Units › ${base.name}</div><div class="card" style="padding:0"><div class="section-bar">${base.name}</div><div style="padding:8px"><div style="display:flex;justify-content:space-between"><div class="pill">${base.slotType}</div><div class="pill">${army||'-'}</div></div><table class="table" style="margin-top:8px"><thead><tr><th>Name</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th></tr></thead><tbody><tr><td>${base.name}</td><td>${stats.movement||'-'}</td><td>${stats.save||'-'}</td><td>${stats.CAF||'-'}</td><td>${stats.morale||'-'}</td><td>${stats.wounds||'-'}</td></tr></tbody></table><div class="section-sub">Weapons</div><table class="table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${rows}</tbody></table><div class="section-sub">Special Rules</div><div>${rules||'<span class=\"small muted\">None</span>'}</div>${upsBlock}</div></div><div style="margin-top:8px"><button class="btn" onclick="setReferenceView('units')">Back to Units</button><button class="btn" style="margin-left:8px" onclick="openReferenceHome()">Reference Home</button></div></div>`; }

      function renderLists(){
        const lists = (savedLists||[]);
        const allSelected = lists.length>0 && selectedListIds.length === lists.length;
        const rows = lists.length ? lists.map(l=>{
          const pointsUsed = (l.formations||[]).reduce((s,f)=>s+formationPoints(f),0);
          const pointsCap = l.pointsCap||2000;
          const checked = selectedListIds.includes(l.id) ? 'checked' : '';
          const saved = formatDateTime(l.updatedAt || l.createdAt);
          return `<tr>
            <td style="width:28px;text-align:center"><input type="checkbox" data-action="list-select" data-id="${l.id}" ${checked}/></td>
            <td><div style="font-weight:800">${l.name||'Untitled'}</div></td>
            <td>${l.faction||'-'}</td>
            <td>${saved}</td>
            <td>${pointsUsed}/${pointsCap} pts <span class="header-actions" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px"><button class="btn btn-blue btn-xs" data-action="list-open" data-id="${l.id}">Build</button><button class="btn btn-blue btn-xs" data-action="list-export" data-id="${l.id}">Export</button><button class="btn btn-red btn-xs" data-action="list-del" data-id="${l.id}">Delete</button></span></td>
          </tr>`;
        }).join('') : `<tr><td colspan="5" class="muted small">No saved lists</td></tr>`;
        const bulk = selectedListIds.length ? `<div class="small" style="display:flex;gap:8px;align-items:center;margin-bottom:8px"><span>Selected: ${selectedListIds.length}</span><button class="btn btn-red btn-sm" data-action="bulk-del">Delete Selected</button></div>` : '';
        const headerActions = selectedListIds.length ? `<span class="header-actions" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px">${selectedListIds.length===1?`<button class=\"btn btn-blue btn-xs\" data-action=\"bulk-open\">Build</button>`:''}<button class="btn btn-blue btn-xs" data-action="bulk-export">Export</button><button class="btn btn-red btn-xs" data-action="bulk-del">Delete</button></span>` : '';
        return `
          <div style="padding:12px">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
              <button class="btn btn-green" onclick="createNewList()">Create List</button>
            </div>
            ${bulk}
            <div class="table-responsive">
              <table class="table"><thead><tr><th style="width:28px;text-align:center"><input type="checkbox" data-action="select-all" ${allSelected?'checked':''}/></th><th>List Name</th><th>Army</th><th>Saved</th><th>Points ${headerActions}</th></tr></thead><tbody>${rows}</tbody></table>
            </div>
          </div>`;
      }

      function setListsSort(k){ listsSortBy = k; listsSortDir = (listsSortDir==='asc') ? 'desc' : 'asc'; renderContent(); }

      function createNewList(){ const now=Date.now(); const id=String(now); selectedArmy='Select Army'; selectedFormationName='Select a Formation'; armyFormations=[]; builderMeta={ name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 }; currentListId=id; setActiveTab('army-builder'); saveState(); }
      function viewList(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; const countForm=(l.formations||[]).length; const rows=(l.formations||[]).map(f=>{ const units=((f.compulsory||[]).reduce((s,slt)=>s+(slt.units||[]).length,0))+((f.optional||[]).reduce((s,slt)=>s+(slt.units||[]).length,0)) + (f.special && (f.special.units||[]).length || 0); return `<tr><td>${f.name}</td><td>${formationPoints(f)} pts</td><td>${units} units</td></tr>`; }).join('') || `<tr><td colspan="3" class="muted small">No formations</td></tr>`; const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${l.name} — Summary</h3><div class="small muted">Faction: ${l.faction||'-'} • Gamemode: ${l.gamemode||'Standard'}</div><div class="small" style="margin-top:6px">Points: <strong>${pointsUsed}/${pointsCap}</strong> • Formations: ${countForm}</div><div style="margin-top:8px"><div class="table-responsive"><table class="table"><thead><tr><th>Formation</th><th>Points</th><th>Units</th></tr></thead><tbody>${rows}</tbody></table></div></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button class="btn" onclick="closeModal()">Close</button><button class="btn btn-green" onclick="openInBuilder('${id}')">Open in Builder</button></div></div></div>`; }
      function duplicateList(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const now=Date.now(); const copy={...l, id:String(now), name:(l.name||'List')+' (copy)', createdAt: now, updatedAt: now}; savedLists.push(copy); persistSavedLists(); renderContent(); }
      function deleteList(id){ const idx=savedLists.findIndex(x=>x.id===id); if(idx>-1){ savedLists.splice(idx,1); persistSavedLists(); renderContent(); } }
      function copyBuilderLink(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const text=JSON.stringify(l); if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text); } alert('Builder link copied to clipboard'); }
      function openInBuilder(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; l.updatedAt = Date.now(); persistSavedLists(); currentListId = l.id; builderMeta = { name: l.name||'New List', gamemode: l.gamemode||'Standard', allegiance: l.allegiance||'Loyalist', pointsCap: l.pointsCap||2000 }; selectedArmy=l.faction||'Select Army'; selectedFormationName='Select a Formation'; armyFormations=JSON.parse(JSON.stringify(l.formations||[])); closeModal(); setActiveTab('army-builder'); saveState(); }
      async function exportListPDF(id){ const prev = (selectedListIds||[]).slice(); selectedListIds = [id]; try{ await exportSelectedListsPDF(); } finally { selectedListIds = prev; } }
      function listModels(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const units=(l.formations||[]).flatMap(f=>[...f.compulsory,...f.optional].flatMap(s=>s.units||[])); const total=units.reduce((s,u)=>s+(u.models||u.baseModels||1),0); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${l.name} — Models</h3><div class="small">Total models: ${total}</div></div></div>`; }
      function buildCompactTextForList(l){ const lines=[]; const pointsCap=l.pointsCap||2000; const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); lines.push(`${l.name||'Untitled'} — ${l.faction||'-'} — ${pointsUsed}/${pointsCap} pts`); (l.formations||[]).forEach(f=>{ lines.push(`- ${f.name}: ${formationPoints(f)} pts`); [f.compulsory,f.optional].forEach(arr=>arr.forEach(s=> (s.units||[]).forEach(u=>{ lines.push(`  • ${u.name} (${unitPoints(u)} pts)`);}))); if(f.special) (f.special.units||[]).forEach(u=>lines.push(`  • ${u.name} (${unitPoints(u)} pts)`)); }); return lines.join('\n'); }
      async function ensureJsPDF(){ if(window.jspdf && window.jspdf.jsPDF) return; const s=document.createElement('script'); s.src='https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'; document.head.appendChild(s); await new Promise(r=>{ s.onload=r; s.onerror=r; }); }
      async function exportSelectedListsPDF(){ const chosen=(savedLists||[]).filter(l=> selectedListIds.includes(l.id)); if(!chosen.length) return; try{ await ensureJsPDF(); const jsPDF = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : null; if(!jsPDF) throw new Error('jsPDF unavailable'); const doc=new jsPDF({ unit:'pt', format:'a4' }); const pageW=doc.internal.pageSize.getWidth(); const pageH=doc.internal.pageSize.getHeight(); const margin=36; const lineH=14; const colText=[31,41,55]; const colHeader=[63,58,54]; const colLight=[211,207,201]; const drawHeader=(title, meta)=>{ doc.setFillColor(colHeader[0],colHeader[1],colHeader[2]); doc.rect(0,0,pageW,42,'F'); doc.setTextColor(255,255,255); doc.setFont('times','bold'); doc.setFontSize(15); doc.text(String(title||'Army Lists').toUpperCase(), margin, 26); doc.setFillColor(colLight[0],colLight[1],colLight[2]); doc.rect(0,42,pageW,28,'F'); doc.setTextColor(colText[0],colText[1],colText[2]); doc.setFont('times','normal'); doc.setFontSize(12); if(meta){ doc.text(meta, margin, 60); } }; const drawSectionHead=(label)=>{ const y=doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : null; }; const ensureSpace=(needed)=>{ const y=state.y; if(y + needed > pageH - margin){ doc.addPage(); drawHeader('Army Lists',''); state.y = 42 + 28 + margin/2; } }; const state={ y: 42 + 28 + margin/2 }; const lists=chosen.slice(); lists.forEach((l,idx)=>{ if(idx===0){ const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; drawHeader(l.name||'Untitled', `Army: ${l.faction||'-'} • Points: ${pointsUsed}/${pointsCap}`); state.y = 42 + 28 + margin/2; } else { doc.addPage(); const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; drawHeader(l.name||'Untitled', `Army: ${l.faction||'-'} • Points: ${pointsUsed}/${pointsCap}`); state.y = 42 + 28 + margin/2; }
        const fms=(l.formations||[]); fms.forEach(f=>{ ensureSpace(28); doc.setFillColor(colLight[0],colLight[1],colLight[2]); doc.rect(margin, state.y, pageW - margin*2, 22, 'F'); doc.setTextColor(colText[0],colText[1],colText[2]); doc.setFont('times','bold'); doc.setFontSize(12); doc.text(`${f.name}: ${formationPoints(f)} pts`, margin+8, state.y+15); state.y += 26; doc.setFont('times','normal'); doc.setFontSize(11); const bullets=[]; [f.compulsory,f.optional].forEach(arr=> (arr||[]).forEach(s=> (s.units||[]).forEach(u=> bullets.push(`• ${u.name} (${unitPoints(u)} pts)`)))); if(f.special) (f.special.units||[]).forEach(u=> bullets.push(`• ${u.name} (${unitPoints(u)} pts)`)); const wrapped=doc.splitTextToSize(bullets.join('\n'), pageW - margin*2); wrapped.forEach(line=>{ ensureSpace(lineH+2); doc.text(line, margin, state.y); state.y += lineH; }); }); }); doc.save('Army_Lists.pdf'); }catch(e){ const chosenText=(savedLists||[]).filter(l=> selectedListIds.includes(l.id)).map(buildCompactTextForList).join('\n\n'); const html=`<!doctype html><html><head><meta charset=\"utf-8\"><title>Xenos Export</title><style>body{font-family:Georgia,Times,serif;margin:24px;color:#1f2937}h1{font-size:18px;margin:0 0 12px}pre{white-space:pre-wrap;font-size:13px;line-height:1.45;border:1px solid #c6c2bd;padding:12px;border-radius:6px;background:#f7f7f7}</style></head><body><h1>Army Lists</h1><pre>${chosenText.replace(/</g,'&lt;')}</pre></body></html>`; const w=window.open('', '_blank'); if(!w) return; w.document.open(); w.document.write(html); w.document.close(); setTimeout(()=>{ try{ w.print(); }catch(err){} }, 300); } }



      function renderArmyBuilder(){
        const armyOptions = Object.keys(ARMIES).map(a => `<option value="${a}" ${a === selectedArmy ? 'selected' : ''}>${a}</option>`).join('');
        const formationList = ARMIES[selectedArmy]?.formations || [];
        const formationOptions = ['Select a Formation', ...formationList].map(n => `<option value="${n}" ${n === selectedFormationName ? 'selected' : ''}>${n}</option>`).join('');
        const listTotal = armyFormations.reduce((s,f)=>s + formationPoints(f), 0);
        const listModels = (armyFormations||[]).reduce((s,f)=> s + totalModelsInFormation(f), 0);
        const formsHtml = armyFormations.length ? armyFormations.map((f,i)=>renderFormationCard(f,i)).join('') : `<div class="muted small p-4">No formations yet.</div>`;
        const allegianceOptions = ['Loyalist','Traitor'].map(a=>`<option value="${a}" ${a===builderMeta.allegiance?'selected':''}>${a}</option>`).join('');
        return `
          <div style="padding:12px">
            <div class="crumbs small muted">Lists › Builder</div>
            <div class="builder-bar">
              <div class="builder-controls-row"><label class="small muted">Faction</label><select class="select-compact" onchange="handleArmySelection(this.value)">${armyOptions}</select><label class="small muted">Name</label><input class="mini-input" value="${builderMeta.name}" onchange="setBuilderName(this.value)"/><label class="small muted">Game size</label><input type="number" class="mini-input" value="${builderMeta.pointsCap}" onchange="setBuilderPoints(this.value)"/> pts <button class="icon-btn icon-sm" title="Delete" data-action="delete-list">🗑</button></div>
              <div class="summary small">Formations: ${armyFormations.length} • Total: ${listTotal} pts • Total models: ${listModels}</div>
            </div>
            <div class="builder-controls"><select id="formation-select" class="select-compact" onchange="handleFormationSelection(this.value)">${formationOptions}</select><button class="btn btn-green btn-sm" onclick="addFormation()">+ Add Formation</button></div>
            ${formsHtml}
            <div class="builder-footer">List total: ${listTotal} pts • ${selectedArmy!=='Select Army'?selectedArmy+': '+listTotal+' pts':'Faction: -'} • Formations: ${armyFormations.length}</div>
          </div>`;
      }



      function formationHasMinViolations(f){

        if(!f || !f.compulsory) return false;

        return f.compulsory.some(slot => (slot.min || 0) > (slot.units ? slot.units.length : 0));

      }



      function renderFormationCard(f, idx){
        const total = formationPoints(f);
        const header = `
          <div class="formation-header">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div><strong class="roster-title">${f.name}</strong><div class="small muted">${f.army}</div></div>
              <div class="mini-icons"><button class="icon-btn icon-sm" title="Minimise" onclick="toggleCollapse(${idx})">▾</button><button class="icon-btn icon-sm" title="Clone" onclick="cloneFormation(${idx})">⎘</button><button class="icon-btn icon-sm" title="Delete" onclick="removeFormation(${idx})">🗑</button></div>
            </div>
          </div>`;
        if(f.collapsed) return header;
        const compHtml = f.compulsory.map((slot,sIdx)=>renderSlotBlock(f,idx,'compulsory',sIdx,slot)).join('');
        const optHtml = f.optional.map((slot,sIdx)=>renderSlotBlock(f,idx,'optional',sIdx,slot)).join('');
        const specialHtml = f.special ? renderSpecialBlock(f,idx,f.special) : `<div class="muted small">No special slots</div>`;
        const hasEmptyComp = (f.compulsory||[]).some(s => (s.min||0) > ((s.units||[]).length));
        const grid = `
          <div class="section-bar">~ COMPULSORY SLOTS ~</div>
          <div class="slot-row">${compHtml}</div>
          <div class="section-bar alt">~ OPTIONAL SLOTS ~</div>
          <div class="slot-row">${optHtml}</div>
          <div class="section-bar">~ SPECIAL ~</div>
          <div class="slot-row">${specialHtml}</div>`;
        return header + grid;
      }



      function renderSlotBlock(f,fIdx,section,sIdx,slot){

        const allowed = unitsFor(slot.type);
        const selectedId = (slot._selectedUnitId || (((slot.units||[])[0]||{}).id) || '');
        const options = `<option value="">Select unit</option>` + allowed.map(u=>`<option value="${u.id}" ${u.id===selectedId?'selected':''}>${u.name}</option>`).join('');

        const selectedUnit = (slot.units||[])[0] || null;
        const unitSize = selectedUnit ? (selectedUnit.models || selectedUnit.baseModels || '-') : 0;
        const slotPts = selectedUnit ? unitPoints(selectedUnit) : 0;
        const unitsHtml = selectedUnit ? `
          <div class="unit-item"><div class="u-actions"><button class="btn btn-xs btn-blue" onclick="window.openEditModal(${fIdx},'${section}',${sIdx},0)">Upgrades</button><button class="btn btn-xs btn-red" title="Remove" onclick="window.removeUnit(${fIdx},'${section}',${sIdx},0)">🗑</button></div></div>
        ` : `<div class="small muted" style="margin-top:6px">Select unit</div>`;
        const loadList = selectedUnit && (selectedUnit.weapons||[]).length ? `<div class="slot-details"><span class="label">Loadout</span> ${(selectedUnit.weapons||[]).map(w=>w.name).join(', ')}</div>` : '';
        const upItems = selectedUnit ? ([]).concat(
          (selectedUnit.upgrades||[]).map(u=>{ const cnt=Number(u.count||0); if(u.type==='BROOD_SIZE'){ const step=(UNIT_BROOD_STEP&&UNIT_BROOD_STEP[selectedUnit.id])||1; const delta=cnt? step*cnt : (u.modelsDelta||0); return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}${delta? ' (+'+delta+' models)':''}`; } else { return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}`; } }),
          (selectedUnit.psychic||[]).map(p=>`${p.name}${p.points? ' +'+p.points+'pts':''}`)
        ) : [];
        const upList = selectedUnit && upItems.length ? `<div class="slot-details"><span class="label">Upgrades</span> ${upItems.join(', ')}</div>` : '';
        const selectHtml = `<select class="select-compact" onchange="setSlotSelection(${fIdx},'${section}',${sIdx}, this.value)">${options}</select>`;
        return `<div class="slot-compact"><div class="slot-pill">${slot.label}${slot._group?` #${slot._group.index}`:''}</div><div class="slot-meta-row">Unit size: ${unitSize} <span class="cost">${slotPts} PTS</span></div><div class="slot-select">${selectHtml}</div>${unitsHtml}${loadList}${upList}</div>`;

      }



      function renderSpecialBlock(f,fIdx,special){
        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const allowedUnits = list.filter(u => special.allowedTypes.includes(u.slotType));
        const selectedId = (armyFormations[fIdx].special._selectedUnitId || (((special.units||[])[0]||{}).id) || '');
        const options = `<option value="">Select unit</option>` + allowedUnits.map(u=>`<option value="${u.id}" ${u.id===selectedId?'selected':''}>${u.name}</option>`).join('');
        const selectedUnit = (special.units||[])[0] || null;
        const unitSize = selectedUnit ? (selectedUnit.models || selectedUnit.baseModels || '-') : 0;
        const slotPts = selectedUnit ? unitPoints(selectedUnit) : 0;
        const unitsHtml = selectedUnit ? `
          <div class="unit-item"><div class="u-actions"><button class="btn btn-xs btn-blue" onclick="window.openEditModal(${fIdx},'special',0,0)">Upgrades</button><button class="btn btn-xs btn-red" title="Remove" onclick="window.removeSpecialUnit(${fIdx},0)">🗑</button></div></div>
        ` : `<div class="small muted" style="margin-top:6px">Select unit</div>`;
        const loadList = selectedUnit && (selectedUnit.weapons||[]).length ? `<div class="slot-details"><span class="label">Loadout</span> ${(selectedUnit.weapons||[]).map(w=>w.name).join(', ')}</div>` : '';
        const upItems = selectedUnit ? ([]).concat(
          (selectedUnit.upgrades||[]).map(u=>{ const cnt=Number(u.count||0); if(u.type==='BROOD_SIZE'){ const step=(UNIT_BROOD_STEP&&UNIT_BROOD_STEP[selectedUnit.id])||1; const delta=cnt? step*cnt : (u.modelsDelta||0); return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}${delta? ' (+'+delta+' models)':''}`; } else { return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}`; } }),
          (selectedUnit.psychic||[]).map(p=>`${p.name}${p.points? ' +'+p.points+'pts':''}`)
        ) : [];
        const upList = selectedUnit && upItems.length ? `<div class="slot-details"><span class="label">Upgrades</span> ${upItems.join(', ')}</div>` : '';
        const selectHtml = `<select class="select-compact" onchange="addUnitToSpecial(${fIdx}, this.value)">${options}</select>`;
        return `<div class="slot-compact"><div class="slot-pill">${special.label}</div><div class="slot-meta-row">Unit size: ${unitSize} <span class="cost">${slotPts} PTS</span></div><div class="slot-select">${selectHtml}</div>${unitsHtml}${loadList}${upList}</div>`;
      }



      const FACTION_RULES = {
        Tyranids: [
          { title: 'Tactics: New Orders', items: [
            'Rampage: Must move at double rate toward the nearest enemy model. If it contacts an enemy model it stops and fights in close combat during the combat phase. If the closest path would pass through impassable terrain, move around it following the shortest path.',
            'Hunt: Moves at normal rate toward the nearest enemy model not already in close combat, moving into close combat if possible. If not pinned and not in close combat during the combat phase, it shoots at the nearest enemy model in the advance fire segment.',
            'Nest: Does not move but shoots at the nearest enemy model in the first fire segment of the combat phase.'
          ]},
          { title: 'Tactics: Objectives', items: [
            'Tyranid armies do not score victory points from holding objective counters. Their aim is to bring enemy forces to battle and crush resistance for biomass consumption.'
          ]},
          { title: 'Tactics: Victory Points', items: [
            '1 Victory Point for each detachment destroyed.',
            '1 Victory Point for each quadrant of the playing field not occupied by any enemy forces each turn.',
            'No victory points for controlling objectives.'
          ]},
          { title: 'Tactics: Brood & Detachments', items: [
            'In Tyranid forces, the term “Brood” is used and has the exact same rules meaning as “Detachment”.'
          ]},
          { title: 'Psychic Powers', items: [
            'Models with Psychic Powers may use them irrespective of other actions they have taken.',
            'A model must generally make a Morale check to use psychic powers; Synapse (X") does not auto-pass Psychic Tests.',
            { name:'Psychic Scream', desc:'During the First Fire phase, make a Morale check. If passed, all units within 8" of the unit with Psychic Scream must take a morale test and, if failed, must fall back.' },
            { name:'Catalyst', desc:'During the Combat Phase, the unit may perform a morale test; if passed, a single brood within 8" gains Feel No Pain.' },
            { name:'The Horror', desc:'Before rolling dice for being engaged, the unit may perform a morale check. If passed, the enemy unit rolls one additional die and discards the highest; apply CAF as normal.' }
          ]},
          { title: 'Special Rules', items: [
            { name:'Synapse (X")', desc:'Models with Synapse are conduits to the Hive Mind. Units within range automatically pass morale checks except those used to test for Psychic Power abilities.' },
            { name:'Instinct: X', desc:'At the end of the Imitative Phase, models with Instinct: X must take a Morale check. If failed, they automatically receive the corresponding order. Where a brood has multiple Instinct values, use the majority; on a tie, roll a die to determine precedence.' },
            { name:'Regeneration', desc:'When a model with Regeneration reaches 0 wounds, do not remove it; the unit may still return. In the end phase, if the unit has fewer than full wounds, roll one D6 for each wound suffered; each 6+ restores one wound.' },
            { name:'Chameleon Skin (X)', desc:'Models with Chameleon Skin blend into the environment. They may not be targeted by enemy units if engaged outside of value X (e.g., 10").' },
            { name:'Winged', desc:'Units with Winged may partake in close combat even if they have the Flyer special rule.' },
            { name:'Burrow', desc:'Instead of moving, a unit with Burrow may return to reserves to be deployed again using deep strike in subsequent turns.' },
            { name:'Spawn (X, Y)', desc:'A model may spawn Y units of type X. If the spawned units share the same formation type they are added to the Brood; otherwise they form a new Brood acting independently. Place spawned units as close as possible to the spawning unit. Example: Spawn(Termagant, D3). If insufficient models are available, ignore extra results.' },
            { name:'Miasma', desc:'Units with Miasma are covered in toxic gases that distort aim. Attacks against a unit with Miasma suffer -1 to To Hit; enemy units engaged with a unit that has Miasma suffer -1 CAF.' }
          ]},
          { title: 'Gear: Weapon Traits', items: [
            { name:'Attract', desc:'On a hit against a model of equal or lesser category (Infantry, Walker, Super-Heavy Vehicle, Knight, Titan designated by value) that does not have Implacable, if the attack fails to kill the target move the closest model D6" toward the attacking unit. If this enters close combat the units are now Engaged. No effect if blocked by shields such as Void Shields or Ion Shields.' },
            { name:'Hunger', desc:'Each time an enemy is slain by a weapon with this trait, the attacker regains a wound up to its maximum.' },
            { name:'Beam', desc:'The attack traces a straight line from firer to target; any formation under this line is a target and is affected as if fired upon directly.' },
            { name:'Parry', desc:'When a model with Parry fights in Close Combat it may force the opponent to re-roll one die.' }
          ]},
          { title: 'Gear: Spore Mines & Launcher', items: [
            { name:'Spore Mines', desc:'Tokens that follow the rules of a lone model; can be targeted; have no save or special rules; if killed, they detonate. At the start of the end phase each spore mine moves randomly: roll a scatter die and move D6" in that direction (use the arrow on Hit). If contacting a non-Tyranid unit or impassable terrain they detonate; if entering a building they enter as per building rules and may move away next turn. On detonation place a Blast (3") marker; all models covered suffer a hit with profile: Spore Mine Explosion, AP -1, Traits: Blast (3"), Light AT.' },
            { name:'Spore Launcher', desc:'Choose a target as per normal targeting rules; the Spore Mine targets the closest model in that detachment. Roll 2D6 and a scatter die; place the Spore Mine as indicated. On Hit use the arrow; if the new location is in base contact or impassable terrain, detonate immediately as per Spore Mines.' }
          ]},
          { title: 'The Army List', items: [
            'As the Tyranids do not conform to the strict hierarchies of the Imperium the Army list follows a slightly different format than those found in the core Legions Imperialis rulebook.'
          ]},
          { title: 'Army List: Unit Types', items: [
            { lead: 'Unit Types' },
            { name:'Synapse', desc:'Broods. in. this. category. are. the. conduits. to. the. Hive. Mind,.without.these.the.Swarm.would.be.little.more.than. mindless. beasts. easily. tricked,. trapped. and. destroyed. the. foes.of.the.Great.Devourer.' },
            { name:'Core', desc:'Core.units.are.all.the.units.regularly.seen.in.the.Tyranid. Army,. these. include. Broods. such. as. the. lowly. Termagant. up.to.mighty.beasts.such.as.the.Carnifex.or.Tervigon..The. majority.of.the.units.in.a.Tyranid.army.will.be.comprised. of.these.Core.Broods..It.is.up.to.you.as.the.player.to.mix.and. match.and.either.create.a.massive.swarm.with.thousands. of. critters. or. build. a. massive. horde. full. of. unstoppable. monsters.' },
            { name:'Bio-Titans', desc:'Bio-Titans.cover.a.range.of.units.from.large.Bio-Constructs. up. to. the. massive. Bio-Titans. that. the. Hive. Mind. can. conjure. up.. These. include. units. from. the. Trygons. up. to. the.massive.Hierophant.titans..While.rare.in.the.context.of. the. untold. millions,. Bio-Titans. are. a. formidable. addition. to.any.swarm.and.creatures.that.can.sway.the.tide.of.battle. of.their.own.' },
            { name:'Flyers', desc:'The.Hive.Mind.is.ever.present,.when.it.is.set.on.devouring. a.world.it.engulfs.it.in.space,.in.the.warp,.on.the.surface.but. also.in.the.skies..The.Flyers.of.the.Tyranids.are.formidable. foes.that.echo.the.mythical.dragons.of.antiquity.and.many. are.the.Imperial.pilots.undone.by.their.overconfidence.in. the.technology.of.their.flying.machines. Flyers. are. a. strong. supporting. element. to. any. Tyranid. swarm.from.the.winged.Harpies.to.the.massive.Harridans' }
          ]},
          { title: 'Army Special Rules', items: [
            'Commander',
            'Invulnerable Save (5+)',
            'Synapse (12")',
            'Shadow in the Warp',
            'Synaptic Relay',
            'Synaptic Control'
          ]},
          { title: 'Army Special Rules: Descriptions', items: [
            { name:'Commander', desc:'Represents the nodal dominance of a major organism within the swarm; the detachment can issue and receive orders effectively even when other synaptic conduits are disrupted.' },
            { name:'Invulnerable Save (5+)', desc:'A resilient outer carapace or bio-field that grants a 5+ save which cannot be modified by AP or similar effects.' },
            { name:'Synapse (12")', desc:'A synaptic aura emanates from key organisms. Friendly Tyranid units within 12" automatically pass morale checks except those used when testing for Psychic Powers.' },
            { name:'Shadow in the Warp', desc:'The ambient psychic pressure of the swarm distorts the immaterium. Enemy units suffer penalties to psychic reliability and may find their morale shaken by its oppressive presence.' },
            { name:'Synaptic Relay', desc:'Orders and behavioral directives propagate through synapse-linked organisms, allowing commands to be relayed across broods without direct line of command.' },
            { name:'Synaptic Control', desc:'Under tight synaptic dominance the swarm’s behavior can be overridden to execute coordinated maneuvers beyond instinctive patterns.' }
          ]},
          { title: 'Psychic Powers', items: [
            'The Horror (+15 points)',
            'Catalyst (+15 points)',
            'Paroxysm',
            'Psychic Scream'
          ]},
          { title: 'Options', items: [
            'Add Wings (+20 points): Change movement profile to 10" and add Flying to Special Rules.',
            'Upgrade to Swarm Lord (+25 points): Change CAF to +14; Change Wounds to 3; Remove Venom Cannon / Barbed Strangler.'
          ]}
        ],
        Eldar: [
          { title: 'Army Special Rules', items: [
            'Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports.',
            'Wraith Constructs: Compulsory Core detachments must be filled with Wraithlords or Wraithguard only; HQ must be Farseer or Warlock only.',
            'Dire Needs: All models increase Tactical Strength by 1 when contesting an Objective with Wraithguard or Wraithlord also contesting.'
          ]},
          { title: 'Psychic Powers', items: [
            'Guide',
            'Doom'
          ]},
          { title: 'Formation Options', items: [
            'Wraithgate Assault: All models must have Move >10" or be mounted in a Transport; all detachments gain Forward Deployment.',
            'Tank Commander: One model from a Compulsory detachment must be upgraded with Commander for +10 pts.'
          ]}
        ],
        Orks: [
          { title: 'Army Special Rules', items: [
            'Sneaky Now: Each mob must take a Nob if able to.',
            'Taktiks: All units gain Outflank and must deploy using the special rule.',
            'Primitive: May not take any detachment of size 2 or more unless it also has Clan(Snakebites).',
            'Wierdboy Shamans: While at least 1 Wierdboy in this formation, generate +2 dice for Psychic Powers.',
            'Mob Rule',
            'Ramshackle'
          ]},
          { title: 'Sub-faction Notes', items: [
            'Blood Axes: One of Air Support/Heavy Armor/Artillery may be selected for Special.',
            'Snakebites: One of Battle Tank/Core/Vanguard for Special.'
          ]}
        ]
      };

      async function openReferenceArmyRules(){ setReferenceView('army-rules'); try{ await ensureFactionRules(); }catch(e){} updateReferenceHash(); requestRender(); }

      function setArmyRulesFactionTab(name){ armyRulesFaction = name; updateReferenceHash(); requestRender(); }
      function renderArmyRuleTabs(){ const armies=Object.keys(ARMIES).filter(a=>a!=='Select Army'); return `<div class="subtabs">${armies.map(a=>`<button class="pill ${a===armyRulesFaction?'active':''}" onclick="setArmyRulesFactionTab('${a}')">${a}</button>`).join('')}</div>`; }
      function renderReferenceArmyRules(){ const rules=(FACTION_RULES[armyRulesFaction]||[]); const list = rules.length ? rules.map(entry=>{ if(typeof entry==='string'){ return `<p class="pdf-paragraph">${entry}</p>`; } else { const inner=(entry.items||[]).map(r=>{ if(typeof r==='string'){ return `<p class="pdf-paragraph">${r}</p>`; } if(r && r.lead){ return `<p class="pdf-lead">${r.lead}</p>`; } if(r && r.name){ const key=String(r.name||''); const known = (typeof RULES_INDEX === 'object') && (RULES_INDEX[_normKey(key)] !== undefined); const head = known ? `<div class="pdf-subhead rule-key" data-rule="${key}" onclick="openRuleDialog('${key}')">${key}</div>` : `<div class="pdf-subhead">${key}</div>`; return head + `<p class="pdf-paragraph">${r.desc||''}</p>`; } return ''; }).join(''); return `<div class="pdf-section"><div class="rb-section-head">${entry.title||armyRulesFaction}</div>${inner}</div>`; } }).join('') : `<div class="muted small">No rules available</div>`; const tabs=renderArmyRuleTabs(); return `<div style="padding:12px">${renderCrumbs([{label:'Reference',on:'openReferenceHome()'},{label:'Army Rules'}])}${tabs}<div class="army-rules-page"><div class="pdf-heading">${armyRulesFaction}</div><div class="pdf-divider"></div>${list}</div><div style="margin-top:8px"><button class="btn" onclick="openReferenceHome()">Back</button></div></div>`; }

      async function ensureFactionRules(){ try{ if(window._factionRulesLoaded) return; const resp1 = await fetch('data/faction_rules.json',{cache:'no-store'}); if(resp1 && resp1.ok){ const data = await resp1.json(); Object.keys(data||{}).forEach(f=>{ const sections = data[f]||[]; if(Array.isArray(sections) && sections.length){ const existing = Array.isArray(FACTION_RULES[f]) ? FACTION_RULES[f] : []; const incoming = sections.map(s=> (typeof s==='string' ? { title:'Army Special Rules', items:[s] } : s)); if(existing.length===0){ FACTION_RULES[f] = incoming; } else { incoming.forEach(sec=>{ const title = sec && sec.title ? sec.title : 'Army Special Rules'; const has = existing.some(e=> (typeof e==='object') && (e.title===title)); if(!has){ existing.push(sec); } }); FACTION_RULES[f] = existing; } } }); }
      const resp2 = await fetch('PDF/MainRules.json',{cache:'no-store'}); if(resp2 && resp2.ok){ const json = await resp2.json(); const traits = json.traitLibrary||{}; if(FACTION_RULES.Tyranids && !FACTION_RULES.Tyranids.some(e=>typeof e==='object' && e.title==='Traits (Reference)')){ FACTION_RULES.Tyranids.push({ title:'Traits (Reference)', items: Object.keys(traits).slice(0,10).map(k=>`${k}: ${traits[k]}`) }); }
      }
      window._factionRulesLoaded=true; }catch(e){} }



      function renderRoster(){
        const hasSaved = (savedLists||[]).length > 0;
        const active = currentListId ? (savedLists||[]).find(x=>x.id===currentListId) : null;
        const working = (armyFormations||[]).length > 0;

        if(!hasSaved && !working){
          return `<div style="padding:12px"><div class="hero"><button class="btn btn-green hero-cta" onclick="createNewList()">Create List</button></div><div class="muted small" style="margin-top:8px">No saved lists yet.</div></div>`;
        }

        if(active){
          const formations = active.formations||[];
          const pointsUsed = formations.reduce((s,f)=>s+formationPoints(f),0);
          const pointsCap = active.pointsCap||2000;
          const header = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong class="roster-title">${active.name}</strong><div class="small muted">${active.faction||'-'}</div></div><div style="display:flex;gap:8px;align-items:center"><div class="small muted">${pointsUsed}/${pointsCap} pts</div><button class="btn btn-blue btn-sm" onclick="setActiveTab('army-builder')">Open in Builder</button><button class="btn btn-blue btn-sm" onclick="printRoster()">Print</button></div></div>`;
          const body = formations.length ? formations.map(f=>`<details class="roster-panel" style="padding:12px;margin-bottom:12px;background:#071a21;border-radius:8px"><summary><div style="display:flex;justify-content:space-between;align-items:center"><div><strong class="roster-title">${f.name}</strong>${ formationHasMinViolations(f) ? `<span class="form-alert"> Compulsory Unit Missing</span>` : '' }<div class="small muted">${f.army}</div></div><div class="small muted">Total: ${formationPoints(f)} pts</div></div></summary><div style="margin-top:10px">${(()=>{ const cuPairs=(f.compulsory||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Compulsory',type:s.type,index:(s._group&&s._group.index)||undefined}}))); return cuPairs.length? `<div class=\\\"section-sub\\\">Compulsory</div>`+cuPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''; })()}${(()=>{ const ouPairs=(f.optional||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Optional',type:s.type,index:(s._group&&s._group.index)||undefined}}))); return ouPairs.length? `<div class=\\\"section-sub\\\">Optional</div>`+ouPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''; })()}${(()=>{ const suPairs=(f.special && f.special.units)||[]; return suPairs.length? `<div class=\\\"section-sub\\\">Special</div>`+suPairs.map(u=>renderRosterUnit(u,{label:(f.special&&f.special.label)||'Special',section:'Special',type:(f.special&&f.special.type)||'Special'})).join('') : ''; })()}</div></details>`).join('') : `<div class=\"muted small p-4\">No formations yet.</div>`;
          return `<div style="padding:8px"><div class="crumbs small muted">Roster › ${active.name}</div><div class="card" style="padding:8px">${header}</div>${body.replace(/padding:12px/g,'padding:8px').replace(/margin-bottom:12px/g,'margin-bottom:8px')}</div>`;
        }

        if(!working){
          return renderLists();
        }

        if(!armyFormations.length) return `<div style="padding:12px" class="muted small">No formations added.</div>`;

        return `<div style="padding:8px"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><div class="crumbs small muted">Roster</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-blue btn-sm" onclick="setActiveTab('army-builder')">Open in Builder</button><button class="btn btn-blue btn-sm" onclick="printRoster()">Print</button></div></div>${armyFormations.map((f,fi)=>`<details class="roster-panel" style="padding:8px;margin-bottom:8px;background:#071a21;border-radius:8px"><summary><div style="display:flex;justify-content:space-between;align-items:center"><div><strong class="roster-title">${f.name}</strong>${ formationHasMinViolations(f) ? `<span class="form-alert"> Compulsory Unit Missing</span>` : '' }<div class="small muted">${f.army}</div></div><div class="small muted">Total: ${formationPoints(f)} pts</div></div></summary><div style="margin-top:8px">${(()=>{ const cuPairs=(f.compulsory||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Compulsory',type:s.type,index:(s._group&&s._group.index)||undefined}}))); return cuPairs.length? `<div class=\\\"section-sub\\\">Compulsory</div>`+cuPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''; })()}${(()=>{ const ouPairs=(f.optional||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Optional',type:s.type,index:(s._group&&s._group.index)||undefined}}))); return ouPairs.length? `<div class=\\\"section-sub\\\">Optional</div>`+ouPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''; })()}${(()=>{ const suPairs=(f.special && f.special.units)||[]; return suPairs.length? `<div class=\\\"section-sub\\\">Special</div>`+suPairs.map(u=>renderRosterUnit(u,{label:(f.special&&f.special.label)||'Special',section:'Special',type:(f.special&&f.special.type)||'Special'})).join('') : ''; })()}</div></details>`).join('')}</div>`;

      }



      function renderRosterUnit(u, slotInfo){ return renderUnitReference(u, slotInfo); }

      function renderUnitReference(u, slotInfo){
        let caf = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].baseCAF) || (UNIT_BASE[u.id] && UNIT_BASE[u.id].CAF) || '';
        let wounds = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].baseWounds) || (UNIT_BASE[u.id] && UNIT_BASE[u.id].wounds) || '-';
        let move = (UNIT_BASE[u.id] && UNIT_BASE[u.id].movement) || '-';
        let save = (UNIT_BASE[u.id] && UNIT_BASE[u.id].save) || '-';
        let morale = (UNIT_BASE[u.id] && UNIT_BASE[u.id].morale) || '-';
        const applied = u._appliedEffects || {};
        const swarm = applied.swarmLord;
        const upgStats = (u.upgrades||[]).reduce((acc,up)=>{ const e=UPGRADE_EFFECTS[up.id]; if(!e) return acc; if(e.stats && e.stats.CAF) acc.CAF=e.stats.CAF; if(e.stats && e.stats.Wounds) acc.Wounds=e.stats.Wounds; if(e.stats && e.stats.Movement) acc.Movement=e.stats.Movement; return acc; }, { CAF:caf, Wounds:wounds, Movement:move });
        if(swarm){ caf = swarm.CAF; wounds = swarm.Wounds; } else { caf = upgStats.CAF || caf; wounds = upgStats.Wounds || wounds; move = upgStats.Movement || move; }
        const dynRules=[]; (u.upgrades||[]).forEach(up=>{ const e=UPGRADE_EFFECTS[up.id]; (e&&e.rules||[]).forEach(r=>{ if(!dynRules.includes(r)) dynRules.push(r); }); });
        const baseRules = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].specialRules) ? UNIT_LOADOUTS[u.id].specialRules.slice() : [];
        const mergedRules = baseRules.concat(dynRules.filter(r=>!baseRules.includes(r)));
        const weaponsHtml = (u.weapons||[]).length ? `<table class="table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th><th>Cost</th></tr></thead><tbody>` + (u.weapons||[]).map(w => { const stat = WEAPON_LIBRARY[w.src] || {}; return `<tr><td>${w.name}</td><td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td><td class="cost">${w.points||0} pts</td></tr>`; }).join('') + `</tbody></table>` : `<div class="small muted">No weapons selected</div>`;
        const upgradesHtml = (u.upgrades||[]).length ? (u.upgrades||[]).map(up=>`<div><strong>${up.name}</strong> <span class="muted">(+${up.points||0} pts)</span><div class="muted">${up.desc||''}</div></div>`).join('') : `<div class="small muted">No upgrades</div>`;
        const psychicHtml = (u.psychic||[]).length ? (u.psychic||[]).map(p=>`<div><strong>${p.name}</strong> <span class="muted">(+${p.points||0} pts)</span><div class="muted">${p.desc||''}</div></div>`).join('') : '';
        const effectHtml = swarm ? `<div class="effect-pill" style="display:inline-block;margin-top:6px">Swarm Lord: CAF ${swarm.CAF}; W ${swarm.Wounds}</div>` : '';
        const specialRules = mergedRules.length ? mergedRules.map(r=>renderRuleText(r)).join('') : '';

        const headerHtml = `
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="display:flex;gap:8px;align-items:center">
              <div style="font-weight:800">${u.name} <span class="muted">(${u.models || u.baseModels || '-'} models)</span></div>
              ${(()=>{ const sec=(slotInfo&&slotInfo.section)||''; const lab=(slotInfo&&slotInfo.label)||((UNIT_BASE[u.id]&&UNIT_BASE[u.id].type)||u.slotType||''); return `<span class="pill">${sec?sec+': ':''}${lab}</span>`; })()}
            </div>
            <div class="right-col small muted">
              <div>Points: ${unitPoints(u)} pts</div>
            </div>
          </div>`;

        const bodyHtml = `
          <div style="margin-top:8px"><strong>Unit</strong>${(()=>{ const typeVal=(UNIT_BASE[u.id] && UNIT_BASE[u.id].type) || u.slotType; return `<table class="table"><thead><tr><th>Type</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th></tr></thead><tbody><tr><td>${typeVal||'-'}</td><td>${move}</td><td>${save}</td><td>${caf}</td><td>${morale}</td><td>${wounds}</td></tr></tbody></table>`; })()}</div>
          ${effectHtml}
          ${specialRules ? `<div style="margin-top:8px"><strong>Special rules</strong>${specialRules}</div>` : ''}
          <div style="margin-top:8px"><strong>Weapons</strong>${weaponsHtml}</div>
          <div style="margin-top:8px"><strong>Upgrades</strong>${upgradesHtml}</div>
          ${psychicHtml ? `<div style="margin-top:8px"><strong>Psychic powers</strong>${psychicHtml}</div>` : ''}
          ${u.notes && u.notes.length ? `<div class="notes" style="margin-top:8px">${u.notes.join('; ')}</div>` : ''}`;

        return `
          <details class="roster-unit">
            <summary>${headerHtml}</summary>
            <div>${bodyHtml}</div>
          </details>
        `;

      }

      function printRoster(){
        try{
          const root=document.getElementById('content');
          if(!root){ window.print(); return; }
          const details=Array.from(root.querySelectorAll('details'));
          const states=details.map(d=>d.open);
          details.forEach(d=>{ d.open=true; });
          setTimeout(()=>{ try{ window.print(); }finally{ setTimeout(()=>{ details.forEach((d,i)=>{ d.open = states[i]; }); },300); } },50);
        }catch(e){
          try{ window.print(); }catch(_) {}
        }
      }

      function renderReferenceUnitDetail(){ const army=referenceDetail.army; const unitId=referenceDetail.unitId; const key=armyKey(army||selectedArmy); const list=(ARMY_UNIT_LIST[key]||[]); const base=list.find(u=>u.id===unitId)||{name:slugToName(unitId),slotType:'Core'}; const stats=UNIT_BASE[unitId]||{}; const load=UNIT_LOADOUTS[unitId]||{weapons:[],specialRules:[],upgrades:[]}; const weapons=(load.weapons||[]).filter(w=>w.base); const rows=weapons.length? weapons.map(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; return `<tr><td>${w.name}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`; }).join('') : `<tr><td colspan="6" class="small muted">No base weapons</td></tr>`; const rulesHtml=(load.specialRules||[]).length?(load.specialRules||[]).map(r=>renderRuleText(r)).join(''):`<div class="muted small">No special rules listed</div>`; const ups=(load.upgrades||[]); const upsBlock=ups.length?`<div class="section-sub">Upgrades</div><div><button class="btn btn-sm" onclick="toggleReferenceUpgrades()">${referenceShowUpgrades?'Hide':'Show'} Upgrades</button>${referenceShowUpgrades?ups.map(u=>`<div style="margin-top:4px"><strong>${u.name}</strong> <span class="muted">(+${u.points||0} pts)</span><div class="muted">${u.desc||''}</div></div>`).join(''):''}</div>`:''; return `<div style="padding:12px"><div class="crumbs small muted">Reference › Units › ${base.name}</div><div class="card" style="padding:0"><div class="section-bar">${base.name}</div><div style="padding:8px"><div style="display:flex;justify-content:space-between"><div class="pill">${base.slotType}</div><div class="pill">${army||'-'}</div></div><table class="table" style="margin-top:8px"><thead><tr><th>Name</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th></tr></thead><tbody><tr><td>${base.name}</td><td>${stats.movement||'-'}</td><td>${stats.save||'-'}</td><td>${stats.CAF||'-'}</td><td>${stats.morale||'-'}</td><td>${stats.wounds||'-'}</td></tr></tbody></table><div class="section-sub">Weapons</div><table class="table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${rows}</tbody></table><div class="section-sub">Special Rules</div><div>${rulesHtml}</div>${upsBlock}</div></div><div style="margin-top:8px"><button class="btn" onclick="setReferenceView('units')">Back to Units</button><button class="btn" style="margin-left:8px" onclick="openReferenceHome()">Reference Home</button></div></div>`; }



      // ---------- Bootstrap ----------

      document.addEventListener('DOMContentLoaded', ()=>{ loadState(true); document.body.classList.add('rb-theme'); document.body.addEventListener('click',(e)=>{ const btn=e.target.closest('.icon-btn[data-action]'); if(btn){ const act=btn.getAttribute('data-action'); if(act==='delete-list') deleteCurrentList(); e.preventDefault(); }
        const fbtn=e.target.closest('.mini-icons .icon-btn[data-action]'); if(fbtn){ const act=fbtn.getAttribute('data-action'); const fi=Number(fbtn.getAttribute('data-fi')); if(act==='formation-toggle') toggleCollapse(fi); else if(act==='formation-clone') cloneFormation(fi); else if(act==='formation-remove') removeFormation(fi); e.preventDefault(); }
        const lbtn=e.target.closest('td button[data-action]'); if(lbtn){ const act=lbtn.getAttribute('data-action'); const id=lbtn.getAttribute('data-id'); if(act==='list-models') listModels(id); else if(act==='duplicate-list') duplicateList(id); else if(act==='view-list') viewList(id); else if(act==='copy-link') copyBuilderLink(id); else if(act==='delete-list') deleteList(id); e.preventDefault(); }
        const bulkBtn=e.target.closest('button[data-action]'); if(bulkBtn){ const act=bulkBtn.getAttribute('data-action'); if(act==='bulk-del'){ if(selectedListIds.length){ savedLists = (savedLists||[]).filter(l=> !selectedListIds.includes(l.id)); selectedListIds = []; persistSavedLists(); renderContent(); } e.preventDefault(); } else if(act==='bulk-export'){ if(selectedListIds.length){ exportSelectedListsPDF(); } e.preventDefault(); } else if(act==='bulk-open'){ if(selectedListIds.length===1){ const id=selectedListIds[0]; openInBuilder(id); setActiveTab('army-builder'); } e.preventDefault(); } else if(act==='list-open'){ const id=bulkBtn.getAttribute('data-id'); if(id){ openInBuilder(id); setActiveTab('army-builder'); } e.preventDefault(); } else if(act==='list-export'){ const id=bulkBtn.getAttribute('data-id'); if(id){ exportListPDF(id); } e.preventDefault(); } else if(act==='list-del'){ const id=bulkBtn.getAttribute('data-id'); if(id){ deleteList(id); } e.preventDefault(); } }
        const mh=e.target.closest('#modal-unit-summary .btn[data-action]'); if(mh){ const act=mh.getAttribute('data-action'); if(act==='unit-dec') window.headerModelBump(-1); else if(act==='unit-inc') window.headerModelBump(1); e.preventDefault(); }
        const dd=e.target.closest('#account-menu .dropdown-item[data-action]'); if(dd){ const act=dd.getAttribute('data-action'); if(act==='open-profile') openProfile(); else if(act==='logout') handleLogout(); e.preventDefault(); }
        const a=e.target.closest('a[href=\"#\"]'); if(a){ e.preventDefault(); } });
        document.body.addEventListener('change',(e)=>{ const sel=e.target.closest('[data-action]'); if(!sel) return; const act=sel.getAttribute('data-action'); if(act==='army-select') handleArmySelection(sel.value); else if(act==='formation-select') handleFormationSelection(sel.value); else if(act==='add-formation') addFormation(); else if(act==='builder-name') setBuilderName(sel.value); else if(act==='points-cap') setBuilderPoints(sel.value); else if(act==='slot-select'){ const fi=Number(sel.getAttribute('data-fi')); const sec=sel.getAttribute('data-sec'); const si=Number(sel.getAttribute('data-si')); setSlotSelection(fi,sec,si,sel.value); } else if(act==='special-select'){ const fi=Number(sel.getAttribute('data-fi')); addUnitToSpecial(fi, sel.value); } else if(act==='list-select'){ const id=sel.getAttribute('data-id'); const isChecked=sel.checked; const set=new Set(selectedListIds); if(isChecked) set.add(id); else set.delete(id); selectedListIds = Array.from(set); renderContent(); } else if(act==='select-all'){ const all=(savedLists||[]).map(l=>l.id); const isChecked=sel.checked; selectedListIds = isChecked ? all : []; renderContent(); } });
        document.addEventListener('click',()=>{}, true);
        document.addEventListener('keydown',(e)=>{ if(e.key==='Escape'){ closeModal(); } });
        loadConsolidatedArmyMaster(selectedArmy).then(ref=>{ setActiveTab('home'); if(ref){ window._lastMasterRef = ref; applyMasterBroodDefaults(ref); applyUpgradeConstraintsFromMaster(ref); buildUpgradeEffectsFromMaster(ref); buildArmyUnitsFromMaster(ref, selectedArmy); }
          initRulesIndex();
          const doPDF = (window.ENABLE_PDF_INGEST===true) || (localStorage.getItem('enable_pdf_ingest')==='1');
          const ingest = doPDF ? ingestPDFDocs() : Promise.resolve();
          return ingest.then(()=>{ buildUpgradeEffects(); runValidation(ref||{}); validateFormationRules(); dataStatus.validationIssues = (window._latestValidationIssues||[]).length; updateStatusBanner(); try{ if((location.hash||'').startsWith('#ref')) location.hash=''; }catch(e){} setActiveTab('home'); requestRender(); refreshAuthButton(); }); }); });



      // expose for quick debugging

      window._app = { armyFormations, renderContent, setActiveTab, UNIT_LOADOUTS, WEAPON_LIBRARY };
      window.openEditModal = openEditModal;
      window.closeModal = closeModal;
      window.removeUnit = removeUnit;
      window.removeSpecialUnit = removeSpecialUnit;

  </script>

</body>



</html>
