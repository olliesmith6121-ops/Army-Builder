<!DOCTYPE html>

<html lang="en">



<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Xenos Army Builder</title>
  <link rel="icon" type="image/png" href="Images/WebIcon.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111827">
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- Inline styles migrated to styles.css -->
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore-compat.js"></script>
  <script>
    window.XENOS_FIREBASE_CONFIG = {
      apiKey: "AIzaSyCU1-OZq-HFPjGUtDkOnykD7HhZDuxYuIc",
      authDomain: "army-builder-a6f09.firebaseapp.com",
      projectId: "army-builder-a6f09",
      storageBucket: "army-builder-a6f09.firebasestorage.app",
      messagingSenderId: "303583993851",
      appId: "1:303583993851:web:6ee3a610db69a3b323755e",
      measurementId: "G-1DWFSZT8VB"
    };
  </script>

</head>



<body>

  <div class="container">

    <header style="text-align:center;margin-bottom:16px">

      <div style="display:flex; justify-content:center; align-items:center; margin-bottom:12px">
        <h1 class="app-title">
          <img src="Images/WebIcon.png" class="title-icon" alt=""/>
          Xenos Army Builder
          <img src="Images/WebIcon.png" class="title-icon" alt=""/>
        </h1>
      </div>

      

      <nav class="topbar">
        <a href="#" data-tab="home" onclick="event.preventDefault(); setActiveTab('home')">Home</a>
        <a href="#" data-tab="reference" onclick="event.preventDefault(); setActiveTab('reference')">Reference</a>
        <a href="#" data-tab="lists" onclick="event.preventDefault(); setActiveTab('lists')">Lists</a>
        <a href="#" data-tab="roster" onclick="event.preventDefault(); setActiveTab('roster')">Roster</a>
        <div class="account-wrap"><button id="auth-btn" class="btn btn-sm" onclick="openLoginModal()">Login</button></div>
      </nav>
      <div id="status-banner" class="warn" style="display:none"></div>

    </header>



    <div class="tabs" style="display:none"></div>



    <div id="content" class="tab-content card" style="padding:16px;"></div>

  </div>



  <div id="modal-root"></div>



  <script>
    // Global Error Handler for Mobile Debugging
    window.onerror = function(msg, url, line, col, error) {
      alert('Global JS Error: ' + msg + '\nLine: ' + line);
      return false;
    };

    // ---------- Auth ----------
      let currentUserId = null;
      let currentUserName = '';
      let currentUserIsGoogle = false;
      let firebaseApp = null;
      let firebaseAuth = null;
      let firebaseDb = null;
      function loadUser(){ 
        try{ 
          const raw=localStorage.getItem('xenos_current_user'); 
          if(raw){ 
            const u=JSON.parse(raw); 
            currentUserId=u.id||'guest'; 
            currentUserName=u.name||'Guest'; 
            currentUserIsGoogle=!!u.google; 
          } else {
             // Default to Guest if no user
             currentUserId = 'guest';
             currentUserName = 'Guest';
             currentUserIsGoogle = false;
             saveUserSession();
          }
        }catch(e){
           // Fallback
           currentUserId = 'guest';
           currentUserName = 'Guest';
        } 
      }
      function saveUserSession(){ try{ const u={ id: currentUserId, name: currentUserName, google: currentUserIsGoogle }; localStorage.setItem('xenos_current_user', JSON.stringify(u)); refreshAuthButton(); }catch(e){} }
      function initCloudIfAvailable(){ 
        if(firebaseApp) return;
        if(!window.firebase || !window.firebase.initializeApp) {
           // Silent fail if offline or blocked
           return;
        }
        if(!window.XENOS_FIREBASE_CONFIG) return; 
        try{ 
          firebaseApp = firebase.initializeApp(window.XENOS_FIREBASE_CONFIG); 
          firebaseAuth = firebase.auth(); 
          firebaseDb = firebase.firestore(); 
          
          // Force Long Polling to fix "hanging" connections in restricted networks
          try {
             firebaseDb.settings({ experimentalForceLongPolling: true });
             console.log('Firestore: Long Polling Forced');
          } catch(e) {
             console.warn('Firestore Settings Error:', e);
          }
          
          // Force LOCAL persistence to ensure session survives redirects/refreshes
          firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
            .then(function() { console.log('Persistence set to LOCAL'); })
            .catch(function(err) { console.error('Persistence Error:', err); });

          // Listen for auth state changes (robust session restoration)
          firebaseAuth.onAuthStateChanged(function(user) {
            if (user) {
              console.log('Auth State Restored:', user.uid);
              // Always reload lists from cloud when auth is confirmed/restored
              // This fixes the issue where page load happens before auth is ready
              if (currentUserId !== user.uid) {
                 handleLoginSuccess(user);
              } else {
                 loadSavedLists(true); 
              }
            } else {
              console.log('Auth State: No User');
              // If we thought we were google but now aren't, revert to guest
              if(currentUserIsGoogle) {
                  currentUserId = 'guest';
                  currentUserName = 'Guest';
                  currentUserIsGoogle = false;
                  saveUserSession();
                  refreshAuthButton();
              }
            }
          });
        }catch(e){ 
          firebaseApp=null; firebaseAuth=null; firebaseDb=null; 
          console.warn('Firebase Init Failed: ' + e.message);
        } 
      }
      function storageKey(suffix){ 
          const uid = currentUserId || 'default'; 
          // Map guest to default to preserve legacy/guest data access
          const effectiveId = (uid === 'guest') ? 'default' : uid;
          return `xenos_${effectiveId}_${suffix}`; 
      }
      function refreshAuthButton(){ 
          const btn=document.getElementById('auth-btn'); 
          if(!btn) return; 
          
          if(currentUserId && currentUserId !== 'guest'){ 
              btn.textContent = `User: ${currentUserName||'User'}`; 
              btn.onclick = openProfileMenu; 
          } else { 
              // Guest Mode
              btn.textContent = 'Guest Login'; 
              btn.onclick = openGuestMenu; 
          } 
      }
      
      function openGuestMenu(){
         initCloudIfAvailable();
         const root=document.getElementById('modal-root');
         root.innerHTML = `
           <div class="modal-backdrop" onclick="closeModal()">
             <div class="modal" onclick="event.stopPropagation()">
               <h3 style="margin:0 0 8px 0">Guest Account</h3>
               <div class="small muted" style="margin-bottom:12px">You are using a local Guest account. Lists are saved to this browser.</div>
               
               <div style="border:1px solid #374151; padding:12px; border-radius:6px; background:#111827">
                  <div style="font-weight:600; margin-bottom:4px">Upgrade to Cloud Account</div>
                  <div class="small muted" style="margin-bottom:8px">Log in with Google to backup your lists and access them on other devices.</div>
                  <button class="btn btn-green" style="width:100%" onclick="loginAndTransfer()">Login & Transfer Guest Data</button>
                  <div style="text-align:center; margin-top:8px; font-size:11px" class="muted">or</div>
                  <button class="btn btn-sm" style="width:100%; margin-top:4px" onclick="googleLogin()">Login Only</button>
               </div>

               <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
                 <button class="btn" onclick="closeModal()">Close</button>
               </div>
             </div>
           </div>`;
      }

      function loginAndTransfer(){
          sessionStorage.setItem('xenos_pending_transfer', 'true');
          googleLogin();
      }

      function openProfileMenu(){
        initCloudIfAvailable();
        const root=document.getElementById('modal-root');
        
        // Check for local lists
        let hasLocal = false;
        try {
          const localRaw = localStorage.getItem('xenos_default_saved_lists');
          const local = localRaw ? JSON.parse(localRaw) : [];
          if(Array.isArray(local) && local.length > 0) hasLocal = true;
        } catch(e){}

        const transferBtn = hasLocal 
          ? `<button class="btn btn-blue" style="width:100%;margin-bottom:8px" onclick="confirmTransferLocal()">Transfer Local Lists to Account</button>` 
          : '';

        root.innerHTML = `
          <div class="modal-backdrop" onclick="closeModal()">
            <div class="modal" onclick="event.stopPropagation()">
              <h3 style="margin:0 0 8px 0">Account</h3>
              <div class="small muted" style="margin-bottom:12px">Logged in as <strong>${currentUserName}</strong></div>
              
              ${transferBtn}
              
              <button class="btn btn-red" style="width:100%" onclick="handleLogout()">Logout</button>
              
              <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
                <button class="btn" onclick="closeModal()">Close</button>
              </div>
            </div>
          </div>`;
      }

      function confirmTransferLocal(){
        const root=document.getElementById('modal-root');
        root.innerHTML = `
          <div class="modal-backdrop" onclick="closeModal()">
            <div class="modal" onclick="event.stopPropagation()">
              <h3 style="margin:0 0 8px 0">Transfer Local Lists?</h3>
              <div class="warn" style="padding:12px;margin-bottom:12px;border:1px solid var(--danger);background:rgba(127,29,29,0.2);border-radius:4px;color:#fca5a5">
                 <strong>Warning:</strong> This will copy your local (guest) lists to your logged-in account.
                 <br/><br/>
                 The local lists will be appended to your account's existing lists.
              </div>
              <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
                <button class="btn" onclick="openProfileMenu()">Back</button>
                <button class="btn btn-green" onclick="performTransfer()">Transfer Now</button>
              </div>
            </div>
          </div>`;
      }

      function performTransfer(){
        try {
            const localRaw = localStorage.getItem('xenos_default_saved_lists');
            if(!localRaw) return;
            const localLists = JSON.parse(localRaw);
            if(!Array.isArray(localLists) || !localLists.length) {
              // Just cleanup if empty
              localStorage.removeItem('xenos_default_saved_lists');
              return;
            }
            
            const currentMap = new Map(savedLists.map(l => [l.id, l]));
            const imported = [];

            localLists.forEach(l => {
                // Check if this exact list is already in savedLists (e.g. via auto-migration)
                const existing = currentMap.get(l.id);
                
                // If it exists and has same/newer timestamp, we skip it to avoid duplication
                // (Auto-migration copies exact timestamp, so this catches that)
                if (existing && (existing.updatedAt || 0) >= (l.updatedAt || 0)) {
                    console.log('Skipping already migrated list:', l.name);
                    return;
                }
                
                // Otherwise, import it as a copy
                imported.push({
                    ...l,
                    id: String(Date.now() + Math.random()).replace('.',''),
                    name: (l.name || 'Untitled') + ' (Imported)',
                    importedAt: Date.now(),
                    updatedAt: Date.now()
                });
            });
            
            if(imported.length > 0) {
                // Add to current user's lists
                savedLists = [...savedLists, ...imported];
                persistSavedLists(); // Saves to current user's storage
            }
            
            // Clear the local guest lists as they are now transferred/merged
            localStorage.removeItem('xenos_default_saved_lists');
            
            // Trigger UI update
            renderContent();
            
            // Transition to Sync Modal to push to Cloud
            const root=document.getElementById('modal-root');
            root.innerHTML = `
               <div class="modal-backdrop" onclick="if(this.dataset.blocking!=='true') closeModal()">
                 <div class="modal-drawer" onclick="event.stopPropagation()" style="width:90%;max-width:500px;height:auto;max-height:80vh">
                   <div id="sync-content">
                     <h3 style="margin:0 0 8px 0">Transferring...</h3>
                     <p>Local lists prepared.</p>
                     <p><strong>Starting Cloud Sync...</strong></p>
                     <div class="spinner"></div>
                   </div>
                 </div>
               </div>`;
            
            // Wait for DOM then trigger sync
            setTimeout(() => {
                performManualSync();
            }, 500);
            
        } catch(e){
            alert('Transfer failed: ' + e.message);
        }
      }

      function openLoginModal(){ initCloudIfAvailable(); const root=document.getElementById('modal-root'); const hasGoogle=!!firebaseAuth; const googleBlock = hasGoogle ? `<div style="margin-top:8px;display:flex;flex-direction:column;gap:8px"><button class="btn btn-green" style="width:100%" onclick="googleLogin()">Sign in with Google</button></div>` : `<div class="small muted" style="margin-top:8px">Google login is not configured in this build.</div>`; root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">Login</h3><div class="small muted">Sign in with Google to sync lists across devices or use a local account.</div>${googleBlock}<div class="small muted" style="margin-top:8px">Local account</div><div style="margin-top:8px"><input id="login-name" class="mini-input" placeholder="Username"/></div><div style="margin-top:8px"><input id="login-pass" type="password" class="mini-input" placeholder="Password"/></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button class="btn" onclick="closeModal()">Cancel</button><button class="btn btn-green" onclick="commitLogin()">Login</button></div></div></div>`; const inp=document.getElementById('login-name'); if(inp) setTimeout(()=>inp.focus(),0); }
      async function ensureArgon2(){ if(window.argon2) return true; const urls=['https://unpkg.com/argon2-browser/dist/argon2-bundled.min.js','https://cdn.jsdelivr.net/npm/argon2-browser/dist/argon2-bundled.min.js']; for(const u of urls){ try{ const s=document.createElement('script'); s.src=u; document.head.appendChild(s); await new Promise(r=>{ s.onload=r; s.onerror=r; }); if(window.argon2) return true; }catch(e){} } return !!window.argon2; }
      function genSalt(len){ const n=Math.max(8, Number(len||16)); const bytes=new Uint8Array(n); try{ crypto.getRandomValues(bytes); }catch(e){ for(let i=0;i<n;i++) bytes[i]=Math.floor(Math.random()*256); } return bytes; }
      function readUserRecord(id){ try{ const raw=localStorage.getItem('xenos_user_'+id); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
      function writeUserRecord(id, rec){ try{ localStorage.setItem('xenos_user_'+id, JSON.stringify(rec)); }catch(e){} }
      async function commitLogin(){ const inp=document.getElementById('login-name'); const pinp=document.getElementById('login-pass'); const name=(inp&&inp.value||'').trim(); const pass=(pinp&&pinp.value||''); if(!name){ alert('Enter a username'); return; } if(!pass){ alert('Enter a password'); return; } const id = name.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); const okLib = await ensureArgon2(); if(!okLib){ alert('Login unavailable: Argon2 library failed to load. Check network and try again.'); return; } const existing=readUserRecord(id); if(existing && existing.hash){ try{ const ok = await window.argon2.verify({ pass, encoded: existing.hash }); if(!ok){ alert('Incorrect password'); return; } }catch(e){ alert('Login failed'); return; } } else { try{ const res = await window.argon2.hash({ pass, salt: genSalt(16), type: window.argon2.ArgonType.Argon2id, time: 3, mem: 4096, parallelism: 1, hashLen: 32 }); writeUserRecord(id, { id, name, hash: res.encoded }); }catch(e){ alert('Could not create user'); return; } }
        currentUserId=id||'user'; currentUserName=name; currentUserIsGoogle=false; closeModal(); saveUserSession(); await loadSavedLists(true); loadState(true); selectedListIds=[]; setActiveTab('home'); renderContent(); }
      function handleLogout(){ currentUserId=null; currentUserName=''; currentUserIsGoogle=false; if(firebaseAuth){ try{ firebaseAuth.signOut(); }catch(e){} } saveUserSession(); selectedListIds=[]; currentListId=null; selectedArmy='Select Army'; armyFormations=[]; builderMeta={ name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 }; setActiveTab('home'); renderContent(); }
      function isMobileDevice(){ return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); }
      function handleAuthError(e) {
        console.error(e);
        if (e.code === 'auth/unauthorized-domain') {
          alert(`Configuration Error: Domain Unauthorized.\n\nPlease go to the Firebase Console -> Authentication -> Settings -> Authorized Domains and add:\n\n${window.location.hostname}`);
        } else if (e.code === 'auth/popup-closed-by-user' || e.code === 'auth/cancelled-popup-request') {
          // Ignore user cancellation
        } else {
          alert('Login failed: ' + e.message);
        }
      }

      function checkRedirectResult(){ 
        if(!firebaseAuth){
          // alert('Debug: Redirect Check skipped - No Auth');
          return;
        } 
        firebaseAuth.getRedirectResult().then(function(result){ 
          if(result.user){ 
            // alert('Debug: Redirect Success for ' + result.user.email);
            handleLoginSuccess(result.user); 
          } else {
             // If we just loaded the page and there is no result, this is normal for a regular visit.
             // But if the user just tried to login, this is bad.
             // We can check if we *expected* a redirect?
             const expected = sessionStorage.getItem('xenos_auth_pending');
             if(expected){
                console.log('Debug: Redirect Result returned NULL, but we expected a login. Session lost?');
                sessionStorage.removeItem('xenos_auth_pending');
             }
          }
        }).catch(function(e){
          alert('Debug: Redirect Error: ' + e.message);
          handleAuthError(e);
        }); 
      }
      async function handleLoginSuccess(user){
        // ... existing code ...
        sessionStorage.removeItem('xenos_auth_pending');
        // ...
        currentUserId=user.uid; 
        currentUserName=user.displayName||user.email||'Google User'; 
        currentUserIsGoogle=true; 
        // closeModal(); // Kept open for transition to Sync
        saveUserSession(); 
        await loadSavedLists(true); 
        
        // Check pending transfer
        if(sessionStorage.getItem('xenos_pending_transfer') === 'true'){
            sessionStorage.removeItem('xenos_pending_transfer');
            performTransfer(); // This will merge guest lists, save, and trigger sync
        } else {
            // Auto-sync on fresh login
            promptCloudSync();
            setTimeout(() => performManualSync(), 500);
        }

        loadState(true); 
        selectedListIds=[]; 
        setActiveTab('home'); 
        renderContent();
      }
      async function googleLogin(){ 
        initCloudIfAvailable(); 
        if(!firebaseAuth){ alert('Google login unavailable: Firebase not initialized'); return; } 
        const provider=new firebase.auth.GoogleAuthProvider(); 
        
        // Universal strategy: Popup first, then Redirect
        // (Popup is better for local dev/HTTP where Redirect often loses session state)
        try{ 
          const res=await firebaseAuth.signInWithPopup(provider); 
          const user=res && res.user; 
          if(!user) return; 
          handleLoginSuccess(user);
        }catch(e){ 
          console.log('Popup failed, trying redirect...', e);
          if(e.code==='auth/popup-blocked'||e.code==='auth/popup-closed-by-user'||e.code==='auth/cancelled-popup-request'||e.code==='auth/operation-not-supported-in-this-environment'){ 
            try{ 
              sessionStorage.setItem('xenos_auth_pending', '1');
              await firebaseAuth.signInWithRedirect(provider); 
            }catch(e2){ 
              handleAuthError(e2);
              sessionStorage.removeItem('xenos_auth_pending');
            } 
          } else { 
            handleAuthError(e);
          } 
        } 
      }

    // ---------- State ----------

      let activeTab = 'home';

      let selectedArmy = 'Select Army';
      let selectedAutoStyle = 'All Round';
      let styleComposition = {}; // Stores weights per role

      let selectedFormationName = 'Select a Formation';

      let armyFormations = [];

      let editContext = null;
      let dataStatus = { loaded:false, warriorUpgrades:0, loading:false, failed:false };
      let builderMeta = { name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 };
      let savedLists = [];
      let currentListId = null;
      let listsSortBy = 'createdAt';
      let listsSortDir = 'desc';
      let selectedListIds = [];
      async function loadSavedLists(migrate){ 
        const key=storageKey('saved_lists'); 
        let raw=localStorage.getItem(key); 
        if(!raw && migrate){ 
          const legacy=localStorage.getItem('xenos_saved_lists'); 
          if(legacy){ raw=legacy; localStorage.setItem(key, legacy); }
          else if(currentUserId){ 
             const guest=localStorage.getItem('xenos_default_saved_lists');
             if(guest){ raw=guest; localStorage.setItem(key, guest); }
          }
        } 
        // Cloud sync is now manual-only via "Cloud Sync" button
        savedLists = raw? JSON.parse(raw):[]; 
        savedLists = (savedLists||[]).map(x=>({ ...x, id: x.id || String(Date.now()+Math.random()), createdAt: x.createdAt || Date.now(), updatedAt: x.updatedAt || x.createdAt || Date.now() })); 
        requestRender();
      }
      async function persistSavedLists(){ 
        const key=storageKey('saved_lists'); 
        try{ localStorage.setItem(key, JSON.stringify(savedLists)); }catch(e){} 
        // Cloud sync is now manual-only
      }
      loadUser(); initCloudIfAvailable(); checkRedirectResult(); refreshAuthButton(); loadSavedLists(true);

      let referenceView = 'main';
      let referenceDetail = { army:null, unitId:null };
      let referenceWeapon = null;
      let referenceFilter = '';
      let referenceQuery = '';
      let referenceShowUpgrades = false;
      let armyRulesFaction = 'Tyranids';

      const APP_SCHEMA_VERSION = 1;
      function saveState(){ const s={ version: APP_SCHEMA_VERSION, activeTab, selectedArmy, selectedFormationName, armyFormations, builderMeta, currentListId }; localStorage.setItem(storageKey('state'), JSON.stringify(s)); autoSaveList('state-change'); }
      function migrateState(s){ const out={ version: APP_SCHEMA_VERSION, activeTab:'home', selectedArmy: s.selectedArmy||'Select Army', selectedFormationName: s.selectedFormationName||'Select a Formation', armyFormations: Array.isArray(s.armyFormations)? s.armyFormations:[], builderMeta: s.builderMeta||builderMeta, currentListId: s.currentListId||null }; return out; }
      function loadState(migrate){ const key=storageKey('state'); let raw=localStorage.getItem(key); if(!raw && migrate){ const legacy=localStorage.getItem('xenos_state'); if(legacy){ raw=legacy; localStorage.setItem(key, legacy); } }
        if(!raw) return; let s=JSON.parse(raw); if(!s.version || s.version!==APP_SCHEMA_VERSION){ const m=migrateState(s); if(!m) return; s=m; } activeTab='home'; selectedArmy=s.selectedArmy||'Select Army'; selectedFormationName=s.selectedFormationName||'Select a Formation'; armyFormations=Array.isArray(s.armyFormations)?s.armyFormations:[]; builderMeta = s.builderMeta || builderMeta; currentListId = s.currentListId || null; }



      // ---------- Armies & formations (mins updated per attached Excel) ----------

      const ARMIES = {
        "Select Army": { formations: [] },
        "Tyranids": { formations: ["Synaptic Swarm","Assault Swarm","Bio-Titan Swarm"] }
        // "Eldar": { formations: ["Craftworld Defenders Warhost","Aspect Warhost","Strike Warhost","Engines of Vaul Warhost","Wraith Warhost"] },
        // "Orks": { formations: ["Warband","Speed Freaks","Blood Axes Warband","Snakebites Warband"] }
      };

      const ARMY_STYLES = {
        "All Round": { HQ: 1, Synapse: 1, Core: 3, Support: 2, Vanguard: 1, BattleTank: 2, Artillery: 1, AirSupport: 1, Flyer: 1, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 1, Knight: 0 },
        "Skirmish": { HQ: 1, Synapse: 1, Core: 2, Support: 2, Vanguard: 3, BattleTank: 0, Artillery: 0, AirSupport: 1, Flyer: 1, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 3, Knight: 0 },
        "Hit & Run": { HQ: 1, Synapse: 1, Core: 1, Support: 2, Vanguard: 4, BattleTank: 0, Artillery: 0, AirSupport: 2, Flyer: 2, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 3, Knight: 0 },
        "Air Support": { HQ: 1, Synapse: 1, Core: 1, Support: 1, Vanguard: 0, BattleTank: 0, Artillery: 0, AirSupport: 5, Flyer: 5, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 2, Knight: 0 },
        "Super Heavy": { HQ: 1, Synapse: 1, Core: 1, Support: 0, Vanguard: 0, BattleTank: 2, Artillery: 0, AirSupport: 0, Flyer: 0, Titan: 1, Biotitan: 1, SuperHeavy: 4, HeavyArmor: 4, Transport: 0, Knight: 2 },
        "Titans": { HQ: 1, Synapse: 1, Core: 0, Support: 0, Vanguard: 0, BattleTank: 0, Artillery: 0, AirSupport: 0, Flyer: 0, Titan: 5, Biotitan: 5, SuperHeavy: 0, HeavyArmor: 0, Transport: 0, Knight: 3 },
        "Troops": { HQ: 1, Synapse: 1, Core: 5, Support: 2, Vanguard: 1, BattleTank: 1, Artillery: 1, AirSupport: 0, Flyer: 0, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 1, Knight: 0 },
        "Elite": { HQ: 2, Synapse: 2, Core: 1, Support: 1, Vanguard: 5, BattleTank: 1, Artillery: 0, AirSupport: 0, Flyer: 0, Titan: 0, Biotitan: 0, SuperHeavy: 0, HeavyArmor: 0, Transport: 1, Knight: 0 }
      };

      // TACTICAL DEFINITIONS
      const UNIT_TACTICS = {}; // Cache for unit scores
      
      function analyzeUnitTactics(unitId) {
          if(UNIT_TACTICS[unitId]) return UNIT_TACTICS[unitId];
          
          const u = UNIT_BASE[unitId];
          if(!u) return {};
          
          const scores = {
              "Hit & Run": 0,
              "Defensive Anchor": 0,
              "Fire Support": 0,
              "Assault Shock": 0
          };
          
          // Helper: Parse stat
          const getMove = () => {
              const m = String(u.movement||"0").match(/(\d+)/);
              return m ? Number(m[1]) : 0;
          };
          const getSave = () => {
              const s = String(u.save||"7+").match(/(\d+)/);
              return s ? Number(s[1]) : 7;
          };
          const getCAF = () => {
             const c = String(u.CAF||"+0").match(/([+-]?\d+)/);
             return c ? Number(c[1]) : 0;
          };
          
          const move = getMove();
          const save = getSave(); // Lower is better
          const caf = getCAF();
          const rules = (UNIT_LOADOUTS[unitId]?.specialRules || []).join(' ').toLowerCase();
          
          // 1. Hit & Run (Speed, Flyer, Transport)
          if(move >= 10) scores["Hit & Run"] += 30;
          else if(move >= 8) scores["Hit & Run"] += 15;
          if(rules.includes('flyer')) scores["Hit & Run"] += 40;
          if(rules.includes('skimmer') || rules.includes('hover')) scores["Hit & Run"] += 20;
          if(rules.includes('transport')) scores["Hit & Run"] += 25;
          if(rules.includes('infiltrate') || rules.includes('scout')) scores["Hit & Run"] += 20;
          if(rules.includes('deep strike')) scores["Hit & Run"] += 15;
          
          // 2. Defensive Anchor (Save, Wounds, Shields)
          if(save <= 3) scores["Defensive Anchor"] += 40;
          else if(save <= 4) scores["Defensive Anchor"] += 20;
          if(u.wounds >= 3) scores["Defensive Anchor"] += 30;
          if(rules.includes('invulnerable') || rules.includes('shield')) scores["Defensive Anchor"] += 25;
          if(rules.includes('regenerate')) scores["Defensive Anchor"] += 20;
          if(rules.includes('armored')) scores["Defensive Anchor"] += 15;

          // 3. Fire Support (Range? - Harder without weapon stats easily access, assume Role/Keywords)
          // We can check if unit has long range weapons in default loadout
          const weapons = UNIT_LOADOUTS[unitId]?.weapons || [];
          let maxRange = 0;
          weapons.forEach(w => {
              const lib = WEAPON_LIBRARY[w.src];
              if(lib) {
                  const r = String(lib.range||"0");
                  if(r !== '-' && r !== 'Melee') {
                      const dist = Number(r.match(/(\d+)/)?.[1] || 0);
                      if(dist > maxRange) maxRange = dist;
                  }
              }
          });
          if(maxRange >= 48) scores["Fire Support"] += 50;
          else if(maxRange >= 24) scores["Fire Support"] += 25;
          if(u.type === 'ARTILLERY') scores["Fire Support"] += 40;
          
          // 4. Assault Shock (CAF, Melee Rules)
          if(caf >= 6) scores["Assault Shock"] += 40;
          else if(caf >= 3) scores["Assault Shock"] += 20;
          if(rules.includes('furious charge')) scores["Assault Shock"] += 25;
          if(rules.includes('rampage')) scores["Assault Shock"] += 20;
          if(rules.includes('assault')) scores["Assault Shock"] += 15;
          
          UNIT_TACTICS[unitId] = scores;
          return scores;
      }

      let UNIT_DEFAULT_MODELS = { 'hive-tyrant':1, 'tyranid-warrior':3, 'termagant':6, 'hormagaunt':6, 'genestealer':6, 'harpy':1, 'mycetic-spores':1, 'carnifex':1, 'exocrine':1, 'tyrannofex':1, 'dominatrix':1 };
      let UNIT_MAX_MODELS = { 'termagant':12, 'hormagaunt':12, 'genestealer':12 };
      let UNIT_BROOD_STEP = { 'termagant':3, 'hormagaunt':3, 'genestealer':3 };
      let UNIT_BROOD_POINTS = {};

      let WEAPON_CONSTRAINTS = {
        'harpy': { disableWhenUpgrade: { 'u_harpy_swap_drool': ['Stranglethorn Cannon (Harpy)', 'Spore Launcher (Harpy)'] } }
      };
      function slugToName(s){ return String(s||'').split('_').map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(' '); }
      async function loadWeaponConstraints(){ return; }
      function masterLSKey(key){ return 'army_master_'+String(key||''); }
      function loadMasterFromLocalStorage(key){ try{ const raw=localStorage.getItem(masterLSKey(key)); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
      function saveMasterToLocalStorage(key, ref){ try{ if(!ref) return; localStorage.setItem(masterLSKey(key), JSON.stringify(ref)); }catch(e){} }
      async function loadConsolidatedArmyMaster(armyArg){ try{ const key=armyKey(armyArg||selectedArmy); try{ const old=localStorage.getItem('oraks'); if(old && !localStorage.getItem('orks')){ localStorage.setItem('orks', old); } }catch(e){} const urls=[`data/armies/${key}/master.json`,`data/${String(key).charAt(0).toUpperCase()+String(key).slice(1)}Master.json`]; let json=loadMasterFromLocalStorage(key); if(armyArg==='Tyranids') json=null; if(!json){ for(const u of urls){ try{ const r=await fetch(u,{cache:'no-store'}); if(r&&r.ok){ json=await r.json(); saveMasterToLocalStorage(key,json); break; } }catch(e){} } } if(!json) return null; const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const normUpgrade=(n)=>String(n||'').toLowerCase().replace(/\(.*?\)/g,'').replace(/^upgrade to\s+/,'').trim(); const roster=json.unit_roster||{}; Object.keys(roster).forEach(key=>{ const id=norm(key); const m=roster[key]||{}; const det=Number(m.detachment_size||1); if(det>1) UNIT_DEFAULT_MODELS[id]=det; const s=m.stats||{}; const base=UNIT_BASE[id]||{}; const uType = m.unit_type??m.role??base.type;
        const uScale = s.scale??base.scale;
        let bSize = s.base_size??base.base_size;
        const typeStr = String(uType).toUpperCase();
        if(!bSize){
           if(typeStr==='INFANTRY' || (typeStr==='WALKER' && uScale==1) || (typeStr==='VEHICLE' && uScale==2)) bSize = '25mm';
           else if(typeStr==='VEHICLE' && uScale>=3) bSize = '80mm';
        }

        UNIT_BASE[id]={ points: m.points??base.points, movement: s.move??base.movement, save: s.save??base.save, CAF: s.caf??base.CAF, morale: s.morale??base.morale, wounds: s.wounds??base.wounds, scale: uScale, type: uType, base_size: bSize, unit_note: m.unit_note??base.unit_note }; const ups=(m.upgrades||[]); UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:UNIT_BASE[id].CAF, baseWounds:UNIT_BASE[id].wounds, specialRules:(m.special_rules||[]) }; (m.weapons||[]).forEach(w=>{ const n=WEAPON_SLUG_TO_NAME[w]||slugToName(w); if(!UNIT_LOADOUTS[id].weapons.some(x=>x.src===n)) UNIT_LOADOUTS[id].weapons.push({id:'w_'+w, name:n, src:n, base:true}); }); ups.forEach((u,i)=>{ const name=u.name||u.description||''; const points=u.cost||u.points||0; const entry={ id:u.id||('u_master_'+id+'_'+i), name, points, desc:u.limit||u.description||'', type: u.type || (/swap/i.test(name)? (/(1\s*per\s*3)/i.test(name)?'WEAPON_SWAP_LIMITED':'WEAPON_SWAP') : (/Increase\s+Brood\s+size/i.test(name)?'BROOD_SIZE':'MODEL_UPGRADE')), replaces: slugToName(u.replaces||''), grants: slugToName(u.grants||''), detachmentSize: u.detachmentSize||undefined }; const normName=normUpgrade(entry.name); const hasUp=(UNIT_LOADOUTS[id].upgrades||[]).some(x=>normUpgrade(x.name)===normName); const hasPsy=(UNIT_LOADOUTS[id].psychicPowers||[]).some(x=>normUpgrade(x.name)===normName); if(!hasUp && !hasPsy) UNIT_LOADOUTS[id].upgrades.push(entry); }); }); const lib=json.weaponLibrary||json.weapons||{}; Object.entries(lib).forEach(([slug,def])=>{ const name=WEAPON_SLUG_TO_NAME[slug]||slugToName(slug); WEAPON_LIBRARY[name]=WEAPON_LIBRARY[name]||{ range:def.range||'-', dice:def.dice||'-', toHit:def.toHit||def.tohit||'-', AP:def.ap??'-', traits: Array.isArray(def.traits)?def.traits.join('; '):(def.traits||''), points: WEAPON_POINTS[name]??(def.points||0) }; }); const b=json.broodSizes||json.unitBroodSizes||{}; Object.keys(b).forEach(k=>{ const id=norm(k); const d=b[k]||{}; const init=Number(d.initial_brood_size||UNIT_DEFAULT_MODELS[id]||1); const max=Number(d.max_brood_size||init); const step=Number(d.upgrade_increment||1); const cost=Number(d.upgrade_cost_per_increment||0); UNIT_DEFAULT_MODELS[id]=init; UNIT_MAX_MODELS[id]=max; UNIT_BROOD_STEP[id]=step; UNIT_BROOD_POINTS[id]=cost; if(max>init){ UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; const exists=(UNIT_LOADOUTS[id].upgrades||[]).some(u=>u.type==='BROOD_SIZE'); if(!exists){ UNIT_LOADOUTS[id].upgrades=(UNIT_LOADOUTS[id].upgrades||[]).concat([{ id:'u_bsize_'+id, name:`Increase the Brood size by ${step}`, points: cost, type:'BROOD_SIZE', modelsDelta: step, maxModels: max }]); } } }); const cons=json.weaponConstraints||{}; Object.keys(cons).forEach(k=>{ const id=norm(k); const rules=cons[k]||[]; const entry={ mutexPairs:[], disableWhenUpgrade:{} }; rules.forEach(r=>{ const opts=(r.options||[]).map(slugToName); if(r.type && r.type.indexOf('MUTUALLY_EXCLUSIVE')>-1){ for(let i=0;i<opts.length;i++){ for(let j=i+1;j<opts.length;j++){ entry.mutexPairs.push([opts[i],opts[j]]); } } } if(r.hide_when_upgrade){ Object.entries(r.hide_when_upgrade||{}).forEach(([up,list])=>{ entry.disableWhenUpgrade[up]=(entry.disableWhenUpgrade[up]||[]).concat((list||[]).map(slugToName)); }); } }); WEAPON_CONSTRAINTS[id]=entry; }); return json; }catch(e){ return null; } }



      // Min/Max values exactly from attachment:

      // Synaptic Swarm: Compulsory Synapse max1 min1, Core max3 min3; Optional Synapse max2, Core max6; Special Biotitan or Flyer max1

      // Assault Swarm: Compulsory Synapse max1 min1, Core max3 min3, Transport max1 min0; Optional Synapse max2, Core max6, Flyer max2

      // Bio-Titan Swarm: Compulsory Biotitan max3 min3; Optional Biotitan max3

      const FORMATIONS = {
        "Synaptic Swarm": {
          compulsory:[{type:"Synapse",label:"Synapse",max:1,min:1},{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Synapse",label:"Synapse Optional",max:2,min:0},{type:"Core",label:"Core Optional",max:6,min:0}],
          special:{type:"Special",label:"Biotitan or Flyer",max:1,allowedTypes:["Biotitan","Flyer"]}
        },
        "Assault Swarm": {
          compulsory:[{type:"Synapse",label:"Synapse",max:1,min:1},{type:"Core",label:"Core",max:3,min:3},{type:"Transport",label:"Transport",max:1,min:0}],
          optional:[{type:"Synapse",label:"Synapse Optional",max:2,min:0},{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0}],
          special:null
        },
        "Bio-Titan Swarm": {
          compulsory:[{type:"Biotitan",label:"Biotitan",max:3,min:3}],
          optional:[{type:"Biotitan",label:"Biotitan Optional",max:3,min:0}],
          special:null
        },
        "Warhost": {
          compulsory:[{type:"Synapse",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0},{type:"Transport",label:"Transport Optional",max:2,min:0}],
          special:{type:"Special",label:"Super-heavy",max:1,allowedTypes:["Biotitan"]}
        },
        "Aspect Warrior Shrine": {
          compulsory:[{type:"Core",label:"Core",max:3,min:3}],
          optional:[{type:"Core",label:"Core Optional",max:6,min:0},{type:"Flyer",label:"Flyer Optional",max:2,min:0}],
          special:null
        },
        "Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"Support",label:"Support",max:1,min:1},{type:"Core",label:"Core",max:1,min:1}],
          optional:[{type:"Transport",label:"Transport",max:1,min:0},{type:"Core",label:"Core Optional",max:6,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Support",label:"Support Optional",max:1,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0},{type:"HeavyArmor",label:"Heavy Armor",max:1,min:0}],
          special:{type:"Special",label:"Titan/Knight or Air/Artillery/Bastion",max:1,allowedTypes:["Biotitan","Knight","AirSupport","Artillery","Bastion"]}
        },
        "Speed Freaks": {
          compulsory:[{type:"Flyer",label:"Flyer",max:2,min:1},{type:"Core",label:"Core",max:3,min:2}],
          optional:[{type:"Flyer",label:"Flyer Optional",max:2,min:0},{type:"Transport",label:"Transport Optional",max:2,min:0}],
          special:null
        },
        "Blood Axes Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:2,min:2}],
          optional:[{type:"Support",label:"Support",max:1,min:0},{type:"Core",label:"Core Optional",max:1,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0}],
          special:{type:"Special",label:"One of Air Support/Heavy Armor/Artillery",max:1,allowedTypes:["AirSupport","HeavyArmor","Artillery"]},
          rules:["Sneaky Now: Each mob must take a Nob if able to.","Taktiks: All units gain Outflank and must deploy using the special rule."]
        },
        "Snakebites Warband": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:1,min:1},{type:"BattleTank",label:"Battle Tank",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:1,min:1}],
          optional:[{type:"Core",label:"Core Optional",max:2,min:0},{type:"Vanguard",label:"Vanguard Optional",max:2,min:0},{type:"Support",label:"Support Optional",max:2,min:0}],
          special:{type:"Special",label:"One of Battle Tank/Core/Vanguard",max:1,allowedTypes:["BattleTank","Core","Vanguard"]},
          rules:["Primitive: May not take any detachment of size 2 or more unless it also has Clan(Snakebites).","Wierdboy Shamans: While at least 1 Wierdboy in this formation, generate +2 dice for Psychic Powers."]
        },
        "Craftworld Defenders Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Core",label:"Core",max:2,min:2},{type:"Support",label:"Support",max:1,min:1}],
          optional:[{type:"Core",label:"Core Optional",max:2,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"Vanguard",label:"Vanguard",max:1,min:0},{type:"Support",label:"Support Optional",max:1,min:0}],
          special:{type:"Special",label:"One of Artillery/Air Support",max:1,allowedTypes:["Artillery","AirSupport"]},
          rules:["Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports."]
        },
        "Aspect Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Vanguard",label:"Vanguard",max:3,min:3}],
          optional:[{type:"Vanguard",label:"Vanguard Optional",max:3,min:0},{type:"Transport",label:"Transport",max:2,min:0},{type:"BattleTank",label:"Battle Tank",max:1,min:0}],
          special:{type:"Special",label:"One of Air Support/Knight",max:1,allowedTypes:["AirSupport","Knight"]},
          rules:["Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports."]
        },
        "Strike Warhost": {
          compulsory:[{type:"BattleTank",label:"Battle Tank",max:3,min:3}],
          optional:[{type:"BattleTank",label:"Battle Tank Optional",max:3,min:0},{type:"Support",label:"Support",max:1,min:0},{type:"Core",label:"Core",max:1,min:0},{type:"Transport",label:"Transport",max:1,min:0}],
          special:{type:"Special",label:"Two of Air Support/Heavy Armor",max:1,allowedTypes:["AirSupport","HeavyArmor"]},
          rules:["Wraithgate Assault: All models must have Move >10\" or be mounted in a Transport; all detachments gain Forward Deployment.","Tank Commander: One model from a Compulsory detachment must be upgraded with Commander for +10 pts."]
        },
        "Engines of Vaul Warhost": {
          compulsory:[{type:"Biotitan",label:"Titan",max:1,min:1}],
          optional:[{type:"Biotitan",label:"Titan Optional",max:1,min:0},{type:"HeavyArmor",label:"Heavy Armor",max:2,min:0},{type:"Knight",label:"Knight",max:3,min:0}],
          special:{type:"Special",label:"One of Air Support/Artillery",max:1,allowedTypes:["AirSupport","Artillery"]}
        },
        "Wraith Warhost": {
          compulsory:[{type:"HQ",label:"HQ",max:1,min:1},{type:"Support",label:"Support",max:2,min:2}],
          optional:[{type:"Support",label:"Support Optional",max:2,min:0},{type:"Transport",label:"Transport",max:1,min:0},{type:"Core",label:"Core",max:1,min:0},{type:"Artillery",label:"Artillery",max:2,min:0}],
          special:{type:"Special",label:"One of Air Support/Heavy Armor/Knight",max:1,allowedTypes:["AirSupport","HeavyArmor","Knight"]},
          rules:["Wraith Constructs: Compulsory Core detachments must be filled with Wraithlords or Wraithguard only; HQ must be Farseer or Warlock only.","Dire Needs: All models increase Tactical Strength by 1 when contesting an Objective with Wraithguard or Wraithlord also contesting."]
        }
      };



      // ---------- Unit registry ----------

      const ARMY_UNIT_LIST = {}; const ARMY_SLOT_FILTERS = {};
      function buildArmyUnitsFromMaster(ref, armyName){ try{ const roster=ref&&ref.unit_roster||{}; const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const mapRole=(r)=>{ const s=String(r||'').toUpperCase().replace(/\s+/g,''); const lut={ SYNAPSE:'Synapse', CORE:'Core', FLYER:'Flyer', BIOTITAN:'Biotitan', TITAN:'Biotitan', SUPERHEAVY:'Biotitan', TRANSPORT:'Transport', HQ:'HQ', SUPPORT:'Support', VANGUARD:'Vanguard', BATTLETANK:'BattleTank', HEAVYARMOR:'HeavyArmor', AIRSUPPORT:'Flyer', ARTILLERY:'Artillery', BASTION:'Bastion', KNIGHT:'Knight', INFANTRY:'Core' }; return lut[s]||'Core'; }; const synapseKeys=new Set(['hive_tyrant','tyranid_warrior_brood']); const list=[]; Object.keys(roster).forEach(key=>{ const m=roster[key]||{}; let type = mapRole(m.role); if(synapseKeys.has(key)){ type = 'Synapse'; } list.push({ id: norm(key), name: m.name||slugToName(key), slotType: type }); }); const key=armyKey(armyName||selectedArmy); ARMY_UNIT_LIST[key]=list; const filt={ Synapse: list.filter(u=>u.slotType==='Synapse').map(u=>u.id), Core: list.filter(u=>u.slotType==='Core').map(u=>u.id), Flyer: list.filter(u=>u.slotType==='Flyer').map(u=>u.id), Biotitan: list.filter(u=>u.slotType==='Biotitan').map(u=>u.id), Transport: list.filter(u=>u.slotType==='Transport').map(u=>u.id), HQ: list.filter(u=>u.slotType==='HQ').map(u=>u.id), Support: list.filter(u=>u.slotType==='Support').map(u=>u.id), Vanguard: list.filter(u=>u.slotType==='Vanguard').map(u=>u.id), BattleTank: list.filter(u=>u.slotType==='BattleTank').map(u=>u.id), HeavyArmor: list.filter(u=>u.slotType==='HeavyArmor').map(u=>u.id), AirSupport: list.filter(u=>u.slotType==='AirSupport').map(u=>u.id), Artillery: list.filter(u=>u.slotType==='Artillery').map(u=>u.id), Bastion: list.filter(u=>u.slotType==='Bastion').map(u=>u.id), Knight: list.filter(u=>u.slotType==='Knight').map(u=>u.id) }; ARMY_SLOT_FILTERS[key]=filt; }catch(e){} }

      function updateFormationsFromMaster(json){ try{ const forms = json.formations || {}; Object.values(forms).forEach(fd => { if(fd.name && FORMATIONS[fd.name]){ FORMATIONS[fd.name].rules = fd.rules || []; } }); }catch(e){} }

      async function ensureArmyMaster(armyName){ const key=armyKey(armyName); if((ARMY_UNIT_LIST[key]||[]).length) return; const ref=await loadConsolidatedArmyMaster(armyName); if(ref){ buildArmyUnitsFromMaster(ref, armyName); updateFormationsFromMaster(ref); } }
      async function preloadAllArmyMasters(){ const list=Object.keys(ARMIES).filter(a=>a!=='Select Army'); await Promise.all(list.map(a=>ensureArmyMaster(a))); }



      /* SLOT_FILTERS handled dynamically via ARMY_SLOT_FILTERS */



      // ---------- Minimal stats/loadouts (unchanged) ----------
      const UNIT_BASE = {

        'hive-tyrant':{points:100,movement:'5"',save:'4+',CAF:'+10',morale:'2+',wounds:2},
        'exocrine':{points:100,movement:'5"',save:'3+',CAF:'+4',morale:'3+',wounds:2,scale:4,type:'VEHICLE',base_size:'80mm'},
        'tyrannofex':{points:90,movement:'5"',save:'3+',CAF:'+5',morale:'3+',wounds:2,scale:3,type:'VEHICLE',base_size:'80mm'},

        'malefactor':{
          baseCAF:'+7', baseWounds:2,
          weapons:[
            {id:'w_maul',name:'Mauling Limbs',src:'Mauling Limbs',base:true},
            {id:'w_frag',name:'Frag Spines',src:'Frag Spines',base:true},
            {id:'w_cysts_m',name:'Spore Cysts',src:'Spore Cysts (Malefactor)',base:true}
          ],
          upgrades:[
            {id:'u_bsize_malefactor',name:'Increase Brood size by 1',points:100,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}
          ],
          specialRules:['Instinct: Rampage','Armored','Large Assault Transport (8)']
        },
        'harridan':{points:110,movement:'16"',save:'4+',CAF:'+4',morale:'3+',wounds:2},
        'tyranid-warrior':{points:60,movement:'5"',save:'5+',CAF:'+5',morale:'3+',wounds:1},

        'hormagaunt':{points:0,movement:'6"',save:'-',CAF:'+0',morale:'4+',wounds:1},
        'genestealer':{points:40,movement:'6"',save:'6+',CAF:'+6',morale:'3+',wounds:1},

        'termagant':{points:30,movement:'5"',save:'-',CAF:'+0',morale:'4+',wounds:1},

        'carnifex':{points:150,movement:'6"',save:'3+',CAF:'+0',morale:'3+',wounds:3},
        'mycetic-spores':{points:20,movement:'-',save:'-',CAF:'+0',morale:'-',wounds:0},
        'ravener':{points:35,movement:'8"',save:'4+',CAF:'+5',morale:'4+',wounds:1},
        'malanthrope':{points:25,movement:'5"',save:'5+',CAF:'+1',morale:'3+',wounds:1},
        'lictor':{points:40,movement:'8"',save:'6+',CAF:'+5',morale:'3+',wounds:1},
        'zoanthrope':{points:65,movement:'5"',save:'6+',CAF:'0',morale:'3+',wounds:1},
        'biovore':{points:45,movement:'5"',save:'6+',CAF:'+1',morale:'4+',wounds:1},
        'gargoyle':{points:35,movement:'12"',save:'6+',CAF:'+1',morale:'4+',wounds:1},
        'venomthrope':{points:65,movement:'6"',save:'4+',CAF:'+5',morale:'4+',wounds:1},
        'haruspex':{points:100,movement:'6"',save:'3+',CAF:'+8',morale:'3+',wounds:2},
        'tervigon':{points:100,movement:'5"',save:'3+',CAF:'+3',morale:'3+',wounds:2},
        'toxicrene':{points:120,movement:'6"',save:'4+',CAF:'+8',morale:'3+',wounds:2},
        'harpy':{points:120,movement:'18"',save:'5+',CAF:'+2',morale:'4+',wounds:1,type:'VEHICLE',scale:2},
        'trygon':{points:120,movement:'10"',save:'3+',CAF:'+8',morale:'2+',wounds:3,scale:4,type:'VEHICLE',base_size:'80mm'},
        'hierodule':{points:150,movement:'8"',save:'3+',CAF:'+10',morale:'2+',wounds:3,scale:4,type:'VEHICLE',base_size:'80mm'}
      };



      const WEAPON_LIBRARY = {
        "Venom Cannon":{range:'14"',dice:2,toHit:'5+',AP:-2,traits:'Anti-Tank',points:15},
        "Barbed Strangler":{range:'10"',dice:1,toHit:'4+',AP:0,traits:'Light AT; Blast (3")',points:5},
        "Lash Whip & Bone Sword":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend; Parry',points:0},
        "Fleshborer":{range:'6"',dice:1,toHit:'5+',AP:0,traits:'',points:0},
        "Rending Claws":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Death Spitter":{range:'24"',dice:2,toHit:'5+',AP:0,traits:'',points:5},
        "Scything Talons":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Bone Swords":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Pyroacid Launcher":{range:'15"',dice:2,toHit:'4+',AP:-2,traits:'Light AT; Ignore Cover',points:0},
        "Spore Launcher":{range:'20"',dice:1,toHit:'5+',AP:-1,traits:'Blast (3"); Spore Launcher',points:0},
        "Stranglewebs":{range:'6"',dice:1,toHit:'5+',AP:0,traits:'Web; Pinning',points:3},
        "Devourer":{range:'8"',dice:2,toHit:'5+',AP:0,traits:'',points:1},
        "Bio-Plasma":{range:'8"',dice:1,toHit:'4+',AP:-1,traits:'Light AT',points:5},
        "Bio-Plasmic Cannon":{range:'22"',dice:4,toHit:'4+',AP:-3,traits:'Anti-Tank; Blast (3")',points:0},
        "Bio Cannon":{range:'22"',dice:6,toHit:'5+',AP:-3,traits:'Anti-Tank',points:0},
        "Warp Pulse":{range:'20"',dice:'-',toHit:'Auto',AP:-4,traits:'Beam; Armorbane',points:0},
        "Spore Cysts":{range:'6"',dice:12,toHit:'6+',AP:0,traits:'Light',points:0},
        "Rupture Cannon":{range:'12"',dice:2,toHit:'5+',AP:-2,traits:'Arc (Front); Anti-Tank',points:0},
        "Fleshborer Hive":{range:'6"',dice:6,toHit:'5+',AP:0,traits:'Arc (Front); Light',points:0},
        "Acid Spray":{range:'T',dice:1,toHit:'5+',AP:-1,traits:'Arc (Front); Light AT',points:0},
        "Stranglethorn Cannon":{range:'22"',dice:4,toHit:'4+',AP:0,traits:'Light AT; Blast (5")',points:0},
        "Drool Cannon":{range:'8"',dice:3,toHit:'4+',AP:-1,traits:'Template; Ignore Cover',points:0},
        "Flesh Hooks":{range:'6"',dice:1,toHit:'4+',AP:0,traits:'Light; Ignore Cover; Attract (1)',points:0},
        "Thoracic Spinefist":{range:'6"',dice:1,toHit:'5+',AP:0,traits:'Light',points:0},
        "Flensing Whips":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Rend',points:0},
        "Stunning Tendrils":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Hunger; Parry',points:0},
        "Warp Blast (Focused)":{range:'24"',dice:1,toHit:'4+',AP:-3,traits:'Anti-Tank',points:0},
        "Warp Blast (Diffused)":{range:'18"',dice:1,toHit:'4+',AP:-1,traits:'Blast (3")',points:0},
        "Flamespurt":{range:'Template',dice:1,toHit:'Auto',AP:-1,traits:'Ignore Cover',points:1},
        "Toxic Lashes":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'Parry',points:0},
        "Ravenous maw":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'Hunger; Wrecker; Armorbane',points:0},
        "Grasping Tongue":{range:'6"',dice:1,toHit:'4+',AP:-1,traits:'Anti-Tank; Attract; Arc(Forward)',points:0},
        "Toxic Fumes":{range:'3"',dice:6,toHit:'3+',AP:0,traits:'Point Defense; Light',points:0},
        "Stranglethorn Cannon (Harpy)":{range:'12"',dice:1,toHit:'5+',AP:-2,traits:'Arc (Front); Light AT; Skyfire',points:0},
        "Spore Launcher (Harpy)":{range:'-',dice:1,toHit:'Special',AP:'-',traits:'Arc (Rear); Spore Launcher; Bombing Run',points:0},
        "Drool Cannon (Harpy)":{range:'T',dice:'-',toHit:'4+',AP:-1,traits:'Arc (Front); Anti-Tank',points:0},
        "Bio-Cannon (Harridan)":{range:'10"',dice:4,toHit:'5+',AP:-3,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Spore Launcher (Harridan)":{range:'-',dice:1,toHit:'Special',AP:'-',traits:'Spore Launcher; Bombing Run',points:0},
        "Horrible Claws":{range:'Melee',dice:'-',toHit:'-',AP:'-',traits:'-',points:0},
        "Mauling Limbs":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'Wrecker (1)',points:0},
        "Frag Spines":{range:'8"',dice:1,toHit:'5+',AP:0,traits:'Blast (3")',points:0},
        "Spore Cysts (Malefactor)":{range:'3"',dice:2,toHit:'2+',AP:0,traits:'Light; Point Defense; Ignores Cover',points:0},
        "Bio-Plasmic Cannon":{range:'18"',dice:1,toHit:'5+',AP:-2,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Spore Cysts (Exocrine)":{range:'3"',dice:2,toHit:'2+',AP:0,traits:'Light; Point Defense; Ignores Cover',points:0},
        "Bio-Shock":{range:'D6x3"',dice:6,toHit:'3+',AP:-1,traits:'Arc (Front); Blast (3")',points:0},
        "Razor Claws":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'Rend; Wrecker (2)',points:0},
        "Toxin Spike":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'-',points:0},
        "Razor Claws (Hierodule)":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'Arc (Front); Rend; Wrecker (2)',points:0},
        "Bio-Cannon (Hierodule)":{range:'10"',dice:4,toHit:'5+',AP:-3,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Pyro-Acid Spray":{range:'T',dice:'-',toHit:'4+',AP:-2,traits:'Arc (Front); Light AT; Shieldbane; Skyfire',points:0},
        "Ripper Tentacles":{range:'4"',dice:6,toHit:'2+',AP:0,traits:'Arc (Front); Skyfire; Attract; Engine Killer (2)',points:0},
        "Spore Pods":{range:'8"',dice:2,toHit:'2+',AP:0,traits:'Light; Point Defense; Ignores Cover',points:0},
        "Stinger Salvo":{range:'6"',dice:3,toHit:'5+',AP:-1,traits:'Light AT; Point Defense; SkyFire',points:0},
        "Razor Claws (Hierophant)":{range:'-',dice:'-',toHit:'-',AP:'-',traits:'Arc (Front); Rend; Wrecker (2)',points:0},
        "Bio-Cannon (Hierophant)":{range:'10"',dice:4,toHit:'5+',AP:-3,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Bio-Cannon (1)":{range:'10"',dice:4,toHit:'5+',AP:-3,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Bio-Cannon (2)":{range:'10"',dice:4,toHit:'5+',AP:-3,traits:'Arc (Front); Anti-Tank; Engine Killer (1)',points:0},
        "Bile Launcher":{range:'8"-50"',dice:5,toHit:'4+',AP:-1,traits:'Arc (Front); Heavy Barrage',points:0}
      };
      const WEAPON_POINTS = { 'Venom Cannon':15, 'Barbed Strangler':5, 'Lash Whip & Bone Sword':0, 'Fleshborer':0, 'Flamespurt':1, 'Death Spitter':5, 'Rending Claws':0, 'Devourer':1, 'Stranglewebs':3, 'Bone Swords':0, 'Pyroacid Launcher':0, 'Spore Launcher':0, 'Thoracic Spinefist':0, 'Stunning Tendrils':0, 'Warp Blast (Focused)':0, 'Warp Blast (Diffused)':0, 'Toxic Lashes':0, 'Ravenous maw':0, 'Grasping Tongue':0, 'Toxic Fumes':0, 'Stranglethorn Cannon (Harpy)':0, 'Spore Launcher (Harpy)':0, 'Drool Cannon (Harpy)':0, 'Bio-Cannon (Harridan)':0, 'Spore Launcher (Harridan)':0, 'Mauling Limbs':0, 'Frag Spines':0, 'Spore Cysts (Malefactor)':0, 'Bio-Plasmic Cannon':0, 'Spore Cysts (Exocrine)':0, 'Bio-Shock':0, 'Razor Claws':0, 'Toxin Spike':0, 'Razor Claws (Hierodule)':0, 'Bio-Cannon (Hierodule)':0, 'Pyro-Acid Spray':0, 'Ripper Tentacles':0, 'Spore Pods':0, 'Stinger Salvo':0, 'Razor Claws (Hierophant)':0, 'Bio-Cannon (Hierophant)':0, 'Bio-Cannon (1)':0, 'Bio-Cannon (2)':0, 'Bile Launcher':0 };



      const UNIT_LOADOUTS = {

        'hive-tyrant':{

          baseCAF:'+10', baseWounds:2,

          weapons:[

            {id:'w_lashbone',name:'Lash Whip & Bone Sword',src:'Lash Whip & Bone Sword',base:true},

            {id:'w_venom',name:'Venom Cannon',src:'Venom Cannon',base:false},

            {id:'w_barbed',name:'Barbed Strangler',src:'Barbed Strangler',base:false}

          ],

          upgrades:[

            {id:'u_wings',name:'Add Wings',points:20,desc:'Movement profile 10"; Winged'},

            {id:'u_swarm',name:'Upgrade to Swarm Lord',points:25,desc:'CAF becomes +14; Wounds = 3; removes Venom/Barbed'}

          ],

          psychicPowers:[

            {id:'p_horror',name:'The Horror',points:15,desc:'Psychic power that induces fear'},{id:'p_catalyst',name:'Catalyst',points:15,desc:'Grants Feel No Pain to nearby brood'}

          ],

          specialRules:[

            "Commander",

            "Invulnerable Save (5+)",

            "Synapse (12)",

            "Psychic Scream"

          ]
        },

        'exocrine':{
          baseCAF:'+4', baseWounds:2,
          weapons:[
            {id:'w_bio_plasmic',name:'Bio-Plasmic Cannon',src:'Bio-Plasmic Cannon',base:true},
            {id:'w_cysts_exo',name:'Spore Cysts',src:'Spore Cysts (Exocrine)',base:true}
          ],
          upgrades:[
            {id:'u_bsize_exocrine',name:'Increase Brood size by 1',points:90,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}
          ],
          specialRules:['Instinct: Nest','Armored']
        },
        'tyrannofex':{
          baseCAF:'+5', baseWounds:2,
          weapons:[
            {id:'w_rupture',name:'Rupture Cannon',src:'Rupture Cannon',base:true}
          ],
          upgrades:[
            {id:'u_bsize_tyrannofex',name:'Increase Brood size by 1',points:80,type:'BROOD_SIZE',modelsDelta:1,maxModels:3},
            {id:'u_tfex_swap_flesh',name:'Swap Rupture Cannon for Fleshborer Hive',points:0,type:'WEAPON_SWAP',replaces:'Rupture Cannon',grants:'Fleshborer Hive'},
            {id:'u_tfex_swap_acid',name:'Swap Rupture Cannon for Acid Spray',points:0,type:'WEAPON_SWAP',replaces:'Rupture Cannon',grants:'Acid Spray'}
          ],
          specialRules:['Instinct: Hunt','Armored']
        },

        'tyranid-warrior':{
          baseCAF:'+5', baseWounds:1,
          weapons:[
            {id:'w_default',name:'Death Spitter',src:'Death Spitter',base:true},
            {id:'w_st',name:'Scything Talons',src:'Scything Talons',base:true}
          ],
          upgrades:[
            {id:'u_war_boneswords',name:'Replace Scything Talons with Bone Swords',points:3,type:'WEAPON_SWAP',replaces:'Scything Talons',grants:'Bone Swords',limit:'Per model'},
            {id:'u_war_barbed',name:'Replace Death Spitter with Barbed Strangler',points:15,type:'WEAPON_SWAP_LIMITED',replaces:'Death Spitter',grants:'Barbed Strangler',detachmentSize:3,limit:'1 per 3 models'},
            {id:'u_war_venom',name:'Replace Death Spitter with Venom Cannon',points:15,type:'WEAPON_SWAP_LIMITED',replaces:'Death Spitter',grants:'Venom Cannon',detachmentSize:3,limit:'1 per 3 models'}
          ],
          psychicPowers:[], specialRules:["Bulky","Synapse (6)","Implacable"]
        },

        'termagant':{
          
          baseCAF:'+0', baseWounds:1,
          
          weapons:[{id:'w_flesh',name:'Fleshborer',src:'Fleshborer',base:true}],
          
          upgrades:[], psychicPowers:[], specialRules:["Instinct: Hunt"]
          
        },
        'gargoyle':{
           baseCAF:'+1', baseWounds:1,
           weapons:[{id:'w_flesh',name:'Fleshborer',src:'Fleshborer',base:true}],
           upgrades:[],
           psychicPowers:[], specialRules:['Jink (6+)','Skimmer']
         },
        
        'genestealer':{
          baseCAF:'+6', baseWounds:1,
          weapons:[{id:'w_rend',name:'Rending Claws',src:'Rending Claws',base:true}],
          upgrades:[{id:'u_broodlord',name:'Broodlord (Model Upgrade)',points:20,type:'MODEL_UPGRADE',desc:'Same statline as Genestealer except: CAF +7; Special rules Synapse (6) and The Horror for that model only.'}],
          psychicPowers:[], specialRules:['Forward Deployment']
        },
        
        'carnifex':{
          baseCAF:'+7', baseWounds:2,
          weapons:[
            {id:'w_bioplasma',name:'Bio-Plasma',src:'Bio-Plasma',base:true},
            {id:'w_st',name:'Scything Talons',src:'Scything Talons',base:true}
          ],
          upgrades:[], psychicPowers:[], specialRules:['Instinct: Rampage','Armored','Bulky','Implacable','Regenerate']
        },
        'hormagaunt':{ baseCAF:'+0', baseWounds:1, weapons:[{id:'w_horm',name:'Scything Talons',src:'Scything Talons',base:true}], upgrades:[], psychicPowers:[], specialRules:['Instinct: Rampage'] },

        'harpy':{
          baseCAF:'+2', baseWounds:1,
          weapons:[
            {id:'w_stc',name:'Stranglethorn Cannon',src:'Stranglethorn Cannon (Harpy)',base:true},
            {id:'w_spore',name:'Spore Launcher',src:'Spore Launcher (Harpy)',base:true}
          ],
          upgrades:[
            {id:'u_harpy_swap_drool',name:'Swap Stranglethorn Cannon & Spore Launcher for Drool Cannon',points:0,type:'WEAPON_SWAP',replaces:'Stranglethorn Cannon',grants:'Drool Cannon (Harpy)'},
            {id:'u_bsize_harpy',name:'Increase Brood size by 1',points:120,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}
          ],
          psychicPowers:[], specialRules:['Flyer','Winged','Hover','Interceptor','Jink (5+)']
        },
        'harridan':{
          baseCAF:'+4', baseWounds:2,
          weapons:[
            {id:'w_bio_harridan_1',name:'Bio-Cannon',src:'Bio-Cannon (Harridan)',base:true},
            {id:'w_spore_harridan',name:'Spore Launcher',src:'Spore Launcher (Harridan)',base:true},
            {id:'w_horrible_claws',name:'Horrible Claws',src:'Horrible Claws',base:true}
          ],
          upgrades:[], psychicPowers:[], specialRules:['Flyer','Winged','Hover','Jink (5+)','Spawn (Gargoyle, 4)','Synapse (12")']
        },
        'malefactor':{
          baseCAF:'+7', baseWounds:2,
          weapons:[
            {id:'w_maul',name:'Mauling Limbs',src:'Mauling Limbs',base:true},
            {id:'w_frag',name:'Frag Spines',src:'Frag Spines',base:true},
            {id:'w_cysts_m',name:'Spore Cysts',src:'Spore Cysts (Malefactor)',base:true}
          ],
          upgrades:[
            {id:'u_bsize_malefactor',name:'Increase Brood size by 1',points:100,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}
          ],
          specialRules:['Instinct: Rampage','Armored','Large Assault Transport (8)']
        },
        'biovore':{
          baseCAF:'+0', baseWounds:1,
          weapons:[
            {id:'w_bio_spore',name:'Spore Launcher',src:'Spore Launcher',base:true}
          ],
          upgrades:[], psychicPowers:[], specialRules:['Instinct: Nest','Bulky']
        },
        'mycetic-spores':{
          baseCAF:'+1', baseWounds:1,
          weapons:[{id:'w_flensing',name:'Flensing Whips',src:'Flensing Whips',base:true}],
          upgrades:[{id:'u_bsize_mycetic-spores',name:'Increase the Brood size by 1',points:15,type:'BROOD_SIZE',modelsDelta:1,maxModels:3}],
          psychicPowers:[], specialRules:['Deep Strike','Large Assault Transport (8)','Drop Pod']
        },
        'dominatrix':{
          baseCAF:'+12', baseWounds:4,
          weapons:[{id:'w_bio_can',name:'Bio Cannon',src:'Bio Cannon',base:true},{id:'w_warp',name:'Warp Pulse',src:'Warp Pulse',base:true},{id:'w_scysts_dom',name:'Spore Cysts',src:'Spore Cysts',base:true}],
          upgrades:[], psychicPowers:[], specialRules:['Invulnerable Save (2+)','Synapse (24)','Psychic Scream','Catalyst','Regenerate','The Horror']
        },
        'toxicrene':{
          baseCAF:'+8', baseWounds:2,
          weapons:[{id:'w_toxic_lashes',name:'Toxic Lashes',src:'Toxic Lashes',base:true},{id:'w_toxic_fumes',name:'Toxic Fumes',src:'Toxic Fumes',base:true}],
          upgrades:[{id:'u_bsize_toxicrene',name:'Increase Brood size by 2',points:80,type:'BROOD_SIZE',modelsDelta:2,maxModels:7}],
          psychicPowers:[], specialRules:['Instinct: Rampage','Miasma']
        },
        'trygon':{
          baseCAF:'+8', baseWounds:3,
          weapons:[
            {id:'w_bioshock',name:'Bio-Shock',src:'Bio-Shock',base:true},
            {id:'w_razor',name:'Razor Claws',src:'Razor Claws',base:true},
            {id:'w_toxin',name:'Toxin Spike',src:'Toxin Spike',base:true}
          ],
          upgrades:[
            {id:'u_bsize_trygon',name:'Increase Brood size by 1',points:110,type:'BROOD_SIZE',modelsDelta:1,maxModels:3},
            {id:'u_prime_trygon',name:'Upgrade to Trygon Prime',points:60,type:'MODEL_UPGRADE',limit:1,desc:'Adds special rule Synapse (6)'}
          ],
          specialRules:['Instinct: Rampage','Deep Strike','Burrow','Nimble']
        },
        'hierodule':{
          baseCAF:'+10', baseWounds:3,
          weapons:[
            {id:'w_stinger',name:'Stinger Salvo',src:'Stinger Salvo',base:true}
          ],
          upgrades:[
            {id:'u_bsize_hierodule',name:'Increase Brood size by 1',points:150,type:'BROOD_SIZE',modelsDelta:1,maxModels:3},
            {id:'u_hierodule_scythed',name:'Scythed Variant (Razor Claws & Spore Pods)',points:0,type:'WEAPON_SWAP',grants:'Razor Claws (Hierodule), Spore Pods'},
            {id:'u_hierodule_barbed',name:'Barbed Variant (Bio-Cannon)',points:0,type:'WEAPON_SWAP',grants:'Bio-Cannon (Hierodule)'},
            {id:'u_hierodule_hive',name:'Hive Variant (Ripper Tentacles & Pyro-Acid Spray)',points:0,type:'WEAPON_SWAP',grants:'Ripper Tentacles, Pyro-Acid Spray'}
          ],
          specialRules:['Instinct: Rampage','Armored']
        }

      };



      const WEAPON_SLUG_TO_NAME = { death_spitter:'Death Spitter', barbed_strangler:'Barbed Strangler', venom_cannon:'Venom Cannon', scything_talons:'Scything Talons', bone_swords:'Bone Swords', spore_launcher:'Spore Launcher', pyroacid_launcher:'Pyroacid Launcher', stranglewebs:'Stranglewebs', devourer:'Devourer', bio_plasma:'Bio-Plasma', bio_plasmic_cannon:'Bio-Plasmic Cannon', bio_cannon_dominatrix:'Bio Cannon', warp_pulse:'Warp Pulse', spore_cysts_dominatrix:'Spore Cysts', stranglethorn_cannon:'Stranglethorn Cannon', drool_cannon:'Drool Cannon', flesh_hooks:'Flesh Hooks', flensing_whips:'Flensing Whips', thoracic_spinefist:'Thoracic Spinefist', stunning_tendrils:'Stunning Tendrils', warp_blast_focused:'Warp Blast (Focused)', warp_blast_diffused:'Warp Blast (Diffused)', flamespurt:'Flamespurt', toxic_lashes:'Toxic Lashes', ravenous_maw:'Ravenous maw', grasping_tongue:'Grasping Tongue', stranglethorn_cannon_harpy:'Stranglethorn Cannon (Harpy)', spore_launcher_harpy:'Spore Launcher (Harpy)', drool_cannon_harpy:'Drool Cannon (Harpy)', bio_cannon_harridan:'Bio-Cannon (Harridan)', spore_launcher_harridan:'Spore Launcher (Harridan)', spore_cysts_malefactor:'Spore Cysts (Malefactor)', mauling_limbs:'Mauling Limbs', frag_spines:'Frag Spines', spore_cysts_exocrine:'Spore Cysts (Exocrine)', rupture_cannon:'Rupture Cannon', fleshborer_hive:'Fleshborer Hive', acid_spray:'Acid Spray', bio_shock:'Bio-Shock', razor_claws:'Razor Claws', toxin_spike:'Toxin Spike', stinger_salvo:'Stinger Salvo', razor_claws_hierodule:'Razor Claws (Hierodule)', spore_pods:'Spore Pods', bio_cannon_hierodule:'Bio-Cannon (Hierodule)', ripper_tentacles:'Ripper Tentacles', pyro_acid_spray:'Pyro-Acid Spray', razor_claws_hierophant:'Razor Claws (Hierophant)', bio_cannon_hierophant:'Bio-Cannon (Hierophant)', bile_launcher:'Bile Launcher', bio_cannon_hierophant_1:'Bio-Cannon (1)', bio_cannon_hierophant_2:'Bio-Cannon (2)' };

      async function loadWeaponsData(){ return; }

      // ---------- Helpers ----------
      function armyKey(name){ const n=String(name||'').toLowerCase(); if(n.includes('tyranid')) return 'tyranids'; if(n.includes('eldar')) return 'eldar'; if(n.includes('ork')) return 'orks'; return 'tyranids'; }
      function clearPDFCache(){ try{ const keys=[]; for(let i=0;i<localStorage.length;i++){ const k=localStorage.key(i); if(k && k.startsWith('pdf_cache_')) keys.push(k); } keys.forEach(k=>localStorage.removeItem(k)); alert('PDF cache cleared'); }catch(e){} }
      function exportCurrentArmyMaster(){ return; }
      function importArmyMaster(){ return; }
      async function linkArmyMasterFile(){ return; }
      async function saveMasterNow(){ return; }

      async function loadMasterRef(){ return null; }
      function formatDateTime(ts){ if(!ts) return '-'; const d=new Date(ts); if(!d || !d.getTime) return '-'; const t=d.getTime(); if(!(t>0)) return '-'; try{ return d.toLocaleString(); }catch(e){ return String(d); } }
      function applyMasterBroodDefaults(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const det=Number(data.detachment_size||1); if(det>1){ UNIT_DEFAULT_MODELS[appId]=det; const ups=data.upgrades||[]; let step=UNIT_BROOD_STEP[appId]||0; let max=UNIT_MAX_MODELS[appId]||det; let cost=UNIT_BROOD_POINTS[appId]||0; ups.forEach(u=>{ const name=u.name||u.description||''; const mStep=(name.match(/Increase\s+Brood\s+size\s+by\s+(\d+)/i)||[])[1]; const mMax=(name.match(/Max\s+(\d+)/i)||[])[1]; if(mStep){ const n=Number(mStep); step = step>0 ? Math.min(step,n) : n; } if(mMax){ max=Number(mMax); } if(/Increase\s+Brood\s+size/i.test(name) && u.cost!=null){ cost=Number(u.cost); } }); if(appId==='termagant'){ step=3; } UNIT_BROOD_STEP[appId]=step; UNIT_MAX_MODELS[appId]=max; UNIT_BROOD_POINTS[appId]=cost; UNIT_LOADOUTS[appId] = UNIT_LOADOUTS[appId] || { weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; const hasB=(UNIT_LOADOUTS[appId].upgrades||[]).some(u=>u.type==='BROOD_SIZE'); if(!hasB && max>det){ UNIT_LOADOUTS[appId].upgrades=(UNIT_LOADOUTS[appId].upgrades||[]).concat([{ id:'u_bsize_'+appId, name:`Increase the Brood size by ${step}`, points: cost, type:'BROOD_SIZE', modelsDelta: step, maxModels: max }]); } else if (hasB) { (UNIT_LOADOUTS[appId].upgrades||[]).forEach(u => { if (u.type === 'BROOD_SIZE' && !u.modelsDelta) { const mStep = (u.name.match(/Increase\s+Brood\s+size\s+by\s+(\d+)/i) || [])[1]; if (mStep) u.modelsDelta = Number(mStep); const mMax = (u.name.match(/Max\s+(\d+)/i) || [])[1]; if (mMax) u.maxModels = Number(mMax); } }); } } }); }catch(e){} }
      function applyUpgradeConstraintsFromMaster(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const ups=(data.upgrades||[]); const load=(UNIT_LOADOUTS[appId]||{}); const libWeps=(load.weapons||[]); const rangedNames=libWeps.filter(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; const r=String(s.range||''); return !(r==='Melee' || r==='-' ); }).map(w=>w.name);
        const findUpId=(substr)=>{ const u=(load.upgrades||[]).find(x=> (x.name||'').toLowerCase().includes(substr.toLowerCase())); return u && u.id; };
        ups.forEach(u=>{ const text=String(u.name||'').toLowerCase(); if(text.includes('swarm lord') && text.includes('no ranged')){ const upId=findUpId('swarm'); if(upId && rangedNames.length){ WEAPON_CONSTRAINTS[appId] = WEAPON_CONSTRAINTS[appId] || { mutexPairs:[], disableWhenUpgrade:{} }; WEAPON_CONSTRAINTS[appId].disableWhenUpgrade[upId] = rangedNames.slice(); } } }); });
        WEAPON_CONSTRAINTS['hive-tyrant'] = WEAPON_CONSTRAINTS['hive-tyrant'] || { mutexPairs:[], disableWhenUpgrade:{} };
        const ht = WEAPON_CONSTRAINTS['hive-tyrant'];
        const pair = ['Venom Cannon','Barbed Strangler'];
        const hasPair = (ht.mutexPairs||[]).some(([a,b])=> (a===pair[0] && b===pair[1]) || (a===pair[1] && b===pair[0]));
        if(!hasPair){ ht.mutexPairs.push(pair); }
      }catch(e){} }
      function countCoreUpgradeTotal(fIdx, excludeSection, excludeIndex, namePattern){ try{ const f=armyFormations[fIdx]; if(!f) return 0; const re=new RegExp(namePattern,'i'); let total=0; [['compulsory','Core'],['optional','Core']].forEach(([sec,type])=>{ const arr=f[sec]||[]; arr.forEach((slot,si)=>{ if(slot.type!==type) return; if(sec===excludeSection && si===excludeIndex) return; const u=(slot.units||[])[0]; if(!u) return; (u.upgrades||[]).forEach(up=>{ if(re.test(up.name||'')) total += Number(up.count||1); }); }); }); return total; }catch(e){ return 0; } }
      function runValidation(ref){ const issues=[]; window._latestValidationIssues = issues; const unitsMap={ 'hive-tyrant':'hive_tyrant','tyranid-warrior':'tyranid_warrior_brood','termagant':'termagant_brood','hormagaunt':'hormagaunt_brood','genestealer':'genestealer_brood','carnifex':'carnifex_brood','exocrine':'exocrine_brood','harpy':'harpy_brood','harridan':'harridan_brood','mycetic-spores':'mycetic_spores','dominatrix':'dominatrix' }; const roster=ref.unit_roster||{}; Object.entries(unitsMap).forEach(([appId,refKey])=>{ const m=roster[refKey]; if(!m) return; const base=UNIT_BASE[appId]||{}; if(m.points!=null && base.points!=null && Number(base.points)!==Number(m.points)){ issues.push(appId+': points '+base.points+'  '+m.points); } const det = Number(m.detachment_size||0); const def = Number(UNIT_DEFAULT_MODELS[appId]||0); if(det && def && det!==def){ issues.push(appId+': detachment/default size '+def+'  '+det); } const s=m.stats||{}; const norm=(v)=>String(v||'').trim(); const cmp=(kApp,kRef,label)=>{ const a=norm(base[kApp]); const b=norm(s[kRef]); if(a&&b&&a!==b) issues.push(appId+': '+label+' '+a+'  '+b); }; cmp('movement','move','move'); cmp('save','save','save'); cmp('CAF','caf','CAF'); cmp('morale','morale','morale'); cmp('wounds','wounds','wounds'); });  const wRef = { 'Barbed Strangler':{range:'10"'}, 'Venom Cannon':{range:'14"'}, 'Fleshborer':{range:'6"'}, 'Devourer':{range:'8"'}, 'Stranglewebs':{range:'6"'} }; Object.entries(wRef).forEach(([name,expect])=>{ const cur=WEAPON_LIBRARY[name]||{}; if(!cur.range) issues.push('Weapon '+name+' missing in library'); else if(expect.range && String(cur.range) !== String(expect.range)) issues.push('Weapon '+name+' range '+cur.range+'  '+expect.range); }); const warriorUps=(UNIT_LOADOUTS['tyranid-warrior']&&UNIT_LOADOUTS['tyranid-warrior'].upgrades)||[]; const findUp=(n)=>warriorUps.find(u=>(u.name||'').toLowerCase().includes(n.toLowerCase())); const bsw=findUp('Bone Swords'); const bstr=findUp('Barbed Strangler'); const vc=findUp('Venom Cannon'); if(bsw && (bsw.points||0)!==3) issues.push('Warrior Boneswords cost '+(bsw.points||0)+'  3'); if(bstr && (bstr.points||0)!==15) issues.push('Warrior Barbed Strangler cost '+(bstr.points||0)+'  15'); if(vc && (vc.points||0)!==15) issues.push('Warrior Venom Cannon cost '+(vc.points||0)+'  15'); const tUps=(UNIT_LOADOUTS['termagant']&&UNIT_LOADOUTS['termagant'].upgrades)||[]; const tFind=(gr)=>tUps.find(u=>(u.grants||'')===gr); const tStr=tFind('Stranglewebs'); const tDev=tFind('Devourer'); if(!tStr) issues.push('Termagant Stranglewebs upgrade missing'); else if((tStr.points||0)!==3) issues.push('Termagant Stranglewebs cost '+(tStr.points||0)+'  3'); if(!tDev) issues.push('Termagant Devourer upgrade missing'); else if((tDev.points||0)!==1) issues.push('Termagant Devourer cost '+(tDev.points||0)+'  1'); if(issues.length){ console.warn('[Validator]',issues); } else { console.info('[Validator] No mismatches'); } }

      function formationUnits(f){ let arr=[]; ['compulsory','optional'].forEach(k=> (f[k]||[]).forEach(s=> arr=arr.concat(s.units||[]))); if(f.special) arr=arr.concat(f.special.units||[]); return arr; }
      function totalModelsInFormation(f){ return formationUnits(f).reduce((s,u)=> s + Number(u.models||u.baseModels||1), 0); }
      function mostExpensiveUnitAcrossList(){ const all=(armyFormations||[]).flatMap(ff=> formationUnits(ff)); let max=null, mp=0; all.forEach(u=>{ const p=unitPoints(u); if(p>mp){ mp=p; max=u; } }); return max; }
      function validateFormationRules(){ const issues=window._latestValidationIssues||[]; (armyFormations||[]).forEach(f=>{ if(f.name==='Goff Warband'){ if(totalModelsInFormation(f)<25) issues.push('Goff Warband: at least 25 models required'); } else if(f.name==='Evil Sunz Warband'){ const bad=formationUnits(f).some(u=>{ const mv=((UNIT_BASE[u.id]&&UNIT_BASE[u.id].movement)||'').match(/(\d+)/); const n=mv?Number(mv[1]):0; return n<8; }); if(bad) issues.push('Evil Sunz Warband: all models must have Move 8+ or be embarked'); } else if(f.name==='Snakebites Warband'){ const bad=formationUnits(f).some(u=>{ const base=(UNIT_DEFAULT_MODELS[u.id]||u.baseModels||1); return base>=2; }); if(bad) issues.push('Snakebites Warband: no detachments of size 2+'); } else if(f.name==='Bad Moons Warband'){ const mx=mostExpensiveUnitAcrossList(); const present=formationUnits(f).some(u=> mx && u.id===mx.id && unitPoints(u)===unitPoints(mx)); if(!present) issues.push('Bad Moons Warband: most expensive mob must be part of the formation'); } }); window._latestValidationIssues=issues; }
      function requestRender(){ if(requestRender._t) return; requestRender._t = setTimeout(()=>{ requestRender._t=null; renderContent(); },0); }
      function updateStatusBanner(){ const el=document.getElementById('status-banner'); if(!el) return; let msg=''; if(dataStatus.loading){ msg='Loading data'; } el.style.display = msg ? '' : 'none'; el.textContent = msg || ''; }
      function setActiveTab(t){ activeTab=t; const m=document.getElementById('account-menu'); if(m) m.style.display='none'; const links=document.querySelectorAll('.topbar a[data-tab]'); links.forEach(a=>{ a.classList.toggle('active', a.getAttribute('data-tab')===activeTab); }); requestRender(); }
      function setReferenceView(v){ referenceView=v; updateReferenceHash(); requestRender(); }
      function openReferenceHome(){ referenceView='main'; referenceDetail={ army:null, unitId:null }; referenceShowUpgrades=false; updateReferenceHash(); requestRender(); }
      function openReferenceUnits(){ referenceView='units'; referenceDetail={ army:null, unitId:null }; referenceShowUpgrades=false; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceUnit(army, unitId){ referenceView='unit-detail'; referenceDetail={ army, unitId }; updateReferenceHash(); ensureArmyMaster(army).then(()=>requestRender()); }
      function openReferenceWeapons(){ referenceView='weapons'; referenceWeapon=null; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceWeapon(name){ referenceView='weapon-detail'; referenceWeapon=String(name||''); updateReferenceHash(); requestRender(); }
      function openReferenceDetachments(){ referenceView='detachments'; updateReferenceHash(); preloadAllArmyMasters().then(()=>requestRender()); }
      function openReferenceFormations(){ referenceView='formations'; updateReferenceHash(); requestRender(); }
      function setReferenceFilter(val){ referenceQuery=String(val||''); const min=12; const shouldFilter = referenceQuery.length>=min; referenceFilter = shouldFilter ? referenceQuery : ''; clearTimeout(setReferenceFilter._t); setReferenceFilter._t = setTimeout(()=>{ if(shouldFilter || referenceQuery===''){ requestRender(); } try{ const id = referenceView==='units' ? 'ref-unit-search' : (referenceView==='weapons' ? 'ref-weapon-search' : (referenceView==='detachments' ? 'ref-detach-search' : '')); if(id){ const el=document.getElementById(id); if(el && el.focus){ el.focus(); const len = el.value ? el.value.length : 0; try{ el.setSelectionRange(len, len); }catch(e){} } } }catch(e){} }, 200); }
      function commitReferenceFilter(val){ referenceQuery=String(val||''); referenceFilter=referenceQuery; requestRender(); }
      function toggleReferenceUpgrades(){ referenceShowUpgrades=!referenceShowUpgrades; requestRender(); }

      function updateReferenceHash(){ try{ if(referenceView==='main'){ location.hash = '#ref'; } else if(referenceView==='units'){ location.hash = '#ref/units'; } else if(referenceView==='unit-detail'){ location.hash = '#ref/unit/'+encodeURIComponent(referenceDetail.army||'')+'/'+encodeURIComponent(referenceDetail.unitId||''); } else if(referenceView==='weapons'){ location.hash = '#ref/weapons'; } else if(referenceView==='weapon-detail'){ location.hash = '#ref/weapon/'+encodeURIComponent(referenceWeapon||''); } else if(referenceView==='detachments'){ location.hash = '#ref/detachments'; } else if(referenceView==='formations'){ location.hash = '#ref/formations'; } else if(referenceView==='army-rules'){ location.hash = '#ref/army-rules/'+encodeURIComponent(armyRulesFaction||''); } }catch(e){} }
      function applyReferenceHash(){ try{ const h=(location.hash||'').replace(/^#/, ''); const parts=h.split('/'); if(parts[0]!=='ref'){ return; } setActiveTab('reference'); if(parts.length===1 || !parts[1]){ openReferenceHome(); return; } if(parts[1]==='units'){ openReferenceUnits(); return; } if(parts[1]==='unit'){ const army=decodeURIComponent(parts[2]||''); const unit=decodeURIComponent(parts[3]||''); openReferenceUnit(army, unit); return; } if(parts[1]==='weapons'){ openReferenceWeapons(); return; } if(parts[1]==='weapon'){ const name=decodeURIComponent(parts[2]||''); openReferenceWeapon(name); return; } if(parts[1]==='detachments'){ openReferenceDetachments(); return; } if(parts[1]==='formations'){ openReferenceFormations(); return; } if(parts[1]==='army-rules'){ armyRulesFaction = decodeURIComponent(parts[2]||'Tyranids'); openReferenceArmyRules(); return; } openReferenceHome(); }catch(e){} }
      function toggleAccountMenu(e){}
      function openProfile(){ alert('Profile coming soon'); }

      function unitsFor(slotType){ const key=armyKey(selectedArmy); const list=ARMY_UNIT_LIST[key]||[]; if(slotType==='Special') return list; const ids=((ARMY_SLOT_FILTERS[key]||{})[slotType])||[]; return list.filter(u=>ids.includes(u.id)); }

      const SLOT_ICON_IMAGES = { 'Tyranids': { Synapse:'Images/Synapse.png', HQ:'Images/Synapse.png', Core:'Images/Core.png', Flyer:'Images/Flyer.jpg', Biotitan:'Images/Biotitan.png', Transport:'Images/Transport.png' } };
      function slotIcon(t){ const fallback={Synapse:'',Core:'',Flyer:'',Biotitan:'',Transport:'',HQ:'',Support:''}; const icons=SLOT_ICON_IMAGES[selectedArmy]; const url=icons&&icons[t]; return url? `<img src="${url}" class="slot-icon" alt="${t}"/>` : (fallback[t]||''); }
      function slotIcons(types){ return (types||[]).map(slotIcon).join(''); }



      // ---------- Formation & slot management ----------

      function handleArmySelection(val){ selectedArmy=val; selectedFormationName='Select a Formation'; armyFormations=[]; loadConsolidatedArmyMaster(val).then(ref=>{ if(ref){ window._lastMasterRef = ref; applyMasterBroodDefaults(ref); applyUpgradeConstraintsFromMaster(ref); buildUpgradeEffectsFromMaster(ref); buildArmyUnitsFromMaster(ref, val); } renderContent(); saveState(); }); }

      function handleFormationSelection(val){ selectedFormationName=val; saveState(); }
      function setBuilderName(val){ builderMeta.name = String(val||'New List'); saveState(); }
      function setBuilderAllegiance(val){ builderMeta.allegiance = String(val||'Loyalist'); saveState(); }
      function setBuilderPoints(val){ const n = Number(val||0); builderMeta.pointsCap = isNaN(n)?builderMeta.pointsCap:n; saveState(); renderContent(); }
      function listModelsCurrent(){ const total=(armyFormations||[]).flatMap(f=>[...f.compulsory,...f.optional].flatMap(s=>s.units||[])).reduce((s,u)=>s+(u.models||u.baseModels||1),0); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${builderMeta.name}  Models</h3><div class="small">Total models: ${total}</div></div></div>`; }
      function sanitizeFormations(arr){ try{ const clean=JSON.parse(JSON.stringify(arr||[])); clean.forEach(f=>{ ([...(f.compulsory||[]), ...(f.optional||[])]).forEach(s=>{ delete s._selectedUnitId; (s.units||[]).forEach(u=>{ delete u._appliedEffects; }); }); if(f.special){ delete f.special._selectedUnitId; (f.special.units||[]).forEach(u=>{ delete u._appliedEffects; }); } }); return clean; }catch(e){ return []; } }
      function saveCurrentList(){ const now=Date.now(); const payload={ id: currentListId || String(now), name: builderMeta.name, gamemode: builderMeta.gamemode, allegiance: builderMeta.allegiance, pointsCap: builderMeta.pointsCap, faction: selectedArmy, formations: sanitizeFormations(armyFormations), createdAt: currentListId ? (savedLists.find(x=>x.id===currentListId)?.createdAt || now) : now, updatedAt: now }; const idx = savedLists.findIndex(x=>x.id===payload.id); if(idx>-1) savedLists[idx]=payload; else savedLists.push(payload); currentListId = payload.id; persistSavedLists(); requestRender(); }
function autoSaveList(reason){ if(selectedArmy==='Select Army') return; const now=Date.now(); const payload={ id: currentListId || String(now), name: builderMeta.name, gamemode: builderMeta.gamemode, allegiance: builderMeta.allegiance, pointsCap: builderMeta.pointsCap, faction: selectedArmy, formations: sanitizeFormations(armyFormations), createdAt: currentListId ? (savedLists.find(x=>x.id===currentListId)?.createdAt || now) : now, updatedAt: now }; const idx=savedLists.findIndex(x=>x.id===payload.id); if(idx>-1) savedLists[idx]=payload; else savedLists.push(payload); currentListId=payload.id; persistSavedLists(); }
      function viewCompact(){ const lines=[]; lines.push(`${builderMeta.name}  ${selectedArmy}  ${builderMeta.pointsCap} pts`); (armyFormations||[]).forEach(f=>{ lines.push(`- ${f.name}: ${formationPoints(f)} pts`); [f.compulsory,f.optional].forEach(arr=>arr.forEach(s=> (s.units||[]).forEach(u=>{ lines.push(`   ${u.name} (${unitPoints(u)} pts)`);}))); if(f.special) (f.special.units||[]).forEach(u=>lines.push(`   ${u.name} (${unitPoints(u)} pts)`)); }); const text = lines.join('\n'); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${builderMeta.name}  Compact View</h3><pre class="compact-pre">${text}</pre><div style="display:flex;gap:8px;justify-content:flex-end"><button class="btn" onclick="closeModal()">Close</button><button class="btn btn-green" onclick="navigator.clipboard&&navigator.clipboard.writeText('${text.replace(/'/g,"\\'")}')">Copy</button></div></div></div>`; }
      function deleteCurrentList(){ if(!currentListId){ alert('No saved list to delete'); return; } const idx=savedLists.findIndex(x=>x.id===currentListId); if(idx>-1){ savedLists.splice(idx,1); persistSavedLists(); currentListId=null; alert('Deleted'); } }



      const GREEK_LETTERS = ['Alpha','Beta','Gamma','Delta','Epsilon','Zeta','Eta','Theta','Iota','Kappa','Lambda','Mu','Nu','Xi','Omicron'];

      function getBaseFormationName(name) {
          let clean = name || 'Formation';
          clean = clean.replace(/ \(copy\)$/, '');
          // Check for Greek words
          for (const g of GREEK_LETTERS) {
              if (clean.endsWith(' ' + g)) {
                  clean = clean.substring(0, clean.length - (g.length + 1));
                  break; 
              }
          }
          // Check for old Greek chars (legacy support)
          const oldGreek = ['','','','','','','','','',''];
          for (const g of oldGreek) {
              if (clean.endsWith(' ' + g)) {
                  clean = clean.substring(0, clean.length - 2);
                  break;
              }
          }
          return clean;
      }

      function reapplyFormationNaming(baseName) {
          const candidates = armyFormations.filter(f => getBaseFormationName(f.name) === baseName);
          if (candidates.length > 1) {
              candidates.forEach((f, i) => {
                  if (i < GREEK_LETTERS.length) {
                      f.name = baseName + ' ' + GREEK_LETTERS[i];
                  }
              });
          } else if (candidates.length === 1) {
              candidates[0].name = baseName;
          }
      }

      function addFormation(){

        if(!selectedArmy || selectedArmy === 'Select Army'){ alert('Choose an army'); return; }

        if(!selectedFormationName || selectedFormationName === 'Select a Formation'){ alert('Choose a formation'); return; }

        const tpl = FORMATIONS[selectedFormationName];

        if(!tpl){ alert('Formation not available'); return; }

        if(armyFormations.length) armyFormations[armyFormations.length-1].collapsed = true;

        const toSlots = (arr)=> (arr||[]).flatMap(s => Array.from({length: s.max||1}, (_,i) => ({ type:s.type, label:s.label, units:[], _selectedUnitId:'', max:1, min: (s.min>0?1:0), _group:{ type:s.type, label:s.label, index:i+1, groupMin:s.min||0, groupMax:s.max||1 } })));

        const compulsory = toSlots(tpl.compulsory);

        const optional   = toSlots(tpl.optional);

        const special    = tpl.special ? ({...tpl.special, units:[], _selectedUnitId:''}) : null;

        const baseName = selectedFormationName;
        armyFormations.push({ name:baseName, army:selectedArmy, collapsed:false, compulsory, optional, special });

        reapplyFormationNaming(baseName);

        selectedFormationName = 'Select a Formation';

        const formSelect = document.getElementById('formation-select');

        if(formSelect) formSelect.value = 'Select a Formation';

        requestRender();
        saveState();

      }



      function removeFormation(idx){ 
          const f = armyFormations[idx];
          const baseName = getBaseFormationName(f.name);
          armyFormations.splice(idx,1); 
          reapplyFormationNaming(baseName);
          requestRender(); 
          saveState(); 
      }
      function toggleCollapse(idx){ armyFormations[idx].collapsed = !armyFormations[idx].collapsed; requestRender(); saveState(); }
      function cloneFormation(idx){ 
          const copy = JSON.parse(JSON.stringify(armyFormations[idx])); 
          const baseName = getBaseFormationName(copy.name);
          copy.name = baseName;
          armyFormations.splice(idx+1,0,copy); 
          reapplyFormationNaming(baseName);
          requestRender(); 
          saveState(); 
      }



      function setSlotSelection(fIdx,section,sIdx,val){ const slot = armyFormations[fIdx][section][sIdx]; if(!slot) return; slot._selectedUnitId = val; if(val){ addUnitToSlot(fIdx,section,sIdx); } }



      function addUnitToSlot(fIdx,section,sIdx){

        const slot = armyFormations[fIdx][section][sIdx];

        if(!slot) return;

        if(!slot._selectedUnitId) return alert('Select a unit');
        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const base = list.find(u=>u.id === slot._selectedUnitId);
        if(!base) return;



        const load = UNIT_LOADOUTS[base.id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[]};

        const weapons = (load.weapons||[]).filter(w=>w.base).map(w=>({ id:w.id, name:w.name, src:w.src, points: (WEAPON_LIBRARY[w.src] && WEAPON_LIBRARY[w.src].points) || 0 }));

        const defaults = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[base.id]) || 1;
        const instance = {
          ...base,
          qty: 1,
          weapons,
          upgrades: [],
          psychic: [],
          notes: [],
          _appliedEffects: {},
          models: defaults,
          baseModels: defaults
        };
        if((slot.units||[]).length){ slot.units[0] = instance; } else { slot.units.push(instance); }

        slot._selectedUnitId = base.id;

        renderContent();
        saveState();

      }



      function addUnitToSpecial(fIdx,unitId){

        const slot = armyFormations[fIdx].special;
        if(!slot) return;

        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const candidate = list.find(u=>u.id===unitId);
        if(!candidate) return alert('Invalid special selection');
        if(slot.allowedTypes && slot.allowedTypes.length && !slot.allowedTypes.includes(candidate.slotType)){ alert('This unit type is not allowed in this special slot'); return; }

        const load = UNIT_LOADOUTS[candidate.id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[]};
        const weapons = (load.weapons||[]).filter(w=>w.base).map(w=>({ id:w.id, name:w.name, src:w.src, points: (WEAPON_LIBRARY[w.src] && WEAPON_LIBRARY[w.src].points) || 0 }));

        const defaults = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[candidate.id]) || 1;
        const instance = {...candidate, qty:1, weapons, upgrades:[], psychic:[], notes:[], _appliedEffects:{}, models: defaults, baseModels: defaults};
        if((slot.units||[]).length){ slot.units[0] = instance; } else { slot.units.push(instance); }
        slot._selectedUnitId = candidate.id;
        renderContent();
        saveState();

      }



      function removeUnit(fIdx,section,sIdx,uIdx){ const slot = armyFormations[fIdx][section][sIdx]; if(!slot) return; slot.units.splice(uIdx,1); slot._selectedUnitId=''; requestRender(); saveState(); }
      function removeSpecialUnit(fIdx,uIdx){ const slot = armyFormations[fIdx].special; if(!slot) return; slot.units.splice(uIdx,1); slot._selectedUnitId=''; requestRender(); saveState(); }



      // ---------- points & render helpers ----------

      function unitPoints(u){
        const base = (UNIT_BASE[u.id] && UNIT_BASE[u.id].points) || 0;
        const ups = (u.upgrades||[]).reduce((s,x)=>{
          const name = String(x.name||'');
          const id = String(x.id||'');
          if(/Increase\s+Brood\s+size/i.test(name) && !id.startsWith('u_bsize_apply_')) return s;
          if(/replace\s+one\s+genestealer\s+w\/\s+broodlord/i.test(name)) return s;
          return s + (x.points||0);
        },0);
        const wep = (u.weapons||[]).reduce((s,x)=>s+(x.points||0),0);
        const psy = (u.psychic||[]).reduce((s,x)=>s+(x.points||0),0);
        return base + ups + wep + psy;
      }

      function formationPoints(f){

        let s=0;

        ['compulsory','optional'].forEach(k => (f[k]||[]).forEach(slot => (slot.units||[]).forEach(u => s += unitPoints(u))));

        if(f.special) (f.special.units||[]).forEach(u => s+= unitPoints(u));

        return s;

      }



      // ---------- Modal & dynamic UI (unchanged behavior) ----------

      function openEditModal(fIdx,section,sIdx,uIdx){ editContext = {fIdx,section,sIdx,uIdx}; window.editContext = editContext; renderModal(); }

      function closeModal(){ editContext=null; window.editContext=null; const root=document.getElementById('modal-root'); if(root) root.innerHTML=''; const last=window._lastFocused; if(last && last.focus){ try{ last.focus(); }catch(e){} } }
      function trapFocus(container){ try{ const focusable=container.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); const first=focusable[0]; const last=focusable[focusable.length-1]; container.addEventListener('keydown', function(e){ if(e.key==='Tab'){ if(focusable.length===0) return; if(e.shiftKey){ if(document.activeElement===first){ e.preventDefault(); last.focus(); } } else { if(document.activeElement===last){ e.preventDefault(); first.focus(); } } } }); }catch(e){} }

      function currentLoadout(id){ return UNIT_LOADOUTS[id] || {weapons:[], upgrades:[], psychicPowers:[], baseCAF:'+0', baseWounds:1, specialRules:[]}; }

      function unitHasUpgrade(unit,upgradeId){ return (unit.upgrades||[]).some(u=>u.id === upgradeId); }

      function weaponConstraintsFor(id){ const r = WEAPON_CONSTRAINTS[id]; return r || { mutexPairs:[], disableWhenUpgrade:{} }; }
      function computeDisabledWeapons(unit, checked, activeUpgrades){ const rules=weaponConstraintsFor(unit.id); const disable=new Set(), hide=new Set(); (rules.mutexPairs||[]).forEach(([a,b])=>{ if(checked.includes(a)) disable.add(b); if(checked.includes(b)) disable.add(a); }); const upsActive = new Set(activeUpgrades||[]); Object.entries(rules.disableWhenUpgrade||{}).forEach(([upId,list])=>{ if(upsActive.has(upId)) list.forEach(n=>{ disable.add(n); hide.add(n); }); }); const load=UNIT_LOADOUTS[unit.id]||{}; (load.upgrades||[]).forEach(u=>{ if(upsActive.has(u.id) && u.replaces){ const rList=u.replaces.split(',').map(s=>s.trim()); rList.forEach(n=>disable.add(n)); } }); return { disable, hide }; }
      function enforceWeaponConstraints(){
        if(!editContext) return;
        const {fIdx,section,sIdx,uIdx}=editContext;
        const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx];
        const unit=slot&&slot.units&&slot.units[uIdx];
        if(!unit) return;
        const checked=Array.from(document.querySelectorAll('.modal-weapon-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-name'));
        const activeUps = Array.from(document.querySelectorAll('.modal-upgrade-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id')).concat(Array.from(document.querySelectorAll('.modal-special-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id')));
        const {disable, hide} = computeDisabledWeapons(unit, checked, activeUps);
        document.querySelectorAll('.modal-weapon-checkbox').forEach(cb=>{
          const n=cb.getAttribute('data-name');
          const row=cb.closest('tr');
          const dis=disable.has(n);
          // Tyrannofex Rupture Cannon: allow manual re-selection
          const isTfexRupture = unit.id === 'tyrannofex' && n === 'Rupture Cannon';
          cb.disabled = dis && !isTfexRupture;
          if(dis && cb.checked){
            cb.checked=false;
          } else if(!dis && !cb.checked && cb.getAttribute('data-base')==='true'){
            cb.checked=true;
          }
          if(row){
            row.style.opacity = (dis && !isTfexRupture) ? 0.5 : '';
            row.style.display = hide.has(n) ? 'none' : 'table-row';
          }
        });
      }
      window.onModalWeaponToggle = function(target){
        if(target && window._modalUnitRef && window._modalUnitRef.id === 'tyrannofex' && target.checked && target.getAttribute('data-name') === 'Rupture Cannon'){
           ['u_tfex_swap_flesh', 'u_tfex_swap_acid'].forEach(id => {
             const cb = document.querySelector(`.modal-upgrade-checkbox[data-id="${id}"]`);
             if(cb && cb.checked) {
               cb.checked = false;
               const oInp = document.getElementById('upcnt-'+id);
               if(oInp) oInp.value = 0;
               const oRm = document.getElementById('uprm-'+id);
               if(oRm) oRm.style.display = 'none';
             }
           });
        }
      }
      function filterWepsByConstraints(unitId, weps, ups){ const rules=weaponConstraintsFor(unitId); let out=weps.slice(); (rules.mutexPairs||[]).forEach(([a,b])=>{ const hasA=out.find(w=>w.name===a); const hasB=out.find(w=>w.name===b); if(hasA&&hasB){ out = out.filter(w=>w.name!==b); } }); Object.entries(rules.disableWhenUpgrade||{}).forEach(([upId,list])=>{ if((ups||[]).some(u=>u.id===upId)) out = out.filter(w=>!list.includes(w.name)); }); return out; }
      const UPGRADE_EFFECTS = {};
      let RULE_NAME_CATALOG = [];
      async function loadTyranidRules(){ return; }
      let RULES_INDEX = {};
      const CROSS_TRAIT_INDEX = {
        'Agile': 'Models with this special rule may change the direction they are facing any number of times during their movement.',
        'Regenerate': 'Roll a D6 for each wound lost at the end of the turn; on a 5+, the wound is regained. (Verify with rulebook)',
        'The Horror': 'Enemy units in contact suffer -1 to Hit rolls. (Verify with rulebook)',
        'Light':'Cannot damage Light Armoured vehicles or better',
        'Light AT':'AP counts as 0 against Vehicles/Knights/Titans',
        'Anti-Tank':'AP counts as 0 against Infantry/Cavalry',
        'Anti-Infantry':'Optimized to defeat infantry formations',
        'Beam':'Hits all models under a 1mm wide line',
        'Armorbane':'Successful Saves by Vehicles/Knights/Titans must be re-rolled',
        'Ignore Cover':'Targets do not receive cover benefits',
        'Ignores Cover':'Targets do not receive cover benefits',
        'Blast':'Uses 3" or 5" template; hits based on models under template',
        'Torrent':'Short-range stream; continuous effect along a path',
        'Rapid Fire':'Any natural rolls of a 6 score 2 Hits instead of 1',
        'Rapid-Fire':'Any natural rolls of a 6 score 2 Hits instead of 1',
        'Rend':'Add D6 to Fight rolls',
        'Parry':'In Close Combat, force opponent to re-roll one die',
        'Brutal':'Increases lethality in melee',
        'Unreliable':'May suffer malfunctions or reduced consistency',
        'Arc':'Can only target Detachments in specified Arc',
        'SkyFire':'Can target Flyers; -2 To Hit against non-Flyers',
        'Shieldbane':'Bypasses Void Shields even if AP is 0',
         'Heavy Barrage':'Acts as Barrage; can damage Structures',
        'Bombing Run':'Attacks during movement; targets within 3"',
        'Spore Launcher':'Target closest model in detachment. Roll 2D6 + scatter. If hit, detonates as Spore Mine.',
        'Hunger':'When enemy slain, attacker regains 1 wound (up to max)',
        'Bunker Buster':'AP counts as double against Structures',
        'Attract':'If target not killed, move closest model D6" towards attacker',
        'Psychic Power':'',
        'Jink':'Reactive save against shooting attacks',
        'Interceptor':'Can target units arriving from reserves',
        'Flyer':'Aerial movement mode with special engagement rules',
        'Hover':'May operate as ground skimmer this turn',
        'Deep Strike':'Deploy from reserves to a chosen location following placement rules',
        'Infiltrate':'Forward deployment using special placement rules',
        'Winged':'Improved movement and aerial engagement capability',
        'Synapse':'Nearby friendly units auto-pass morale checks except psychic tests',
        'Instinct':'Units outside Synapse must follow their instinct subtype (Hunt/Rampage/Nest)',
        'Hunt':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Rampage':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Nest':'Instinct subtype. Behaviour defined in Tyranids army rules.',
        'Pinning':'Infantry units hit by this weapon take an extra Blast marker.',
        'Web':'Units hit by this weapon may not move in their next activation.',
        'Feel No Pain':'Roll to ignore suffered wounds',
        'Invulnerable Save':'Save roll that ignores AP modifiers',
        'Bulky':'Counts more for transport/movement constraints',
        'Implacable':'Resists falling back; steady advance',
        'Regenerate':'Recover lost wounds during end phase',
        'Drop Pod':'Deploy via descent; assault transport',
        'Commander':'Provides command aura or special order access to nearby units',
        'Void Shields':'Energy shield layers that absorb hits before Wounds; some traits bypass or reduce shields',
        'God-engine':'Titanic construct with unique resilience and rules interactions',
        'Jump Packs':'Enhanced movement; treats as aerial leap with special restrictions',
        'Accurate': 'Re-roll failed Hit rolls',
        'Assault': 'Double dice if within half range',
        'Barrage': 'Can target without LoS (suffers -1 to Hit)',
        'Burrowing': 'Counts as hitting Rear Arc; bypasses Void Shields',
        'Bypass': 'Bypasses specified saves (e.g., Void Shields)',
        'Co-axial': 'Must target same unit as primary weapon',
        'Collapsing Singularity': 'Roll D6; on 1 firing model takes Wound, on 6 hits bypass Void Shields',
        'Deflagrate': 'Unsaved Wounds generate additional Hits',
        'Demolisher': 'Can damage Structures',
        'Engine Killer': 'Super-heavies/Knights/Titans suffer X additional Wounds',
        'Firestorm': 'Uses Flame template; bypasses Cover Saves',
        'Point Defence': 'Can be fired in Engagement phase against Infantry',
        'Reach': 'Can fight models within 2 inches',
        'Ripple Fire': 'Re-roll failed Hit rolls if stationary',
        'Saturation Fire': 'Target suffers -1 to Save rolls',
        'Shock Pulse': 'Vehicles/Knights/Titans hit reduce Movement and Shield level',
        'Shred': 'Re-roll failed Wound rolls against Infantry/Cavalry',
        'Tracking': 'Re-roll failed Hit rolls against Flyers',
        'Warp': 'Bypasses Void Shields and Invulnerable Saves',
        'Wrecker': 'Damages Structures and Garrisoned units'
      };
      function _normKey(s){ return String(s||'').trim().toLowerCase().replace(/_/g,' ').replace(/[^a-z0-9\s]/g,'').replace(/\s+/g,' ').trim(); }
      function renderTraitsCell(val){ const arr = Array.isArray(val) ? val : String(val||'').split(';').map(s=>s.trim()).filter(Boolean); if(!arr.length) return '-'; return arr.map(t=>{ const k=t.split('(')[0].split(':')[0].trim(); const rest=t.slice(k.length); return '<span class="rule-key" data-rule="'+k+'" style="text-decoration:underline;font-style:italic;cursor:pointer" onclick="openRuleDialog(\''+k+'\')">'+k+'</span>'+rest; }).join(', '); }
      function renderRuleText(r){ const txt=String(r||''); const base = txt.split(':')[0].split('(')[0].trim(); const afterBase = txt.slice(base.length); const subtype = txt.includes(':') ? txt.split(':')[1].split('(')[0].trim() : ''; if(subtype){ const tail = txt.slice((base+': '+subtype).length); return '<div class="muted small">- <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+base+'" onclick="openRuleDialog(\''+base+'\')">'+base+'</span>: <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+subtype+'" onclick="openRuleDialog(\''+subtype+'\')">'+subtype+'</span>'+tail+'</div>'; } return '<div class="muted small">- <span class="rule-key" style="text-decoration:underline;font-style:italic;cursor:pointer" data-rule="'+base+'" onclick="openRuleDialog(\''+base+'\')">'+base+'</span>'+afterBase+'</div>'; }
      function getRuleEffect(k){ return RULES_INDEX[_normKey(k)] || ''; }
      function showRulePopover(target, key){ document.querySelectorAll('.rule-popover').forEach(p=>p.remove()); const eff=getRuleEffect(key)||key; const pop=document.createElement('div'); pop.className='rule-popover'; pop.textContent=eff; document.body.appendChild(pop); const rect=target.getBoundingClientRect(); const pad=6; let left=rect.left; let top=rect.bottom + pad; const vw=document.documentElement.clientWidth; const vh=document.documentElement.clientHeight; const pw=pop.offsetWidth||280; const ph=pop.offsetHeight||60; if(left+pw>vw) left=Math.max(8, vw-pw-8); if(top+ph>vh) top=Math.max(8, rect.top-ph-pad); pop.style.left=left+'px'; pop.style.top=top+'px'; function close(){ if(pop && pop.remove) pop.remove(); document.removeEventListener('click', onDoc, true); } function onDoc(e){ if(!pop.contains(e.target) && e.target!==target) close(); } setTimeout(()=>document.addEventListener('click', onDoc, true),0); }
      function openRuleDialog(key){ try{ Array.from(document.querySelectorAll('.rule-popover,.rule-dialog-backdrop')).forEach(el=>el.remove()); }catch(e){} const eff=getRuleEffect(key)||key; const root=document.getElementById('modal-root')||document.body; const wrap=document.createElement('div'); wrap.className='rule-dialog-backdrop'; wrap.style.position='fixed'; wrap.style.inset='0'; wrap.style.background='rgba(0,0,0,.4)'; wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.justifyContent='center'; wrap.style.zIndex='100000'; const box=document.createElement('div'); box.className='rule-dialog'; box.style.background='#163010'; box.style.color='#e6eef8'; box.style.border='1px solid #245017'; box.style.padding='12px'; box.style.borderRadius='8px'; box.style.boxShadow='0 12px 32px rgba(0,0,0,.6)'; box.style.maxWidth='420px'; box.style.width='90%'; const title=document.createElement('div'); title.className='rule-title'; title.style.fontWeight='800'; title.style.marginBottom='6px'; title.textContent=key; const text=document.createElement('div'); text.className='rule-text'; text.style.whiteSpace='pre-wrap'; text.textContent=eff; const btns=document.createElement('div'); btns.style.display='flex'; btns.style.justifyContent='flex-end'; btns.style.gap='8px'; btns.style.marginTop='8px'; const close=document.createElement('button'); close.className='btn btn-sm btn-blue'; close.textContent='Close'; close.onclick=()=>{ if(wrap&&wrap.remove) wrap.remove(); }; btns.appendChild(close); box.appendChild(title); box.appendChild(text); box.appendChild(btns); wrap.appendChild(box); wrap.onclick=(e)=>{ if(e.target===wrap){ wrap.remove(); } }; root.appendChild(wrap); }
      async function initRulesIndex(){ try{ const dict={}; const ref=window._lastMasterRef||{}; const add=(n,e)=>{ if(!n) return; dict[_normKey(n)] = e||''; RULE_NAME_CATALOG.push(String(n||'').toLowerCase()); };
        Object.entries(CROSS_TRAIT_INDEX).forEach(([n,e])=>add(n,e));
        try{ const sr=ref.special_rules_library||{}; Object.entries(sr).forEach(([n,e])=>add(slugToName(n), e)); }catch(e){}
        try{ const wtl=ref.weapon_traits_library||{}; Object.entries(wtl).forEach(([n,e])=>add(slugToName(n), e)); }catch(e){}
        try{ const orders=ref.unique_orders||{}; Object.values(orders).forEach(o=>add(o.name||slugToName(o.id||''), o.description||o.effect||'')); }catch(e){}
        try{ const pp=ref.psychic_powers||{}; Object.values(pp).forEach(p=>add(p.name, p.effect||'')); }catch(e){}
        try{ const fr=(ref.faction_info&&ref.faction_info.faction_rules)||[]; fr.forEach(r=>add(r.name, r.effect||r.description||'')); }catch(e){}
        try{ const mr=await fetch('PDF/MainRules.json',{cache:'no-store'}).then(r=>r.ok?r.json():null); if(mr){ Object.entries(mr.traitLibrary||{}).forEach(([slug,effect])=>add(slug,effect)); Object.values(mr.unit_roster||{}).forEach(u=>{ (u.special_rules||[]).forEach(sr=>add(sr,'')); }); } }catch(e){}
        const lib=ref.weaponLibrary||{}; Object.values(lib).forEach(def=>{ const traits = Array.isArray(def.traits)? def.traits : String(def.traits||'').split(';').map(s=>s.trim()).filter(Boolean); traits.forEach(t=>{ const k=String(t).split('(')[0].split(':')[0].trim(); add(k, dict[_normKey(k)]||''); }); });
        Object.values(UNIT_LOADOUTS||{}).forEach(load=>{ (load.specialRules||[]).forEach(r=>{ const k=String(r).split(':')[0].split('(')[0].trim(); add(k, dict[_normKey(k)]||''); }); (load.psychicPowers||[]).forEach(p=>add(p.name,p.desc||'')); (load.upgrades||[]).forEach(u=>add(u.name,u.desc||'')); });
        RULES_INDEX=dict; }catch(e){ RULES_INDEX={}; } }
      function deriveEffectsFromText(name, desc){ const txt = (name+' '+(desc||'')).toLowerCase(); const rules=[]; const stats={}; RULE_NAME_CATALOG.forEach(n=>{ if(n && txt.includes(n)) rules.push(n.replace(/\(x?\)/i,'')); }); const syn = txt.match(/synapse\s*\(?\s*(\d+)\s*\"?\s*\)?/i); if(/synapse/i.test(txt)){ rules.push('Synapse'+(syn?` (${syn[1]}\")`:'')); } if(/the\s+horror/i.test(txt)) rules.push('The Horror'); if(/winged|flying/i.test(txt)) rules.push('Winged'); if(/feel\s+no\s+pain/i.test(txt)) rules.push('Feel No Pain'); const caf = txt.match(/caf\s*(?:becomes)?\s*\+?(-?\d+)/i); if(caf) stats.CAF = '+'+caf[1]; const w = txt.match(/wounds\s*=?\s*(\d+)/i); if(w) stats.Wounds = Number(w[1]); const mov = txt.match(/movement(?:\s+profile)?\s*(\d+)\"/i); if(mov) stats.Movement = mov[1]+'"'; if(/flying/.test(txt) && stats.Movement) stats.Movement = stats.Movement+' (Flying)'; return { rules, stats }; }
      function buildUpgradeEffects(){ Object.entries(UNIT_LOADOUTS).forEach(([uid,load])=>{ (load.upgrades||[]).forEach(u=>{ UPGRADE_EFFECTS[u.id] = deriveEffectsFromText(u.name||'', u.desc||''); }); }); }
      function buildUpgradeEffectsFromMaster(ref){ try{ const roster=ref.unit_roster||{}; const norm=(k)=>k.replace(/_brood$/,'').replace(/_/g,'-'); Object.keys(roster).forEach(key=>{ const appId=norm(key); const data=roster[key]||{}; const ups=(data.upgrades||[]); const load=(UNIT_LOADOUTS[appId]||{}); ups.forEach(u=>{ const name=String(u.name||u.description||''); const eff=deriveEffectsFromText(name, u.description||''); const match=(load.upgrades||[]).find(x=> (x.name||'').toLowerCase().includes(String(u.name||'').toLowerCase().split(' (')[0]) ); if(match){ UPGRADE_EFFECTS[match.id] = eff; } }); }); }catch(e){} }
      async function ensurePDFJS(){ if(window.pdfjsLib) return; const head=document.head||document.getElementsByTagName('head')[0]; const s=document.createElement('script'); s.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; head.appendChild(s); await new Promise(r=>{ s.onload=r; s.onerror=r; }); const w=document.createElement('script'); w.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; head.appendChild(w); await new Promise(r=>{ w.onload=r; w.onerror=r; }); if(window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) window.pdfjsLib.GlobalWorkerOptions.workerSrc=w.src; }
      async function parsePDFToText(url){ try{ const key='pdf_cache_'+url; const cached=localStorage.getItem(key); if(cached){ return cached; } await ensurePDFJS(); const d=await window.pdfjsLib.getDocument({ url }).promise; let out=''; for(let i=1;i<=d.numPages;i++){ const p=await d.getPage(i); const tc=await p.getTextContent(); out+=tc.items.map(it=>it.str).join(' ')+'\n'; } try{ localStorage.setItem(key,out); }catch(e){} return out; }catch(e){ return ''; } }
      function extractFromPDFText(txt){ const data={ units:{} }; const norm=(s)=>s.toLowerCase(); if(/genestealer\s+brood/i.test(txt)){ data.units['genestealer']={ baseWeapon:{ name:'Rending Claws', traits:'Rend' }, upgrades:[{ id:'u_broodlord', name:'Broodlord (Model Upgrade)', points:20, type:'MODEL_UPGRADE', desc:'CAF +7; Synapse (6\") and The Horror for that model only.' }] }; } if(/hive\s+tyrant/i.test(txt) && /wings/i.test(txt)){ data.units['hive-tyrant']=data.units['hive-tyrant']||{}; const ups=(data.units['hive-tyrant'].upgrades=data.units['hive-tyrant'].upgrades||[]); ups.push({ id:'u_wings', name:'Add Wings', points:20, type:'MODEL_UPGRADE', desc:'Movement profile 10\"; Winged' }); } return data; }
      function applyExtractedData(payload){ Object.entries(payload.units||{}).forEach(([id,info])=>{ UNIT_LOADOUTS[id]=UNIT_LOADOUTS[id]||{ weapons:[], upgrades:[], psychicPowers:[], baseCAF:'', baseWounds:1, specialRules:[] }; if(info.baseWeapon){ const exists=(UNIT_LOADOUTS[id].weapons||[]).some(w=>w.name===info.baseWeapon.name); if(!exists) UNIT_LOADOUTS[id].weapons.unshift({ id:'w_pdf_'+id, name:info.baseWeapon.name, src:info.baseWeapon.name, base:true }); WEAPON_LIBRARY[info.baseWeapon.name]=WEAPON_LIBRARY[info.baseWeapon.name]||{ range:'-', dice:'-', toHit:'-', AP:'-', traits:info.baseWeapon.traits||'', points:0 }; }
        (info.upgrades||[]).forEach(u=>{ const has=(UNIT_LOADOUTS[id].upgrades||[]).some(x=>x.name===u.name); if(!has) UNIT_LOADOUTS[id].upgrades.push(u); UPGRADE_EFFECTS[u.id]=deriveEffectsFromText(u.name,u.desc); });
        const ref=window._lastMasterRef; if(ref && ref.unit_roster){ const norm=(k)=>String(k||'').replace(/_brood$/,'').replace(/_/g,'-'); const kMatch=Object.keys(ref.unit_roster).find(k=>norm(k)===id); if(kMatch){ const upArr=ref.unit_roster[kMatch].upgrades = ref.unit_roster[kMatch].upgrades||[]; (info.upgrades||[]).forEach(u=>{ if(!upArr.some(x=>String(x.name||'')===String(u.name||''))) upArr.push({ name:u.name, cost:u.points||0 }); }); const lib=ref.weaponLibrary = ref.weaponLibrary||{}; const slug=(s)=>String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); if(info.baseWeapon){ const wslug=slug(info.baseWeapon.name); lib[wslug]=lib[wslug]||{ range:'-', dice:'-', toHit:'-', ap:'-', traits: [] }; } const key=armyKey(selectedArmy); try{ localStorage.setItem('xenos_master_'+key, JSON.stringify(ref)); }catch(e){} } }
      }); }
      async function ingestPDFDocs(){ try{ const files=['PDF/LI_HiveWar_02.pdf','PDF/LI_Xenos_04.pdf','PDF/Legions Imperialis Rulebook - Optimised.pdf']; for(const f of files){ const t=await parsePDFToText(f); if(t) applyExtractedData(extractFromPDFText(t)); } }catch(e){} }

      async function loadBroodSize(){ return; }

      async function loadWeaponUpgrades(){ return; }



      function onModalUpgradeToggle(){
        const swarmCount = document.getElementById('upcnt-u_swarm');
        const isSwarmActive = swarmCount && Number(swarmCount.value||0)>0;
        const cafBlock = document.getElementById('modal-caf-block');
        const woundsBlock = document.getElementById('modal-wounds-block');
        if(cafBlock) cafBlock.style.display = isSwarmActive ? '' : 'none';
        if(woundsBlock) woundsBlock.style.display = isSwarmActive ? '' : 'none';
        const effectPill = document.getElementById('modal-effect-pill');
        if(effectPill){ if(isSwarmActive) effectPill.textContent = 'Swarm Lord effect: CAF becomes +14; Wounds = 3'; effectPill.style.display = isSwarmActive ? '' : 'none'; }
        enforceWeaponConstraints();
        updateSpecialRulesBlock();
        scheduleUpdateTotals();
      }



      function setModalUnitSizeLabel(models){ const root=document.getElementById('modal-root'); const lbl = root && root.querySelector('.modal-drawer #bsize-label'); if(!lbl) return; const {fIdx,section,sIdx,uIdx}=window.editContext||{}; const slot=(section==='special')?(armyFormations[fIdx]&&armyFormations[fIdx].special):(armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]); const unit=slot&&slot.units&&slot.units[uIdx]; const pts=unit? unitPoints(unit) : ''; lbl.innerHTML = pts!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts + ' PTS</span>') : ('Unit size: ' + models); lbl.setAttribute('data-models', String(models)); }
      function scheduleUpdateTotals(){ try{ requestAnimationFrame(()=>updateModalTotals()); }catch(e){ setTimeout(updateModalTotals,0); } }
      window.updateHieroduleVisuals = function(){
        const baseEl = document.getElementById('hierodule-base-count');
        if(baseEl){
            const inputs = Array.from(document.querySelectorAll('.modal-upgrade-count[data-upid^="u_hierodule_"]'));
            const sum = inputs.reduce((s,i)=>s+Number(i.value||0),0);
            
            let total = 1;
            const valEl = document.getElementById('modal-unit-val');
            if(valEl){
                total = Number(valEl.value || valEl.textContent || 0);
            } else {
                const lbl = document.querySelector('.modal-drawer #bsize-label');
                total = lbl ? Number(lbl.getAttribute('data-models')||1) : 1;
            }

            const rem = Math.max(0, total - sum);
            
            if(baseEl.tagName === 'INPUT') baseEl.value = rem;
            else baseEl.textContent = 'x' + rem;
            
            const scythedTable = document.getElementById('table-container-u_hierodule_scythed');
            if(scythedTable) scythedTable.style.opacity = rem > 0 ? '1' : '0.5';
            
            inputs.forEach(inp => {
                const id = inp.getAttribute('data-upid');
                const table = document.getElementById('table-container-' + id);
                if(table) table.style.opacity = Number(inp.value||0) > 0 ? '1' : '0.5';
            });

            const btnDec = document.getElementById('btn-base-dec');
            if(btnDec){
                const isDisabled = (rem <= 0);
                btnDec.disabled = isDisabled;
                btnDec.style.opacity = isDisabled ? '0.5' : '1';
                btnDec.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
            }
            
            const btnInc = document.getElementById('btn-base-inc');
            if(btnInc){
                 const headerSum = document.getElementById('modal-unit-summary');
                 const max = headerSum ? Number(headerSum.getAttribute('data-max')||99) : 99;
                 const isMax = total >= max;
                 btnInc.disabled = isMax;
                 btnInc.style.opacity = isMax ? '0.5' : '1';
                 btnInc.style.cursor = isMax ? 'not-allowed' : 'pointer';
            }
        }
      };

    window.onModalUpgradeToggle = function(target){
        if(target && window._modalUnitRef && window._modalUnitRef.id === 'tyrannofex' && target.checked){
          const id = target.getAttribute('data-id');
          const swaps = ['u_tfex_swap_flesh', 'u_tfex_swap_acid'];
          if(swaps.includes(id)){
            const rupture = document.querySelector('.modal-weapon-checkbox[data-name="Rupture Cannon"]');
            if(rupture && rupture.checked) rupture.checked = false;
            swaps.forEach(otherId => {
              if(otherId !== id){
                const otherCb = document.querySelector(`.modal-upgrade-checkbox[data-id="${otherId}"]`);
                if(otherCb && otherCb.checked){
                  otherCb.checked = false;
                  const oInp = document.getElementById('upcnt-'+otherId);
                  if(oInp) oInp.value = 0;
                  const oRm = document.getElementById('uprm-'+otherId);
                  if(oRm) oRm.style.display = 'none';
                }
              }
            });
          }
        }
        updateModalTotals(); enforceWeaponConstraints(); 
      }
      function updateModalTotals(){

        const ptsEl = document.getElementById('modal-total-points');

        if(!ptsEl) return;

        const weBoxes = Array.from(document.querySelectorAll('.modal-weapon-checkbox'));
        const upBoxes = Array.from(document.querySelectorAll('.modal-upgrade-checkbox'));
        const psyBoxes = Array.from(document.querySelectorAll('.modal-psychic-checkbox'));
        const countInputs = Array.from(document.querySelectorAll('.modal-upgrade-count'));

        let total = 0;
        if(window.editContext){
             const {fIdx,section,sIdx,uIdx}=window.editContext;
             const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx];
             const unit=slot&&slot.units&&slot.units[uIdx];
             if(unit){
                 total = (UNIT_BASE[unit.id] && UNIT_BASE[unit.id].points) || 0;
             }
        }

        weBoxes.filter(b=>b.checked && b.closest('tr') && b.closest('tr').style.display !== 'none').forEach(b=>{

          const src = b.getAttribute('data-src');

          total += (WEAPON_LIBRARY[src] && WEAPON_LIBRARY[src].points) || 0;

        });

        upBoxes.filter(b=>b.checked).forEach(b=>{

          total += Number(b.getAttribute('data-points') || 0);

        });

        // Add BROOD_SIZE counts (paired with checkboxes)
        countInputs.forEach(inp=>{
          const id = inp.getAttribute('data-upid');
          const checked = upBoxes.some(b=>b.getAttribute('data-id')===id && b.checked);
          if(!checked) return;
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });
        // Add BROOD_SIZE counts from Unit size controls (no checkbox)
        countInputs.filter(inp=> (inp.getAttribute('data-type')||'')==='BROOD_SIZE').forEach(inp=>{
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const id = inp.getAttribute('data-upid') || (inp.id||'').replace('upcnt-','');
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });
        // Add per-model weapon swap counts (rows without data-upid)
        countInputs.filter(inp=>!inp.getAttribute('data-upid')).forEach(inp=>{
          const c = Number(inp.value || 0);
          const pp = Number(inp.getAttribute('data-points') || 0);
          total += c * pp;
          const id = (inp.id||'').replace('upcnt-','');
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });

        // Include special single-model upgrades
        const specialBoxes = Array.from(document.querySelectorAll('.modal-special-checkbox'));
        specialBoxes.filter(b=>b.checked).forEach(b=>{
          const id = b.getAttribute('data-id');
          const inp = document.getElementById('upcnt-'+id);
          const pp = Number((inp && inp.getAttribute('data-points')) || b.getAttribute('data-points') || 0);
          const c = Number((inp && inp.value) || 1);
          total += c * pp;
          const rm = document.getElementById('uprm-'+id);
          if(rm) rm.style.display = c>0 ? '' : 'none';
        });

        psyBoxes.filter(b=>b.checked).forEach(b=>{

          total += Number(b.getAttribute('data-points') || 0);

        });

        if(window.editContext){ const {fIdx,section,sIdx,uIdx}=window.editContext; const slot = (section==='special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx]; const unit = slot && slot.units && slot.units[uIdx]; if(unit){ const models = Number(unit.models || (UNIT_DEFAULT_MODELS[unit.id]||1)); const totalPts = unitPoints(unit); const root=document.getElementById('modal-root'); const lbl = root && root.querySelector('.modal-drawer #bsize-label'); if(lbl){ lbl.innerHTML = 'Unit size: ' + models + ' <span class="cost">' + totalPts + ' PTS</span>'; lbl.setAttribute('data-models', String(models)); }
          const sumEl = document.getElementById('modal-unit-summary'); if(sumEl){ const costEl=document.getElementById('modal-unit-cost'); if(costEl) costEl.textContent = totalPts + ' PTS'; const valBtn=document.getElementById('modal-unit-val'); if(valBtn){ if(valBtn.tagName==='SELECT') valBtn.value=String(models); else valBtn.textContent = String(models); } const incLbl=document.getElementById('modal-inc-label'); const baseM=(UNIT_DEFAULT_MODELS[unit.id]||1); if(incLbl) incLbl.textContent = 'Increase by: +' + Math.max(0, models - baseM); } const baseWeps = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base); baseWeps.forEach(bw=>{ const replacingRows = Array.from(document.querySelectorAll('.modal-upgrade-row')).filter(r => (r.getAttribute('data-replaces')||'').split(',').map(s=>s.trim()).includes(bw.name)); replacingRows.forEach(r=>{ const iid=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+iid); if(inp) inp.max = String(models); }); const sum = replacingRows.reduce((s,r)=>{ const id=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+id); if(inp) return s + Number(inp.value||0); const cb = r.querySelector('.modal-upgrade-checkbox'); return s + (cb && cb.checked ? 1 : 0); },0); const remain = Math.max(0, models - sum); const cb = Array.from(document.querySelectorAll('.modal-weapon-checkbox')).find(b=>b.getAttribute('data-name')===bw.name); if(cb){ cb.checked = remain>0; } const span = document.getElementById('base-rem-'+bw.id); if(span){ span.textContent = remain>0 ? `(x${remain})` : ''; } }); Array.from(document.querySelectorAll('.modal-upgrade-row')).filter(r=>{ const t=r.getAttribute('data-type')||''; return t.startsWith('WEAPON_SWAP'); }).forEach(r=>{ const iid=r.getAttribute('data-upgrade'); const inp=document.getElementById('upcnt-'+iid); if(inp) inp.max = String(models); }); } }

        if(window.editContext){ const {fIdx,section,sIdx,uIdx}=window.editContext; const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx]; const unit=slot&&slot.units&&slot.units[uIdx]; if(unit){ const bsize = (unit.upgrades||[]).find(u=> (u.type==='BROOD_SIZE' && String(u.id||'').startsWith('u_bsize_apply_')) ); if(bsize){ total += Number(bsize.points||0); } } }
        ptsEl.textContent = total + ' pts';
        try{ updateBroodSummary(); }catch(e){}
        try{ updateHieroduleVisuals(); }catch(e){}
      }
      function updateHieroduleVisuals(){
        const unit = window._modalUnitRef;
        if(!unit || !unit.id.includes('hierodule')) return;
        const variants = ['u_hierodule_barbed', 'u_hierodule_hive'];
        let variantSum = 0;
        variants.forEach(id => {
          const inp = document.getElementById('upcnt-'+id);
          if(inp) variantSum += Number(inp.value||0);
        });
        const baseCount = Math.max(0, (unit.models||1) - variantSum);
        const baseInp = document.getElementById('hierodule-base-count');
        if(baseInp) baseInp.value = baseCount;
      }
      function updateBroodSummary(){
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        const unit = slot && slot.units && slot.units[uIdx];
        const el = document.getElementById('bsize-summary'); if(!el || !unit) return;
        const baseNames = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base).map(w=>w.name);
        const rows = Array.from(document.querySelectorAll('.modal-upgrade-row')).filter(r=> baseNames.includes(r.getAttribute('data-replaces')||''));
        const items = rows.map(r=>{ const id=r.getAttribute('data-upgrade'); const cnt=Number((document.getElementById('upcnt-'+id)||{}).value||0); const grant=r.getAttribute('data-grants')||''; return {grant,cnt}; }).filter(i=>i.cnt>0);
        const def = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id]) || 1;
        const bInp = document.getElementById('upcnt-u_bsize_fallback_'+unit.id);
        const step = Number(bInp && bInp.getAttribute('data-step') || 1);
        const plus = Number(bInp && bInp.value || 0) * step;
        const models = Math.max(def + plus, Number(unit.models||def));
        const sum = items.reduce((s,i)=>s+i.cnt,0);
        const baseRemain = Math.max(0, models - sum);
        el.textContent = items.length ? `Replacements: ${items.map(i=> `${i.grant} x${i.cnt}`).join(', ')}  Base remaining: ${baseRemain}` : `Base remaining: ${baseRemain}`;
      }

      function bumpUpgradeCount(id, delta){
        const inp = document.getElementById('upcnt-'+id);
        if(!inp) return;
        const row = document.querySelector(`.modal-upgrade-row[data-upgrade="${id}"]`);
        let val = Number(inp.value || 0);
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        let unit = window._modalUnitRef || (slot && slot.units && slot.units[uIdx]);
        const def = unit ? ((UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id])||1) : 1;
        const bInp = unit ? document.getElementById('upcnt-u_bsize_fallback_'+unit.id) : null;
        const step = Number(bInp && bInp.getAttribute('data-step') || 1);
        const plus = Number(bInp && bInp.value || 0) * step;
        const lbl = document.getElementById('bsize-label');
        const lblAttr = lbl && lbl.getAttribute('data-models');
        const lblVal = lblAttr ? Number(lblAttr) : (lbl ? Number(((lbl.textContent||'').match(/\d+/)||[])[0]||def) : def);
        let models = unit ? Math.max(lblVal, def + plus, Number(unit.models||def)) : Math.max(lblVal, def + plus);
        const replaces = row ? (row.getAttribute('data-replaces') || '') : '';
        if(replaces === 'Hierophant Arm Weapon') models = 2;
        if(replaces){
          const peerRows = Array.from(document.querySelectorAll(`.modal-upgrade-row[data-replaces="${replaces}"]`));
          const peers = peerRows.map(r=>{ const iid = r.getAttribute('data-upgrade'); const i = document.getElementById('upcnt-'+iid); return { id: iid, val: Number(i && i.value || 0) }; });
          const sumOthers = peers.filter(p=>p.id!==id).reduce((s,p)=>s+p.val,0);
          let allowed = Math.max(0, models - sumOthers);
          val += delta;
          if(val < 0) val = 0;
          
          if(val > allowed){
             const deficit = val - allowed;
             let recovered = 0;
             for(const r of peerRows){
                if(recovered >= deficit) break;
                const pId = r.getAttribute('data-upgrade');
                if(pId === id) continue;
                const pInp = document.getElementById('upcnt-'+pId);
                if(!pInp) continue;
                let pVal = Number(pInp.value||0);
                if(pVal > 0){
                   const canTake = Math.min(pVal, deficit - recovered);
                   pVal -= canTake;
                   recovered += canTake;
                   pInp.value = String(pVal);
                   const pDisp = document.getElementById('upval-'+pId);
                   if(pDisp) pDisp.textContent = String(pVal);
                   const pRm = document.getElementById('uprm-'+pId);
                   if(pRm) pRm.style.display = pVal>0 ? '' : 'none';
                }
             }
             const newSumOthers = peerRows.filter(r=>r.getAttribute('data-upgrade')!==id).reduce((s,r)=>{
                 const i = document.getElementById('upcnt-'+r.getAttribute('data-upgrade'));
                 return s + Number(i && i.value || 0);
             }, 0);
             allowed = Math.max(0, models - newSumOthers);
          }

          if(val > allowed) val = allowed;
          inp.max = String(allowed);
        } else {
          let max = models;
          const typ = row ? (row.getAttribute('data-type')||'') : '';
          const name = row ? (row.getAttribute('data-name')||'') : '';
          if(typ==='MODEL_UPGRADE' && /broodlord/i.test(name)){
            const others = countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord');
            max = val>0 ? 1 : Math.max(0, 1 - others);
          } else if(typ==='MODEL_UPGRADE') {
            max = 1;
          }
          val += delta;
          if(val < 0) val = 0;
          if(val > max) val = max;
          inp.max = String(max);
        }
        inp.value = val;
        const disp = document.getElementById('upval-'+id);
        if(disp) disp.textContent = String(val);
        const rm = document.getElementById('uprm-'+id);
        if(rm) rm.style.display = val>0 ? '' : 'none';
        updateModalTotals(); try{ updateBroodSummary(); }catch(e){}
      }
      window.bumpUpgradeCount = bumpUpgradeCount;
      function onBroodSizeSelect(id, val, selId, selEl){
        const inp = document.getElementById('upcnt-'+id);
        if(!inp) return;
        const v = Number(val||0);
        inp.value = String(v);
        const {fIdx,section,sIdx,uIdx} = window.editContext || {};
        const slot = (section==='special') ? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]);
        const unit = slot && slot.units && slot.units[uIdx];
        if(unit){
          const def = (UNIT_DEFAULT_MODELS&&UNIT_DEFAULT_MODELS[unit.id])||1;
          const step = Number(inp.getAttribute('data-step')||1);
          const models = def + v*step;
          const container = (selEl && selEl.parentElement) || (inp && inp.parentElement);
          const lblEl = container ? container.querySelector('#bsize-label') : document.querySelector('.modal-drawer #bsize-label');
          if(lblEl){ const pts = unit ? unitPoints(unit) : ''; lblEl.innerHTML = pts!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts + ' PTS</span>') : ('Unit size: ' + models); lblEl.setAttribute('data-models', String(models)); } else { setModalUnitSizeLabel(models); }
          setTimeout(()=>{ const contLbl = (container && container.querySelector('#bsize-label')) || document.querySelector('.modal-drawer #bsize-label'); if(contLbl){ const pts2 = unit ? unitPoints(unit) : ''; contLbl.innerHTML = pts2!=='' ? ('Unit size: ' + models + ' <span class="cost">' + pts2 + ' PTS</span>') : ('Unit size: ' + models); contLbl.setAttribute('data-models', String(models)); } },0);
          const sel = selEl || document.getElementById(selId || 'bsize-select'); if(sel){ sel.value = String(v); sel.selectedIndex = Number(v); Array.from(sel.options).forEach(o=>{ o.selected = (o.value === String(v)); }); }
          unit.models = models;
          const swapRows = Array.from(document.querySelectorAll('.modal-upgrade-row[data-type="WEAPON_SWAP"]'));
          const groups = {};
          swapRows.forEach(r => {
              const rep = r.getAttribute('data-replaces') || '';
              if(!groups[rep]) groups[rep] = [];
              groups[rep].push(r);
          });
          Object.keys(groups).forEach(rep => {
              const rows = groups[rep];
              const inputs = rows.map(r => document.getElementById('upcnt-' + r.getAttribute('data-upgrade'))).filter(Boolean);
              inputs.forEach(inp => inp.max = String(models));
              let sum = inputs.reduce((s, inp) => s + Number(inp.value||0), 0);
              if(sum > models){
                  let over = sum - models;
                  for(const inp of inputs){
                      if(over <= 0) break;
                      const cur = Number(inp.value||0);
                      const dec = Math.min(cur, over);
                      inp.value = String(cur - dec);
                      const disp = document.getElementById('upval-' + inp.id.replace('upcnt-',''));
                      if(disp) disp.textContent = inp.value;
                      over -= dec;
                  }
              }
          });
        }
        updateModalTotals();
        try{ updateBroodSummary(); }catch(e){}
      }
      window.onBroodSizeSelect = onBroodSizeSelect;

      function applyModalUnitSize(){ if(!window.editContext) return; const {fIdx,section,sIdx,uIdx}=window.editContext; const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx]; const unit=slot&&slot.units&&slot.units[uIdx]; if(!unit) return; const input=document.getElementById('modal-models-input'); if(!input) return; let val=Number(input.value||0); const min=Number(input.getAttribute('min')||1); const max=Number(input.getAttribute('max')||val); const step=Number(input.getAttribute('step')||1); if(val<min) val=min; if(val>max) val=max; if(step>1){ const off=(val-min)%step; val=val-off; } unit.models=val; unit.baseModels=min; const inc=Math.max(0, Math.floor((val-min)/step)); const cost=(UNIT_BROOD_POINTS[unit.id]||0); const upId='u_bsize_apply_'+unit.id; unit.upgrades=(unit.upgrades||[]).filter(u=>u.id!==upId); if(inc>0){ unit.upgrades.push({ id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*step, maxModels: (UNIT_MAX_MODELS[unit.id]||max) }); } const sumEl=document.getElementById('modal-unit-summary'); if(sumEl){ sumEl.innerHTML='Unit size: '+unit.models+' <span class="cost">'+unitPoints(unit)+' PTS</span>'; } updateModalTotals(); try{ updateBroodSummary(); }catch(e){} }
      window.applyModalUnitSize = applyModalUnitSize;
      function updateBroodSizeUpgrade(unit){ const min=(UNIT_DEFAULT_MODELS[unit.id]||1); const max=(UNIT_MAX_MODELS[unit.id]||min); const step=(UNIT_BROOD_STEP[unit.id]||1); const inc=Math.max(0, Math.floor((Number(unit.models||min)-min)/step)); const cost=(UNIT_BROOD_POINTS[unit.id]||0); const upId='u_bsize_apply_'+unit.id; unit.upgrades=(unit.upgrades||[]).filter(u=>u.id!==upId); if(inc>0){ unit.upgrades.push({ id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*step, maxModels: max }); } }
      function headerModelBump(delta){ bumpHeaderUnit(delta, document.getElementById('modal-unit-summary')); }
      window.headerModelBump = headerModelBump;
      function bumpHeaderUnit(delta, el){ const cont = (el && (el.closest && el.closest('#modal-unit-summary'))) || document.getElementById('modal-unit-summary'); if(!cont) return; const unitId = cont.getAttribute('data-unit'); const min = Number(cont.getAttribute('data-min')||1); const max = Number(cont.getAttribute('data-max')||min); const step = Number(cont.getAttribute('data-step')||1); const ctx=window.editContext||{}; const {fIdx,section,sIdx,uIdx}=ctx; const slot=(section==='special')? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]); let unit = window._modalUnitRef || (slot&&slot.units&&slot.units[uIdx]); if(!unit || (unitId && unit.id!==unitId)) unit = slot && slot.units && slot.units[uIdx]; if(!unit) return; let cur = Number(unit.models || min); cur += delta * step; if(cur < min) cur = min; if(cur > max) cur = max; unit.models = cur; 
        const swapRows = Array.from(document.querySelectorAll('.modal-upgrade-row[data-type="WEAPON_SWAP"]'));
        const groups = {};
        swapRows.forEach(r => {
            const rep = r.getAttribute('data-replaces') || '';
            if(!groups[rep]) groups[rep] = [];
            groups[rep].push(r);
        });
        Object.keys(groups).forEach(rep => {
            const rows = groups[rep];
            const inputs = rows.map(r => document.getElementById('upcnt-' + r.getAttribute('data-upgrade'))).filter(Boolean);
            inputs.forEach(inp => inp.max = String(cur));
            let sum = inputs.reduce((s, inp) => s + Number(inp.value||0), 0);
            if(sum > cur){
                let over = sum - cur;
                for(const inp of inputs){
                    if(over <= 0) break;
                    const val = Number(inp.value||0);
                    const dec = Math.min(val, over);
                    inp.value = String(val - dec);
                    const disp = document.getElementById('upval-' + inp.id.replace('upcnt-',''));
                    if(disp) disp.textContent = inp.value;
                    over -= dec;
                }
            }
        });
        updateBroodSizeUpgrade(unit); const valBtn = document.getElementById('modal-unit-val'); if(valBtn){ if(valBtn.tagName==='SELECT'){ let opt = valBtn.querySelector('option[value="'+cur+'"]'); if(!opt){ opt=document.createElement('option'); opt.value=cur; opt.textContent=cur; valBtn.appendChild(opt); } valBtn.value=cur; } else valBtn.textContent = String(cur); } const costEl = document.getElementById('modal-unit-cost'); if(costEl) costEl.textContent = unitPoints(unit) + ' PTS'; scheduleUpdateTotals(); try{ updateBroodSummary(); }catch(e){} }
      function setUnitSize(val){ const cont = document.getElementById('modal-unit-summary'); if(!cont) return; const unitId = cont.getAttribute('data-unit'); const min = Number(cont.getAttribute('data-min')||1); const max = Number(cont.getAttribute('data-max')||min); if(val < min) val = min; if(val > max) val = max; const ctx=window.editContext||{}; const {fIdx,section,sIdx,uIdx}=ctx; const slot=(section==='special')? (armyFormations[fIdx]&&armyFormations[fIdx].special) : (armyFormations[fIdx]&&armyFormations[fIdx][section]&&armyFormations[fIdx][section][sIdx]); let unit = window._modalUnitRef || (slot&&slot.units&&slot.units[uIdx]); if(!unit || (unitId && unit.id!==unitId)) unit = slot && slot.units && slot.units[uIdx]; if(!unit) return; unit.models = val; 
        const swapRows = Array.from(document.querySelectorAll('.modal-upgrade-row[data-type="WEAPON_SWAP"]'));
        const groups = {};
        swapRows.forEach(r => {
            const rep = r.getAttribute('data-replaces') || '';
            if(!groups[rep]) groups[rep] = [];
            groups[rep].push(r);
        });
        Object.keys(groups).forEach(rep => {
            const rows = groups[rep];
            const inputs = rows.map(r => document.getElementById('upcnt-' + r.getAttribute('data-upgrade'))).filter(Boolean);
            inputs.forEach(inp => inp.max = String(val));
            let sum = inputs.reduce((s, inp) => s + Number(inp.value||0), 0);
            if(sum > val){
                let over = sum - val;
                for(const inp of inputs){
                    if(over <= 0) break;
                    const cur = Number(inp.value||0);
                    const dec = Math.min(cur, over);
                    inp.value = String(cur - dec);
                    const disp = document.getElementById('upval-' + inp.id.replace('upcnt-',''));
                    if(disp) disp.textContent = inp.value;
                    over -= dec;
                }
            }
        });
        updateBroodSizeUpgrade(unit); const valBtn = document.getElementById('modal-unit-val'); if(valBtn){ if(valBtn.tagName==='SELECT') valBtn.value=val; else valBtn.textContent = String(val); } const costEl = document.getElementById('modal-unit-cost'); if(costEl) costEl.textContent = unitPoints(unit) + ' PTS'; scheduleUpdateTotals(); try{ updateBroodSummary(); }catch(e){} }
      window.setUnitSize = setUnitSize;
      window.bumpHeaderUnit = bumpHeaderUnit;
      function onSpecialUpgradeToggle(id, checked){
        const inp = document.getElementById('upcnt-'+id);
        if(inp){ inp.value = checked ? 1 : 0; }
        const rm = document.getElementById('uprm-'+id);
        if(rm) rm.style.display = checked ? '' : 'none';
        const cb = document.querySelector('.modal-special-checkbox[data-id="'+id+'"]');
        if(cb){ cb.checked = checked; cb.style.display = checked ? 'none' : ''; }

        if(window._modalUnitRef && window._modalUnitRef.id === 'tyrannofex' && checked){
          const swaps = ['u_tfex_swap_flesh', 'u_tfex_swap_acid'];
          if(swaps.includes(id)){
            swaps.forEach(otherId => {
              if(otherId !== id){
                const otherCb = document.querySelector(`.modal-upgrade-checkbox[data-id="${otherId}"]`);
                if(otherCb && otherCb.checked){
                  otherCb.checked = false;
                  const oInp = document.getElementById('upcnt-'+otherId);
                  if(oInp) oInp.value = 0;
                  const oRm = document.getElementById('uprm-'+otherId);
                  if(oRm) oRm.style.display = 'none';
                }
              }
            });
          }
        }

        enforceWeaponConstraints();
        updateSpecialRulesBlock();
        scheduleUpdateTotals();
      }
      function updateSpecialRulesBlock(){
        const cont = document.getElementById('modal-special-rules');
        if(!cont || !window.editContext) return;
        const {fIdx,section,sIdx,uIdx}=window.editContext;
        const slot=(section==='special')?armyFormations[fIdx].special:armyFormations[fIdx][section][sIdx];
        const unit=slot&&slot.units&&slot.units[uIdx];
        if(!unit) return;
        const lib=currentLoadout(unit.id);
        const base=(lib.specialRules||[]);
        const dyn=[];
        const activeIds = Array.from(document.querySelectorAll('.modal-special-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id'))
          .concat(Array.from(document.querySelectorAll('.modal-upgrade-checkbox')).filter(cb=>cb.checked).map(cb=>cb.getAttribute('data-id')));
        activeIds.forEach(id=>{ const eff=UPGRADE_EFFECTS[id]; if(eff && (eff.rules||[]).length){ dyn.push(...eff.rules); } });
        const items=base.concat(dyn);
        cont.innerHTML = items.length ? items.map(r=>renderRuleText(r)).join('') : `<div class="muted small">No special rules listed</div>`;
      }



      function saveEditFromModal(){

        if(!editContext) return;

        const {fIdx,section,sIdx,uIdx} = editContext;

        const slot = (section === 'special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx];

        const unit = slot && slot.units && slot.units[uIdx];

        if(!unit) return;
        window._modalUnitRef = unit;
        window._modalUnitRef = unit;

        const weBoxes = Array.from(document.querySelectorAll('.modal-weapon-checkbox'));

        const chosenWeps = weBoxes.filter(b=>b.checked && b.closest('tr') && b.closest('tr').style.display !== 'none').map(b=>{

          const id = b.getAttribute('data-id'); const name = b.getAttribute('data-name'); const src = b.getAttribute('data-src'); const pts = Number(b.getAttribute('data-points')||0);

          return { id, name, src, points: pts };

        });

        const upBoxes = Array.from(document.querySelectorAll('.modal-upgrade-checkbox'));

        let chosenUps = upBoxes.filter(b=>b.checked).map(b=>{

          return { id: b.getAttribute('data-id'), name: b.getAttribute('data-name'), points: Number(b.getAttribute('data-points')||0), desc: b.getAttribute('data-desc')||'', type: b.getAttribute('data-type')||'', replaces: b.getAttribute('data-replaces')||'', grants: b.getAttribute('data-grants')||'', limit: b.getAttribute('data-limit')||'', detachmentSize: Number(b.getAttribute('data-detach')||0), maxModels: Number(b.getAttribute('data-maxmodels')||0) };

        });

        const psyBoxes = Array.from(document.querySelectorAll('.modal-psychic-checkbox'));

        const chosenPsy = psyBoxes.filter(b=>b.checked).map(b=>{

          return { id: b.getAttribute('data-id'), name: b.getAttribute('data-name'), points: Number(b.getAttribute('data-points')||0), desc: b.getAttribute('data-desc')||'' };

        });

        // Read upgrade counts directly from rows and merge into selected upgrades
        const upCounts = Array.from(document.querySelectorAll('.modal-upgrade-count'));
        const countedUps = upCounts.map(inp=>{
          const id = inp.id.replace('upcnt-','');
          const row = document.querySelector(`.modal-upgrade-row[data-upgrade="${id}"]`);
          const scb = document.querySelector(`.modal-special-checkbox[data-id="${id}"]`);
          const cnt = Number(inp.value||0);
          const base = Number(inp.getAttribute('data-points')||0);
          const name = row ? (row.getAttribute('data-name') || row.querySelector('strong')?.textContent || '') : (scb ? (scb.getAttribute('data-name') || '') : (inp.getAttribute('data-name') || ''));
          const type = row ? (row.getAttribute('data-type') || '') : (scb ? (scb.getAttribute('data-type') || '') : (inp.getAttribute('data-type') || ''));
          const replaces = row ? (row.getAttribute('data-replaces') || '') : (inp.getAttribute('data-replaces') || '');
          const grants = row ? (row.getAttribute('data-grants') || '') : (inp.getAttribute('data-grants') || '');
          const detach = row ? Number(row.getAttribute('data-detach')||0) : Number(inp.getAttribute('data-detach')||0);
          const obj = { id, name, points: base * cnt, desc: '', type, replaces, grants, limit:'', detachmentSize: detach, count: cnt };
          if(type==='BROOD_SIZE'){
             const step = Number(inp.getAttribute('data-step') || (UNIT_BROOD_STEP && UNIT_BROOD_STEP[unit.id]) || 1);
             obj.modelsDeltaTotal = step * cnt;
             
             // Try to find existing maxModels from checkbox
             const cb = document.querySelector(`.modal-upgrade-checkbox[data-id="${id}"]`);
             const explicitMax = cb ? Number(cb.getAttribute('data-maxmodels')||0) : 0;
             
             obj.maxModels = explicitMax || ((UNIT_MAX_MODELS && UNIT_MAX_MODELS[unit.id]) || 0); 
          }
          return obj;
        }).filter(u=>u.count>0);
        // merge countedUps into chosenUps (override points/count/models delta)
        countedUps.forEach(cu=>{
          const idx = chosenUps.findIndex(u=>u.id===cu.id);
          if(idx>-1){
            chosenUps[idx] = { ...chosenUps[idx], points: cu.points, count: cu.count, modelsDeltaTotal: cu.modelsDeltaTotal, maxModels: cu.maxModels };
          } else {
            chosenUps.push(cu);
          }
        });

        const mInput = document.getElementById('modal-models-input');
        if(mInput){ let val = Number(mInput.value||0); const min = Number(mInput.getAttribute('min')||1); const max = Number(mInput.getAttribute('max')||val); const step = Number(mInput.getAttribute('step')||1); if(val<min) val=min; if(val>max) val=max; if(step>1){ const offset = (val - min) % step; val = val - offset; } unit.models = val; unit.baseModels = unit.baseModels || min; } else {
          const baseM = (UNIT_DEFAULT_MODELS[unit.id]||unit.baseModels||1);
          const explicitBrood = chosenUps.filter(u=>u.type==='BROOD_SIZE' && !u.id.startsWith('u_bsize_apply_'));

          if(explicitBrood.length > 0){
             let delta = 0;
             explicitBrood.forEach(u => delta += (u.modelsDeltaTotal||0));
             unit.models = baseM + delta;
          } else {
             const stepM = (UNIT_BROOD_STEP[unit.id]||1);
             const maxM = (UNIT_MAX_MODELS[unit.id]||baseM);
             let curM = Number(unit.models||baseM);
             if(curM<baseM) curM=baseM; if(curM>maxM) curM=maxM;
             unit.models = curM;
             const inc = Math.max(0, Math.floor((curM - baseM)/stepM));
             const cost = (UNIT_BROOD_POINTS[unit.id]||0);
             const upId = 'u_bsize_apply_'+unit.id;
             const entry = { id: upId, name:'Brood size', points: inc*cost, type:'BROOD_SIZE', count: inc, modelsDeltaTotal: inc*stepM, maxModels: maxM };
             const idx = chosenUps.findIndex(u=>u.id===upId);
             if(idx>-1){ chosenUps[idx] = entry; } else if(inc>0){ chosenUps.push(entry); }
          }
        }

        let weapons;
        const isBrood = (unit.models||1) > 1;
        if(isBrood){
          const baseWeps = (currentLoadout(unit.id).weapons||[]).filter(w=>w.base);
          const grouped = {};
          chosenUps.filter(u=> (u.type==='WEAPON_SWAP' || u.type==='WEAPON_SWAP_LIMITED') && u.replaces).forEach(u=>{ 
            const keys = u.replaces.split(',').map(s=>s.trim());
            keys.forEach(k=>{ grouped[k]=grouped[k]||[]; grouped[k].push(u); });
          });
          weapons = [];
          baseWeps.forEach(bw=>{ const ups = grouped[bw.name]||[]; let remaining = unit.models||1; ups.forEach(u=>{ const c = Math.max(0, Math.min(remaining, Number(u.count||0))); u.count = c; remaining -= c; if(u.grants && c>0 && !u._grantAdded){ u._grantAdded=true; const gList = u.grants.split(',').map(s=>s.trim()); gList.forEach((gName,gi)=>{ const label = c>1 ? `${gName} (x${c})` : gName; weapons.push({ id:'auto_'+u.id+'_'+gi, name: label, src:gName, points: 0 }); }); } }); const baseCount = Math.max(0, remaining); if(baseCount>0){ const baseLabel = baseCount>1 ? `${bw.name} (x${baseCount})` : bw.name; weapons.push({ id: bw.id, name: baseLabel, src: bw.src, points: 0 }); } });
          
          chosenUps.forEach(u => {
            if((u.type==='WEAPON_SWAP' || u.type==='WEAPON_SWAP_LIMITED') && !u.replaces && u.grants && !u._grantAdded){
               const c = (u.count !== undefined) ? u.count : (unit.models||1);
               if(c > 0){
                 u._grantAdded = true;
                 const gList = u.grants.split(',').map(s=>s.trim());
                 gList.forEach((gName, gi) => {
                   const gLabel = c > 1 ? `${gName} (x${c})` : gName;
                   weapons.push({ id:'auto_'+u.id+'_'+gi, name: gLabel, src:gName, points: 0 });
                 });
               }
            }
          });
        } else {
          weapons = chosenWeps.slice();
          chosenUps.forEach(u=>{ 
            if(u.type==='WEAPON_SWAP' || u.type==='WEAPON_SWAP_LIMITED'){ 
              if(u.replaces){ 
                const rList=u.replaces.split(',').map(s=>s.trim()); 
                weapons = weapons.filter(w=>!rList.includes(w.name)); 
              } 
              if(u.grants){ 
                const gList = u.grants.split(',').map(s=>s.trim());
                gList.forEach((gName, gi) => {
                  const label = u.count && u.count>1 ? `${gName} (x${u.count})` : gName;
                  weapons.push({ id:'auto_'+u.id+'_'+gi, name: label, src:gName, points: 0 });
                });
              } 
            } 
          });
        }
        weapons = filterWepsByConstraints(unit.id, weapons, chosenUps);

        unit.weapons = weapons;
        unit.upgrades = chosenUps;
        unit.psychic = chosenPsy;

        const hasSwarm = chosenUps.some(u=>u.id === 'u_swarm');

        if(hasSwarm){

          unit._appliedEffects = unit._appliedEffects || {};

          unit._appliedEffects.swarmLord = { CAF: '+14', Wounds: 3, note: 'Swarm Lord applied: CAF +14; Wounds = 3; Venom/Barbed removed.' };

          unit.weapons = (unit.weapons||[]).filter(w => !['Venom Cannon','Barbed Strangler'].includes(w.name));

          unit.notes = unit.notes || [];

          if(!unit.notes.find(n=>n.startsWith('Swarm Lord:'))) unit.notes.push('Swarm Lord applied: CAF +14; Wounds = 3; Venom/Barbed removed.');

        } else {

          if(unit._appliedEffects && unit._appliedEffects.swarmLord) delete unit._appliedEffects.swarmLord;

          unit.notes = (unit.notes||[]).filter(n=>!n.startsWith('Swarm Lord:'));

        }

        closeModal();

        renderContent();
        saveState();

      }



      function renderModal(){
        window._modalUnitRef = null;
        const root = document.getElementById('modal-root'); window._lastFocused = document.activeElement; root.innerHTML = ''; if(!editContext) return;

        const {fIdx,section,sIdx,uIdx} = editContext;

        const slot = (section === 'special') ? armyFormations[fIdx].special : armyFormations[fIdx][section][sIdx];

        const unit = slot && slot.units && slot.units[uIdx];

        if(!unit) return;
        window._modalUnitRef = unit;

        if(unit.id === 'tyranid-warrior'){ }

        const needBrood = false;

        const lib = currentLoadout(unit.id);

        const instanceWeaponIds = (unit.weapons||[]).map(w=>w.id);

        const instanceUpgradeIds = (unit.upgrades||[]).map(u=>u.id);

        const initialHasSwarm = instanceUpgradeIds.includes('u_swarm') || (unit._appliedEffects && unit._appliedEffects.swarmLord);



        const weaponsHtml = (lib.weapons||[]).map(w=>{

          const stat = WEAPON_LIBRARY[w.src] || {};

          const checked = instanceWeaponIds.includes(w.id) || (w.base && instanceWeaponIds.length===0);

          const pts = stat.points || 0;

          const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td><td class="cost">${pts} pts</td>`;

          const display = initialHasSwarm && (w.name === 'Venom Cannon' || w.name === 'Barbed Strangler') ? 'style="display:none"' : '';

          return `<tr class="modal-weapon-row" data-weapon="${w.name}" ${display}><td style="width:auto"><label style="display:flex;gap:8px;align-items:center"><input type="checkbox" class="modal-weapon-checkbox" data-id="${w.id}" data-name="${w.name}" data-src="${w.src}" data-points="${pts}" data-base="${w.base}" ${checked ? 'checked' : ''}/> ${w.name}${w.base && (unit.models||1)>1 ? ' <span id="base-rem-'+w.id+'" class="muted small"></span>' : ''}</label></td>${statCols}</tr>`;

        }).join('');



        const upgradesHtml = (lib.upgrades||[]).filter(u => !((u.type||'').startsWith('WEAPON') && u.grants && WEAPON_LIBRARY[u.grants])).map(u=>{

          const checked = instanceUpgradeIds.includes(u.id) || (unit._appliedEffects && unit._appliedEffects.swarmLord && u.id === 'u_swarm');
          const limitModels = (unit.models || u.detachmentSize || 0);
          const isLimited = (u.type === 'WEAPON_SWAP_LIMITED');
          const meetsLimit = !isLimited || (Math.floor(limitModels / 3) >= 1);
          const disabledAttr = meetsLimit ? '' : 'disabled';
          const hint = isLimited ? `<div class="muted small" style="margin-top:4px">Limit: 1 per 3 models${meetsLimit?'':'  requires at least 3 models'}</div>` : '';
          const bsizeHint = u.type==='BROOD_SIZE' ? `<div class="muted small" style="margin-top:4px">Models: ${(unit.models||unit.baseModels||3)}  ${(unit.models||unit.baseModels||3)+(u.modelsDelta||0)}${u.maxModels? ' (max '+u.maxModels+')':''}</div>` : '';

          const baseM = unit.baseModels || ((UNIT_DEFAULT_MODELS && UNIT_DEFAULT_MODELS[unit.id]) || 1);
          const stepM = u.type==='BROOD_SIZE' ? (u.modelsDelta || ((UNIT_BROOD_STEP && UNIT_BROOD_STEP[unit.id]) || 1)) : 1;
          const maxM = u.type==='BROOD_SIZE' ? (u.maxModels || ((UNIT_MAX_MODELS && UNIT_MAX_MODELS[unit.id]) || baseM)) : baseM;
          const count = u.type==='BROOD_SIZE' ? Math.max(0, Math.floor(((unit.models||baseM) - baseM) / stepM)) : 0;
          const maxCount = u.type==='BROOD_SIZE' ? Math.max(0, Math.floor((maxM - baseM) / stepM)) : 0;
          const control = u.type==='BROOD_SIZE' ? `<div style="margin-top:6px;display:flex;gap:6px;align-items:center"><button class="btn btn-xs btn-green" onclick="window.bumpUpgradeCount('${u.id}',1)">+ ${stepM} models (+${u.points||0} pts)</button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${u.points||0}" data-upid="${u.id}" data-step="${stepM}" style="width:0;opacity:0;pointer-events:none"/><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()"></button></div>` : '';

          return `<div class="modal-upgrade-row" data-upgrade="${u.id}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-detach="${u.detachmentSize||0}" style="margin-bottom:8px"><label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-upgrade-checkbox" data-id="${u.id}" data-name="${u.name}" data-points="${u.points}" data-desc="${u.desc||''}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-limit="${u.limit||''}" data-detach="${u.detachmentSize||''}" data-maxmodels="${u.maxModels||''}" ${checked ? 'checked' : ''} ${disabledAttr} onchange="onModalUpgradeToggle(this)"/><div><strong>${u.name}</strong> <span class="muted">(+${u.points} pts)</span><div class="muted" style="margin-top:6px">${u.desc||''}</div>${hint}${bsizeHint}${control}</div></label></div>`;

        }).join('');
        const tableUps = (lib.upgrades||[]).filter(u => (u.type||'').startsWith('WEAPON') && u.grants && !unit.id.includes('hierodule') && !unit.id.includes('hierophant'));
        const tableUpIds = new Set(tableUps.map(u=>u.id));
        const tableUpGrants = new Set((lib.weapons||[]).map(w=>String(w.name||'').toLowerCase()));
        let hieroduleHtml = '';
        let upgradesRowsHtml = tableUps.map(u=>{
          const current = (unit.upgrades||[]).find(x=>x.id===u.id);
          const count = current && current.count ? Number(current.count) : 0;
          const per = (u.type==='WEAPON_SWAP_LIMITED' && (u.detachmentSize||3)) || null;
          let maxCount = u.type==='MODEL_UPGRADE' ? 1 : (per ? Math.floor((unit.models||per)/per) : (u.type==='WEAPON_SWAP'? (unit.models||1) : (u.type==='BROOD_SIZE'? Math.max(0, Math.floor(((UNIT_MAX_MODELS[unit.id]||0)-(UNIT_DEFAULT_MODELS[unit.id]||0)) / (UNIT_BROOD_STEP[unit.id]||1))) : 0)));
          const isBroodlord = /broodlord/i.test(u.name||'');
          if(isBroodlord){ const others = countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord'); maxCount = count>0 ? 1 : Math.max(0, 1 - others); }
          
          const grantList = String(u.grants||'').split(',').map(s=>s.trim()).filter(Boolean);
          if(!grantList.length) return '';

          const basePts = u.type==='BROOD_SIZE' ? (UNIT_BROOD_POINTS[unit.id]??(u.points||0)) : (u.points||0);
          
          return grantList.map((gName, gIdx) => {
             const stat = WEAPON_LIBRARY[gName] || {};
             const grantKey = gName.toLowerCase();
             if(tableUpGrants.has(grantKey)) return ''; // Skip if already present? But if it's the first one, we lose the checkbox? 
             // Ideally we shouldn't grant things that are already there. 
             // If we must, we should still render the control row but maybe empty stats?
             // For now assume no conflicts for new units.
             tableUpGrants.add(grantKey);

             const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
             
             let nameCell;
             if(gIdx === 0){
                 // Render Control
                  const control = u.type==='BROOD_SIZE'
                    ? `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs btn-green" onclick="window.bumpUpgradeCount('${u.id}',1)">+ ${(UNIT_BROOD_STEP[unit.id]||1)} models (+${UNIT_BROOD_POINTS[unit.id]??(u.points||0)} pts)</button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${UNIT_BROOD_POINTS[unit.id]??(u.points||0)}" style="width:0;opacity:0;pointer-events:none"/><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()"></button></div>`
                    : (u.replaces ? 
                        `<div style="display:none"><input id="upcnt-${u.id}" class="modal-upgrade-count" type="number" value="${count}" data-points="${u.points||0}"/></div>` 
                        : `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${u.id}',-1)"></button><button id="upval-${u.id}" class="btn btn-xs" style="width:28px;justify-content:center">${count}</button><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCount}" step="1" value="${count}" data-points="${u.points||0}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${u.id}',1)" ${count>=maxCount ? 'disabled' : ''}>+</button><button id="uprm-${u.id}" class="btn btn-xs btn-red" style="display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; document.getElementById('upval-${u.id}').textContent='0'; updateModalTotals()"></button></div>`
                      );
                  
                  const displayName = (u.grants||'') || (u.name||'').replace(/^Replace\s+.*\s+with\s+/,'');
                  // Use grantList[0] for display name if implicit? 
                  // If multiple grants, displayName usually includes both? u.grants is the raw string.
                  // u.name usually "Swap A for B".
                  // Let's use u.name if available, or list.
                  
                  const displayModelName = (u.type==='MODEL_UPGRADE') ? (String(u.name||'').replace(/^Replace\s+.*\s+with\s+/,'').replace(/\(Model Upgrade\)/i,'').trim() || 'Upgrade') : (u.name || u.grants);

                  if(u.replaces){
                     const checked = count > 0;
                     nameCell = `<td><label style="display:flex;gap:8px;align-items:center"><input type="checkbox" class="modal-upgrade-checkbox" data-id="${u.id}" data-name="${u.name}" data-points="${u.points}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" ${checked ? 'checked' : ''} onchange="onModalUpgradeToggle(this)"/> ${displayModelName}</label><div class="small muted">${u.limit||''}</div></td>`;
                  } else {
                     nameCell = `<td><div style="font-weight:600">${displayModelName}</div><div class="small muted">${u.limit||''}</div>${control}</td>`;
                  }
                  return `<tr class="modal-upgrade-row" data-upgrade="${u.id}" data-type="${u.type||''}" data-replaces="${u.replaces||''}" data-grants="${u.grants||''}" data-detach="${u.detachmentSize||0}" data-name="${u.name}">${nameCell}${statCols}<td class="cost" rowspan="${grantList.length}">${(count>0? (count*basePts) : basePts)} pts</td></tr>`;
             } else {
                 // Secondary grant
                 return `<tr class="modal-upgrade-row" data-upgrade="${u.id}" data-sub="${gName}"><td><div style="padding-left:24px;font-weight:600;font-size:0.9em">${gName}</div></td>${statCols}<td style="display:none"></td></tr>`;
             }
          }).join('');
        }).join('');
        if(!upgradesRowsHtml){
          const defM = (UNIT_DEFAULT_MODELS[unit.id]||1), maxM=(UNIT_MAX_MODELS[unit.id]||defM), stepM=(UNIT_BROOD_STEP[unit.id]||0);

          if(unit.id==='termagant'){
            const entries = [
              {id:'u_fb_strangle', name:'Replace Fleshborer with Stranglewebs', pts:3, grants:'Stranglewebs'},
              {id:'u_fb_dev', name:'Replace Fleshborer with Devourer', pts:1, grants:'Devourer'}
            ];
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            entries.forEach(e=>{
              const stat = WEAPON_LIBRARY[e.grants] || {};
              const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
              const maxCnt = (unit.models||defM2);
              const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',-1)"></button><button id="upval-${e.id}" class="btn btn-xs" style="width:28px;justify-content:center">0</button><input id="upcnt-${e.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="0" data-points="${e.pts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',1)">+</button><button id="uprm-${e.id}" class="btn btn-xs btn-red" style="display:none" onclick="document.getElementById('upcnt-${e.id}').value=0; document.getElementById('upval-${e.id}').textContent='0'; updateModalTotals()"></button></div>`;
              const nameCell = `<td><div style="font-weight:600">${e.grants}</div>${control}</td>`;
              upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${e.id}" data-type="WEAPON_SWAP" data-replaces="Fleshborer" data-grants="${e.grants}" data-detach="0" data-name="${e.name}">${nameCell}${statCols}<td class="cost">${e.pts} pts</td></tr>`;
              tableUpGrants.add(String(e.grants||'').toLowerCase());
            });
          } else if(unit.id==='carnifex'){
            const entries = [
              {id:'u_carn_bs', name:'Replace Bio-Plasma with Barbed Strangler', pts:5, grants:'Barbed Strangler'},
              {id:'u_carn_vc', name:'Replace Bio-Plasma with Venom Cannon', pts:5, grants:'Venom Cannon'}
            ];
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            const maxCnt = (unit.models||defM2);
            entries.forEach(e=>{
              const stat = WEAPON_LIBRARY[e.grants] || {};
              const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
              
              const existing = (unit.upgrades||[]).find(x=>x.id===e.id);
              const curCount = existing ? Number(existing.count||0) : 0;
              
              const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',-1)"></button><button id="upval-${e.id}" class="btn btn-xs" style="width:28px;justify-content:center">${curCount}</button><input id="upcnt-${e.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="${curCount}" data-points="${e.pts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',1)">+</button><button id="uprm-${e.id}" class="btn btn-xs btn-red" style="display:${curCount>0?'':'none'}" onclick="document.getElementById('upcnt-${e.id}').value=0; document.getElementById('upval-${e.id}').textContent='0'; updateModalTotals()"></button></div>`;
              const nameCell = `<td><div style="font-weight:600">${e.grants}</div>${control}</td>`;
              upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${e.id}" data-type="WEAPON_SWAP" data-replaces="Bio-Plasma" data-grants="${e.grants}" data-detach="0" data-name="${e.name}">${nameCell}${statCols}<td class="cost">${curCount>0 ? curCount*e.pts : e.pts} pts</td></tr>`;
              tableUpGrants.add(String(e.grants||'').toLowerCase());
            });
          } else if(unit.id==='biovore'){
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            const baseModels = unit.models || defM2;
            const pyroBase = (lib.upgrades||[]).find(x=>/pyrovor/i.test(String(x.name||'')));
            const pyroId = pyroBase ? pyroBase.id : 'u_biovore_pyro';
            const pyroPts = pyroBase ? (pyroBase.points||0) : 0;
            const pyroDet = pyroBase ? (pyroBase.detachmentSize||0) : 0;
            const stat = WEAPON_LIBRARY['Pyroacid Launcher'] || {};
            const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
            const maxCnt = baseModels;
            let curCount = 0;
            const existing = (unit.upgrades||[]).find(x=>x.id===pyroId);
            if(existing){
              const stored = Number(existing.count||0);
              curCount = stored>0 ? Math.min(maxCnt, stored) : maxCnt;
            }
            const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${pyroId}',-1)"></button><button id="upval-${pyroId}" class="btn btn-xs" style="width:28px;justify-content:center">${curCount}</button><input id="upcnt-${pyroId}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="${curCount}" data-points="${pyroPts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${pyroId}',1)">+</button><button id="uprm-${pyroId}" class="btn btn-xs btn-red" style="display:${curCount>0?'':'none'}" onclick="document.getElementById('upcnt-${pyroId}').value=0; document.getElementById('upval-${pyroId}').textContent='0'; updateModalTotals()"></button></div>`;
            const nameCell = `<td><div style="font-weight:600">Pyrovore (Pyroacid Launcher)</div><div class="small muted">Each Pyrovore has CAF +4 (Biovore CAF 0).</div>${control}</td>`;
            upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${pyroId}" data-type="WEAPON_SWAP" data-replaces="Spore Launcher" data-grants="Pyroacid Launcher" data-detach="${pyroDet}" data-name="${pyroBase?pyroBase.name:'Pyrovore'}">${nameCell}${statCols}<td class="cost">${pyroPts} pts</td></tr>`;
            tableUpGrants.add('pyroacid launcher');
          } else if(unit.id==='gargoyle'){
            const entries = [
              {id:'u_flamespurt', name:'Replace Fleshborer with Flamespurt', pts:1, grants:'Flamespurt'}
            ];
            const defM2 = (UNIT_DEFAULT_MODELS[unit.id]||1);
            const maxCnt = (unit.models||defM2);
            entries.forEach(e=>{
              const stat = WEAPON_LIBRARY[e.grants] || {};
              const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
              
              const existing = (unit.upgrades||[]).find(x=>x.id===e.id);
              const curCount = existing ? Number(existing.count||0) : 0;
              
              const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',-1)"></button><button id="upval-${e.id}" class="btn btn-xs" style="width:28px;justify-content:center">${curCount}</button><input id="upcnt-${e.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="${curCount}" data-points="${e.pts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',1)">+</button><button id="uprm-${e.id}" class="btn btn-xs btn-red" style="display:${curCount>0?'':'none'}" onclick="document.getElementById('upcnt-${e.id}').value=0; document.getElementById('upval-${e.id}').textContent='0'; updateModalTotals()"></button></div>`;
              const nameCell = `<td><div style="font-weight:600">${e.grants}</div>${control}</td>`;
              upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${e.id}" data-type="WEAPON_SWAP" data-replaces="Fleshborer" data-grants="${e.grants}" data-detach="0" data-name="${e.name}">${nameCell}${statCols}<td class="cost">${curCount>0 ? curCount*e.pts : e.pts} pts</td></tr>`;
              tableUpGrants.add(String(e.grants||'').toLowerCase());
            });
          } else if(unit.id.includes('hierophant')){
             const entries = [
               {id:'u_hiero_bc', name:'Bio-Cannon (Hierophant)', pts:0, grants:'Bio-Cannon (Hierophant)'},
               {id:'u_hiero_rc', name:'Razor Claws (Hierophant)', pts:0, grants:'Razor Claws (Hierophant)'},
               {id:'u_hiero_bl', name:'Bile Launcher', pts:0, grants:'Bile Launcher'},
               {id:'u_hiero_ps', name:'Pyro-Acid Spray', pts:0, grants:'Pyro-Acid Spray'}
             ];
             const maxCnt = 2; 
             entries.forEach(e=>{
               const stat = WEAPON_LIBRARY[e.grants] || {};
               const statCols = `<td>${stat.range||'-'}</td><td>${stat.dice||'-'}</td><td>${stat.toHit||'-'}</td><td>${stat.AP===undefined?'-':stat.AP}</td><td>${renderTraitsCell(stat.traits)}</td>`;
               
               const existing = (unit.upgrades||[]).find(x=>x.id===e.id);
               const curCount = existing ? Number(existing.count||0) : 0;
               
               const control = `<div style="display:flex;gap:6px;align-items:center"><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',-1)"></button><button id="upval-${e.id}" class="btn btn-xs" style="width:28px;justify-content:center">${curCount}</button><input id="upcnt-${e.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="${maxCnt}" step="1" value="${curCount}" data-points="${e.pts}" style="width:0;opacity:0;pointer-events:none"/><button class="btn btn-xs" onclick="window.bumpUpgradeCount('${e.id}',1)">+</button><button id="uprm-${e.id}" class="btn btn-xs btn-red" style="display:${curCount>0?'':'none'}" onclick="document.getElementById('upcnt-${e.id}').value=0; document.getElementById('upval-${e.id}').textContent='0'; updateModalTotals()"></button></div>`;
               
               const nameCell = `<td><div style="font-weight:600">${e.name}</div>${control}</td>`;
               upgradesRowsHtml += `<tr class="modal-upgrade-row" data-upgrade="${e.id}" data-type="WEAPON_SWAP" data-replaces="Hierophant Arm Weapon" data-grants="${e.grants}" data-detach="0" data-name="${e.name}">${nameCell}${statCols}<td class="cost">${e.pts} pts</td></tr>`;
               tableUpGrants.add(String(e.grants||'').toLowerCase());
             });
          } else if(unit.id.includes('hierodule')){
            const variants = [
              {id:'u_hierodule_scythed', name:'Scythed Variant', isBase:true, grants:['Razor Claws (Hierodule)','Spore Pods','Stinger Salvo']},
              {id:'u_hierodule_barbed', name:'Barbed Variant', grants:['Bio-Cannon (Hierodule)','Stinger Salvo']},
              {id:'u_hierodule_hive', name:'Hive Variant', grants:['Ripper Tentacles','Pyro-Acid Spray','Stinger Salvo']}
            ];
            
            hieroduleHtml = variants.map(v => {
               const rows = v.grants.map(gName => {
                const stat = WEAPON_LIBRARY[gName] || {};
                const statCols = `<td style="color:#fff">${stat.range||'-'}</td><td style="color:#fff">${stat.dice||'-'}</td><td style="color:#fff">${stat.toHit||'-'}</td><td style="color:#fff">${stat.AP===undefined?'-':stat.AP}</td><td style="color:#fff">${renderTraitsCell(stat.traits)}</td>`;
                return `<tr><td><div style="font-weight:600;font-size:0.9em;color:#fff">${gName}</div></td>${statCols}</tr>`;
              }).join('');
              
              let control = '';
              if(v.isBase){
                  control = `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <span style="font-weight:700;font-size:1.1em;color:#fff">${v.name} (Base)</span>
                    <div style="display:flex;align-items:center;gap:8px">
                        <button id="btn-base-dec" class="btn btn-xs" onclick="window.headerModelBump(-1)" style="width:30px;height:30px;font-weight:bold">-</button>
                        <input id="hierodule-base-count" class="modal-upgrade-count mini-input" type="text" value="1" readonly style="width:40px;text-align:center;background:#222;color:#fff;border:1px solid #555;height:30px">
                        <button id="btn-base-inc" class="btn btn-xs" onclick="window.headerModelBump(1)" style="width:30px;height:30px;font-weight:bold">+</button>
                    </div>
                  </div>`;
              } else {
                  const current = (unit.upgrades||[]).find(x=>x.id===v.id);
                  const count = current ? Number(current.count||0) : 0;
                  control = `<div class="modal-upgrade-row" data-upgrade="${v.id}" data-replaces="razor_claws_hierodule" data-type="WEAPON_SWAP" data-name="${v.name}" style="margin-bottom:8px">
                    <div style="display:flex;justify-content:space-between;align-items:center">
                       <span style="font-weight:700;font-size:1.1em;color:#fff">${v.name}</span>
                       <div style="display:flex;align-items:center;gap:8px">
                         <button class="btn btn-xs" onclick="bumpUpgradeCount('${v.id}', -1)" style="width:30px;height:30px;font-weight:bold">-</button>
                         <input id="upcnt-${v.id}" class="modal-upgrade-count mini-input" type="number" value="${count}" min="0" data-points="0" data-upid="${v.id}" readonly style="width:40px;text-align:center;background:#222;color:#fff;border:1px solid #555;height:30px">
                         <button class="btn btn-xs" onclick="bumpUpgradeCount('${v.id}', 1)" style="width:30px;height:30px;font-weight:bold">+</button>
                       </div>
                    </div>
                  </div>`;
              }

              return `<div id="card-${v.id}" class="hierodule-variant-card" style="border:1px solid #444; background:#222; margin-bottom:10px; padding:10px; border-radius:6px;">
                ${control}
                <div id="table-container-${v.id}" style="transition: opacity 0.3s ease;">
                    <table class="table table-sm table-striped" style="margin:0; background:transparent; color:#fff;">
                      <thead><tr><th style="color:#fff">Weapon</th><th style="color:#fff">Range</th><th style="color:#fff">Dice</th><th style="color:#fff">To Hit</th><th style="color:#fff">AP</th><th style="color:#fff">Traits</th></tr></thead>
                      <tbody>${rows}</tbody>
                    </table>
                </div>
              </div>`;
            }).join('');
          }
        }



        const specialUps = (lib.upgrades||[]).filter(u => {
          const t = String(u.type||'');
          const nameLc = String(u.name||'').toLowerCase();
          const grantLc = String(u.grants||'').toLowerCase();
          if(unit.id==='biovore' && /pyrovor/i.test(nameLc)) return false;
          const isReplace = nameLc.includes('replace');
          const overlapsGrant = (grantLc && tableUpGrants.has(grantLc)) || Array.from(tableUpGrants).some(g=> nameLc.includes(g));
          const weaponLike = t.startsWith('WEAPON') || t==='MODEL_UPGRADE';
          const isBroodSizeName = /increase\s+brood\s+size/i.test(nameLc);
          const isDuplicateBroodlord = /replace\s+one\s+genestealer\s+w\/\s+broodlord/i.test(nameLc);
          return !(
            t.startsWith('WEAPON') || u.type==='BROOD_SIZE' || isBroodSizeName || isDuplicateBroodlord || tableUpIds.has(u.id) || (weaponLike && isReplace && overlapsGrant) || (unit.id === 'hierophant_brood' && u.type === 'WEAPON_SWAP')
          );
        });
        const specialUpgradesHtml = specialUps.map(u=>{
          const cur=(unit.upgrades||[]).find(x=>x.id===u.id);
          const count=cur&&cur.count?Number(cur.count):0;
          const pts=u.points||0;
          const isBroodlord=/broodlord/i.test(u.name||'');
          const others=isBroodlord? countCoreUpgradeTotal(fIdx, section, sIdx, 'broodlord'):0;
          const available=count>0?1:Math.max(0,1-others);
          const disabledAttr = (!count && available===0) ? 'disabled' : '';
          const eff = UPGRADE_EFFECTS[u.id]||{};
          const grants = (eff.rules||[]).length && window._modalUnitRef.id !== 'tyrannofex' ? `<div class="muted small" style="margin-top:4px">Grants: ${(eff.rules||[]).join('; ')}</div>` : '';
          const statTxt = eff.stats && (eff.stats.CAF||eff.stats.Wounds||eff.stats.Movement) ? `<div class="muted small">Stats: ${[eff.stats.CAF?('CAF '+eff.stats.CAF):'', eff.stats.Wounds?('Wounds '+eff.stats.Wounds):'', eff.stats.Movement?('Move '+eff.stats.Movement):''].filter(Boolean).join('; ')}</div>` : '';
          let extra = '';
          const isPyrovore = unit.id==='biovore' && /pyrovor/i.test(u.name||'');
          if(isPyrovore){
            const baseWeap = WEAPON_LIBRARY['Spore Launcher']||{};
            const pyroWeap = WEAPON_LIBRARY['Pyroacid Launcher']||{};
            const row = (label, s)=>`<tr><td>${label}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`;
            extra = `<div class="muted small" style="margin-top:4px">Weapons change:</div><table class="table" style="margin-top:4px"><thead><tr><th>Profile</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${row('Biovore  Spore Launcher', baseWeap)}${row('Pyrovore  Pyroacid Launcher', pyroWeap)}</tbody></table><div class="muted small" style="margin-top:4px">CAF increases for Pyrovores compared to Biovores (see unit rules for details).</div>`;
          }
          return `<label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-special-checkbox" data-id="${u.id}" data-name="${u.name}" data-type="${u.type||'MODEL_UPGRADE'}" data-points="${pts}" ${count>0?'checked':''} ${disabledAttr} style="display:${count>0?'none':''}" onchange="onSpecialUpgradeToggle('${u.id}', this.checked)"/><div><strong>${u.name}</strong> <span class="muted">(+${pts} pts)</span>${grants}${statTxt}${extra}<button id="uprm-${u.id}" class="btn btn-xs btn-red" style="margin-left:8px;display:${count>0?'':'none'}" onclick="document.getElementById('upcnt-${u.id}').value=0; onSpecialUpgradeToggle('${u.id}', false)"></button></div></label><input id="upcnt-${u.id}" class="modal-upgrade-count mini-input" type="number" min="0" max="1" step="1" value="${count}" data-points="${pts}" style="width:0;opacity:0;pointer-events:none"/>`;
        }).join('');

        const psychicHtml = (lib.psychicPowers||[]).map(p=>{

          const checked = (unit.psychic||[]).some(x=>x.id === p.id);

          return `<label style="display:flex;align-items:flex-start;gap:8px"><input type="checkbox" class="modal-psychic-checkbox" data-id="${p.id}" data-name="${p.name}" data-points="${p.points||0}" data-desc="${p.desc||''}" ${checked ? 'checked' : ''}/><div><strong>${p.name}</strong> <span class="muted">(+${p.points||0} pts)</span><div class="muted" style="margin-top:6px">${p.desc||''}</div></div></label>`;

        }).join('');



        const baseRules = (lib.specialRules||[]);
        const dyn = [];
        if(unit.id==='hive-tyrant' && (initialHasSwarm || (document.getElementById('upcnt-u_swarm') && Number(document.getElementById('upcnt-u_swarm').value||0)>0))) dyn.push('Swarm Lord: CAF +14; Wounds = 3');
        if(unit.id==='genestealer' && ((document.getElementById('upcnt-u_broodlord') && Number(document.getElementById('upcnt-u_broodlord').value||0)>0) || instanceUpgradeIds.includes('u_broodlord'))){ dyn.push('Synapse (6\")'); dyn.push('The Horror (Broodlord only)'); }
        const specialRulesHtml = (baseRules.concat(dyn)).length ? baseRules.concat(dyn).map(r=>renderRuleText(r)).join('') : `<div class="muted small">No special rules listed</div>`;

        const effectText = initialHasSwarm ? 'Swarm Lord effect: CAF becomes +14; Wounds = 3' : '';

        const baseCAF = lib.baseCAF || (UNIT_BASE[unit.id] && UNIT_BASE[unit.id].CAF) || '';

        const baseWounds = lib.baseWounds || (UNIT_BASE[unit.id] && UNIT_BASE[unit.id].wounds) || '';

        const loadModelsMap = UNIT_DEFAULT_MODELS || {};
        const maxModelsMap = UNIT_MAX_MODELS || {};
        const stepMap = UNIT_BROOD_STEP || {};
        let defModels = loadModelsMap[unit.id] || 1;
        let maxModels = maxModelsMap[unit.id] || defModels;
        let stepModels = stepMap[unit.id] || 1;
        const load = UNIT_LOADOUTS[unit.id] || {};
        const broodUp = (load.upgrades||[]).find(u=>u.type==='BROOD_SIZE');
        if(broodUp){
          if(broodUp.modelsDelta) stepModels = broodUp.modelsDelta;
          if(broodUp.maxModels) maxModels = broodUp.maxModels;
        }
        const adjustable = maxModels>defModels;
        const sizerMin = defModels;
        const sizerMax = maxModels;
        const sizerStep = stepModels;
        const modelCtrl = '';
        const baseM = (UNIT_DEFAULT_MODELS[unit.id]||defModels);
        let curM = Number(unit.models||defModels);
        const st = UNIT_BASE[unit.id] || {};
        
        let sizeOpts = '';
        const safeStep = Number(sizerStep) || 1;
        const safeMin = Number(sizerMin) || 1;
        const safeMax = Number(sizerMax) || safeMin;
        
        let modelList = [];
        for(let m=safeMin; m<=safeMax; m+=safeStep){
            modelList.push(m);
        }
        
        // Ensure current value is in the list so it displays correctly
        if(!modelList.includes(curM)){
            modelList.push(curM);
            modelList.sort((a,b)=>a-b);
        }

        sizeOpts = modelList.map(m => `<option value="${m}" ${m===curM?'selected':''}>${m}</option>`).join('');

        // Removed appearance:none so standard dropdown UI is visible. Removed btn classes to avoid conflicts.
         const selectHtml = `<select id="modal-unit-val" style="display:inline-block;width:auto;min-width:60px;height:40px;padding:0 24px 0 12px;font-weight:bold;background-color:#1e3a45;color:#fff;border:1px solid #374151;cursor:pointer;border-radius:6px;font-size:1.2em" onchange="window.setUnitSize(Number(this.value))">${sizeOpts}</select>`;
         const headerSummary = adjustable
          ? `<div id="modal-unit-summary" data-unit="${unit.id}" data-min="${sizerMin}" data-max="${sizerMax}" data-step="${sizerStep}" class="slot-meta-row small" style="margin:6px 0 10px;display:flex;flex-direction:column;gap:6px"><div style="display:flex;align-items:center;gap:8px"><span>Unit size:</span><div style="display:flex;gap:6px;align-items:center"><button id="modal-unit-dec" class="btn btn-xs" style="width:40px;height:40px;font-size:1.5em;display:inline-flex;align-items:center;justify-content:center" data-action="unit-dec"></button>${selectHtml}<button id="modal-unit-inc" class="btn btn-xs" style="width:40px;height:40px;font-size:1.5em;display:inline-flex;align-items:center;justify-content:center" data-action="unit-inc">+</button></div><span id="modal-unit-cost" class="cost">${unitPoints(unit)} PTS</span><span class="small muted">Max: ${sizerMax}</span></div><div id="modal-inc-label" class="small muted">Increase by: +${sizerStep}</div></div>`
          : `<div id="modal-unit-summary" data-unit="${unit.id}" data-min="${sizerMin}" data-max="${sizerMax}" data-step="${sizerStep}" class="slot-meta-row small" style="margin:6px 0 10px;display:flex;flex-direction:column;gap:6px"><div style="display:flex;align-items:center;gap:8px"><span>Unit size:</span><span class="pill">${curM}</span><span id="modal-unit-cost" class="cost">${unitPoints(unit)} PTS</span><span class="small muted">Max: ${sizerMax}</span></div></div>`;



        root.innerHTML = `

          <div class="modal-backdrop" onclick="closeModal()">

            <div class="modal-drawer" onclick="event.stopPropagation()" role="dialog" aria-modal="true" aria-labelledby="modal-title">
              <h3 id="modal-title" style="margin:0 0 8px 0">${unit.name}  Edit</h3>
              ${headerSummary}
              <div class="drawer-stack">
                <div>

                  ${(()=>{
                    if(!st || !st.movement) return '';
                    return `<div class="table-scroll-wrapper">
                      <table class="table" style="min-width:600px"><thead><tr><th>Name</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th><th>Base</th></tr></thead><tbody><tr><td>${unit.name}</td><td>${st.movement||'-'}</td><td>${st.save||'-'}</td><td>${st.CAF||'-'}</td><td>${st.morale||'-'}</td><td>${st.wounds||'-'}</td><td>${st.base_size||'-'}</td></tr></tbody></table>
                    </div>`;
                  })()}

                  ${(weaponsHtml || upgradesRowsHtml) && !unit.id.includes('hierodule') ? `
                    <div class="table-scroll-wrapper">
                      <table class="table" style="min-width:600px"><thead><tr><th>Weapon / Upgrade</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th><th class="text-end" style="width: 80px;">Cost</th></tr></thead><tbody>${weaponsHtml+upgradesRowsHtml}</tbody></table>
                    </div>
                  ` : ''}
                  ${hieroduleHtml ? `<div style="margin-top:10px">${hieroduleHtml}</div>` : ''}

                  ${modelCtrl}

                  ${specialUps.length ? `
                    <div style="margin-bottom:10px">
                      <label class="small">Unit Upgrades</label>
                      <div style="margin-top:6px">${specialUpgradesHtml}</div>
                    </div>
                  ` : ''}

                  ${unit.id === 'hive-tyrant' ? `

                    <div style="margin-bottom:10px">

                      <label class="small">Psychic Powers</label>

                      <div style="margin-top:6px">${psychicHtml || '<div class="muted">None</div>'}</div>

                    </div>

                  ` : ''}





                </div>



                <div>

                  <div id="modal-effect-pill" class="effect-pill" style="display:${effectText? '': 'none'}">${effectText}</div>



                  <div id="modal-caf-block" style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px;display:${initialHasSwarm ? '' : 'none'}">

                    <div class="small muted">CAF (effective)</div>

                    <div id="modal-caf-value" data-base="${baseCAF}" style="font-weight:700">${initialHasSwarm? '+14' : baseCAF}</div>

                  </div>



                  <div id="modal-wounds-block" style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px;display:${initialHasSwarm ? '' : 'none'}">

                    <div class="small muted">Wounds (effective)</div>

                    <div id="modal-wounds-value" data-base="${baseWounds}" style="font-weight:700">${initialHasSwarm? '3' : baseWounds}</div>

                  </div>



                  <div style="background:#071a21;padding:10px;border-radius:6px;margin-top:10px">

                    <div class="small muted">Special rules</div>

                    <div id="modal-special-rules" style="margin-top:6px">${specialRulesHtml}</div>

                  </div>



                  <div style="margin-top:10px" class="small muted">Total Unit Cost:
                    <div id="modal-total-points" style="margin-top:8px;font-weight:700">0 pts</div>
                  </div>



                  ${st.unit_note ? `<div class="notes" style="margin-top:10px;font-style:italic">${st.unit_note}</div>` : ''}

                  ${unit.notes && unit.notes.length ? `<div class="notes" style="margin-top:10px">${unit.notes.join('; ')}</div>` : ''}

                </div>

              </div>



              <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
                <button id="modal-save-btn" class="btn btn-sm btn-blue">Save</button>
              </div>
            </div>
          </div>
        `;
        enforceWeaponConstraints();
        window.bumpUpgradeCount = bumpUpgradeCount;
        try{ const drawer=document.querySelector('.modal-drawer'); if(drawer){ trapFocus(drawer); setTimeout(()=>{ const first=drawer.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'); if(first && first.focus) first.focus(); },0); } }catch(e){}
        (function bindHeaderControls(){ try{ const dec=document.getElementById('modal-unit-dec'); const inc=document.getElementById('modal-unit-inc'); if(dec) dec.addEventListener('click', ()=>window.headerModelBump(-1)); if(inc) inc.addEventListener('click', ()=>window.headerModelBump(1)); }catch(e){} })();

        setTimeout(()=>{ try{ onModalUpgradeToggle(); }catch(e){} try{ updateModalTotals(); }catch(e){} try{ enforceWeaponConstraints(); }catch(e){} try{ updateSpecialRulesBlock(); }catch(e){} try{ updateHieroduleVisuals(); }catch(e){} }, 0);

        const saveBtn = document.getElementById('modal-save-btn'); if(saveBtn) saveBtn.addEventListener('click', saveEditFromModal, { once:true });



        Array.from(document.querySelectorAll('.modal-weapon-checkbox')).forEach(cb => cb.addEventListener('change', (e)=>{ if(window.onModalWeaponToggle) window.onModalWeaponToggle(e.target); updateModalTotals(); enforceWeaponConstraints(); }));

        Array.from(document.querySelectorAll('.modal-upgrade-count')).forEach(inp => inp.addEventListener('change', updateModalTotals));

        Array.from(document.querySelectorAll('.modal-psychic-checkbox')).forEach(cb => cb.addEventListener('change', updateModalTotals));

        const modalModelsInput = document.getElementById('modal-models-input'); if(modalModelsInput) modalModelsInput.addEventListener('change', ()=>{ onModalUpgradeToggle(); updateModalTotals(); });

      }



      // ---------- Renderers ----------

      function renderContent(){

        const content = document.getElementById('content'); if(!content) return;

        if(activeTab === 'home'){ content.innerHTML = renderHome(); return; }

        if(activeTab === 'lists'){ content.innerHTML = renderLists(); return; }

        if(activeTab === 'army-builder'){ content.innerHTML = renderArmyBuilder(); return; }

        

        if(activeTab === 'reference'){ content.innerHTML = renderReference(); try{ postRenderAdjustments(); }catch(e){} return; }

        if(activeTab === 'roster'){ content.innerHTML = renderRoster(); return; }

      }



      const RECENT_UPDATES = [
        { date: '2026-01-24', text: 'Offline Mode: App is now a PWA! Install it to your home screen and use it without internet.' },
        { date: '2026-01-24', text: 'Exports: Added Detailed Roster PDF/Print with full stats, weapons, and special rules.' },
        { date: '2026-01-24', text: 'Exports: Refined Builder List layout with points per unit and spacing.' },
        { date: '2026-01-24', text: 'Exports: Standardized filenames (Name - Faction - Points).' },
        { date: '2026-01-24', text: 'Tyranid Army List Complete! All units and formations are now available.' },
        { date: '2026-01-24', text: 'Added Hierophant Brood (Biotitan) with full weapon options and logic.' },
        { date: '2026-01-23', text: 'Added Hierodule Brood to Tyranid army list (Biotitan).' },
        { date: '2026-01-23', text: 'Added Tyrannofex Brood, Exocrine Brood, and Malefactor Brood to Tyranid army list.' },
        { date: '2026-01-22', text: 'Update: All units with Flyer rule now default to 32mm base size.' },
        { date: '2026-01-22', text: 'Added Harpy Brood to Tyranid army list (Flyer Support).' },
        { date: '2026-01-22', text: 'Added Guest Mode with local storage support.' },
        { date: '2026-01-22', text: 'Implemented seamless Local-to-Cloud list transfer.' },
        { date: '2026-01-22', text: 'Improved UI readability for Detachment and Army rules.' },
        { date: '2026-01-22', text: 'Added white background to Roster tables for better contrast.' },
        { date: '2026-01-21', text: 'Added unit types & sizes (e.g., WALKER (1)) to Builder & Roster.' },
        { date: '2026-01-21', text: 'Introduced Interactive Rule Badges for full description popups.' },
        { date: '2026-01-21', text: 'Polished Roster Army Rules layout to match Reference tab.' },
        { date: '2026-01-20', text: 'Fixed formation rule display issues in Roster view.' },
        { date: '2026-01-20', text: 'Prevented accidental card collapse when clicking rule badges.' },
        { date: '2026-01-19', text: 'Initial release of Tyranid Army Data and Reference tools.' }
      ];

      const COMING_SOON = [
        "Auto Army Builder",
        "Ork Army Data",
        "Eldar Army Data"
      ];

      function renderHome(){
        const updatesContent = RECENT_UPDATES.map(u => `
          <div class="muted small" style="margin-bottom:8px">
            <strong style="color:var(--accent)">${u.date}:</strong> ${u.text}
          </div>
        `).join('');
        
        const comingSoonContent = COMING_SOON.map(item => `
          <div style="background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:4px; padding:6px 12px; font-size:12px; color:var(--text-muted)">
            ${item}
          </div>
        `).join('');

        const welcomeText = `
          <div style="margin-bottom:24px; text-align:center">
            <div style="margin-bottom:16px">
               <img src="Images/WebIcon.png" style="max-width:120px; border-radius:50%; border:2px solid var(--accent); box-shadow:0 0 15px var(--accent-dim)" alt="Xenos Icon" onerror="this.src='Images/WebIcon.png'"/>
            </div>
            <h2 style="margin:0 0 8px 0; font-size:24px; letter-spacing:1px; text-transform:uppercase; color:var(--text-main); font-family:'Orbitron',sans-serif">The Galaxy Burns</h2>
            <div class="muted small" style="max-width:500px; margin:0 auto; line-height:1.6">
              Command your forces and conquer the stars. Whether you lead the endless swarms of the Tyranids, the ancient craftworlds of the Eldar, or the brutal waagh of the Orks, the galaxy is yours for the taking.
              <br/><br/>
              Build your army lists, manage your detachments, and prepare for war.
            </div>
          </div>
        `;

        // Check if user is Guest to show Link Account button
        const isGuest = (!currentUserId || currentUserId === 'guest');
        const linkAccountBtn = isGuest ? `<button class="btn" style="border:1px solid var(--accent); color:var(--accent); background:transparent" onclick="openGuestMenu()">Link Google Account</button>` : '';

        return `<div style="padding:12px">
          <div class="hero" style="background:linear-gradient(180deg, rgba(16,24,39,0) 0%, rgba(16,24,39,1) 100%)">
            ${welcomeText}
            
            <div style="display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-bottom:32px">
               <button class="btn btn-green hero-cta" onclick="createNewList()">Create List</button>
               <button class="btn btn-blue" onclick="setActiveTab('lists'); renderContent()">My Lists</button>
               ${linkAccountBtn}
            </div>

            <div style="max-width:600px; margin:0 auto">
               <div class="card p-4" style="margin-bottom:16px">
                 <h3 class="section-title" style="border-bottom:1px solid var(--border); padding-bottom:8px; margin-bottom:12px">Recent Updates</h3>
                 ${updatesContent}
               </div>

               <div class="card p-4">
                 <h3 class="section-title" style="border-bottom:1px solid var(--border); padding-bottom:8px; margin-bottom:12px">Coming Soon</h3>
                 <div style="display:flex; flex-wrap:wrap; gap:8px">
                   ${comingSoonContent}
                 </div>
               </div>
            </div>

          </div>
        </div>`;
      }


      function renderReference(){ if(referenceView==='main') return renderReferenceHome(); if(referenceView==='units') return renderReferenceUnits(); if(referenceView==='unit-detail') return renderReferenceUnitDetail(); if(referenceView==='weapons') return renderReferenceWeapons(); if(referenceView==='weapon-detail') return renderReferenceWeaponDetail(); if(referenceView==='detachments') return renderReferenceDetachments(); if(referenceView==='formations') return renderReferenceFormations(); if(referenceView==='army-rules') return renderReferenceArmyRules(); if(referenceView==='game-rules') return renderReferenceGameRules(); return renderReferenceHome(); }

      function renderCrumbs(parts){ try{ return `<div class="crumbs small muted">` + parts.map((p,i)=>`<span ${p.on?`onclick=\"${p.on}\" style=\"cursor:pointer;text-decoration:underline\"`:''}>${p.label}</span>${i<parts.length-1?'  ':''}`).join('') + `</div>`; }catch(e){ return `<div class="crumbs small muted">Reference</div>`; } }

      function postRenderAdjustments(){ const crumbs=document.querySelector('.crumbs.small.muted'); if(crumbs){ const text=(crumbs.textContent||'').trim(); if(text.startsWith('Reference')){ const parts=text.split('').map(s=>s.trim()); if(parts.length===1){ crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span>`; } if(parts.length===2){ const tail=parts[1]; crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span>  ${tail}`; } if(parts.length>=3){ const mid=parts[1]; const tail=parts.slice(2).join('  '); const midAction=(mid==='Units')?"setReferenceView('units')":(mid==='Weapons'?"setReferenceView('weapons')":(mid==='Army Rules'?"setReferenceView('army-rules')":(mid==='Game Rules'?"setReferenceView('game-rules')":""))); const midSpan=midAction?`<span onclick=\"${midAction}\" style=\"cursor:pointer;text-decoration:underline\">${mid}</span>`:mid; crumbs.innerHTML = `<span onclick="openReferenceHome()" style="cursor:pointer;text-decoration:underline">Reference</span>  ${midSpan}  ${tail}`; } } } if(referenceView==='weapons'){ const table=document.querySelector('.card table.table'); if(table){ const ths=table.querySelectorAll('thead th'); if(ths.length){ ths[ths.length-1].style.display='none'; } const rows=table.querySelectorAll('tbody tr'); rows.forEach(tr=>{ const tds=tr.querySelectorAll('td'); if(tds.length){ tds[tds.length-1].style.display='none'; } }); } } }

      function renderReferenceHome(){
        const icons = {
          units:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm-7 8v-2a5 5 0 0 1 5-5h4a5 5 0 0 1 5 5v2H5Z"/></svg>`,
          weapons:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 21l6-6 3 3-6 6H3Zm9-9 3 3 6-6-3-3-6 6Z"/></svg>`,
          detachments:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 3h8v8H3V3Zm10 0h8v8h-8V3ZM3 13h8v8H3v-8Zm10 5h8v3h-8v-3Z"/></svg>`,
          formations:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2l4 7h-8l4-7Zm-9 20h18l-9-6-9 6Z"/></svg>`,
          rules:`<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`
        };
        const tiles=[
          {label:'Units',svg:icons.units,action:"openReferenceUnits()"},
          {label:'Weapons',svg:icons.weapons,action:"openReferenceWeapons()"},
          {label:'Army Rules',svg:icons.units,action:"openReferenceArmyRules()"},
          {label:'Game Rules',svg:icons.rules,action:"openReferenceGameRules()"},
          {label:'Detachments',svg:icons.detachments,action:"openReferenceDetachments()"},
          {label:'Formations',svg:icons.formations,action:"openReferenceFormations()"}
        ];
        const mapSrc = {
          Units: 'Images/rule_icons/units.svg',
          Weapons: 'Images/rule_icons/weapons.svg',
          Detachments: 'Images/rule_icons/detachments.svg',
          Formations: 'Images/rule_icons/formations.svg',
          'Army Rules': 'Images/rule_icons/army_rules.svg',
          'Game Rules': 'Images/rule_icons/game_rules.svg'
        };
        const items=tiles.map(t=>`<div class="rb-tile-card" onclick="${t.action}"><div class="rb-tile-header">${t.label}</div><div class="rb-tile-body"><img class="tile-icon-img" src="${mapSrc[t.label]}" alt="${t.label} icon" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"/><div class="tile-icon" style="display:none">${t.svg}</div></div></div>`).join('');
        return `<div style="padding:12px">${renderCrumbs([{label:'Reference'}])}<div class="tile-grid">${items}</div></div>`;
      }

      function renderReferenceGameRules(){
        const rules = [
          {
            title: 'Blast Markers',
            content: `
              <div class="pdf-paragraph">Blast Markers represent the confusion, suppression, and morale impact of enemy fire on a formation. They are a core mechanic of the game.</div>
              <div class="pdf-subhead">Gaining Blast Markers</div>
              <div class="pdf-paragraph">A formation gains Blast Markers (BMs) in the following ways:</div>
              <ul style="list-style-type:disc;padding-left:20px;color:#1f2937">
                <li><strong>Coming Under Fire:</strong> When a formation is targeted by a shooting attack, it receives 1 Blast Marker immediately, even if no hits are scored.</li>
                <li><strong>Casualties:</strong> The formation receives 1 additional Blast Marker for each unit destroyed (or Void Shield lost).</li>
                <li><strong>Special Rules:</strong> Some weapons (e.g., those with the <em>Pinning</em> trait) or effects may cause additional Blast Markers.</li>
              </ul>
              <div class="pdf-subhead">Effects of Blast Markers</div>
              <ul style="list-style-type:disc;padding-left:20px;color:#1f2937">
                <li><strong>Suppressed:</strong> If a formation has 1 or more Blast Markers, it is considered <em>Suppressed</em>. It suffers a <strong>-1 penalty to Hit</strong> when shooting.</li>
                <li><strong>Broken:</strong> If the number of Blast Markers equals or exceeds the number of units in the formation, the formation becomes <em>Broken</em>. It cannot shoot or assault, and must withdraw (make a Withdrawal move) to cover.</li>
                <li><strong>Initiative:</strong> Blast Markers also apply a penalty to Initiative checks (Action tests). -1 modifier per Blast Marker.</li>
              </ul>
              <div class="pdf-subhead">Rallying</div>
              <div class="pdf-paragraph">In the End Phase, formations can Rally to remove Blast Markers. Broken formations must make a Rally test. If successful, they remove half their Blast Markers (rounded up) and are no longer Broken. Unbroken formations remove D6 Blast Markers.</div>
            `
          }
        ];
        
        const items = rules.map(r => `
          <div class="card" style="padding:0;margin-bottom:12px">
            <div class="section-bar">${r.title}</div>
            <div style="padding:12px">
              ${r.content}
            </div>
          </div>
        `).join('');

        return `<div style="padding:12px">${renderCrumbs([{label:'Reference',on:'openReferenceHome()'},{label:'Game Rules'}])}${items}<div style="margin-top:8px"><button class="btn" onclick="openReferenceHome()">Back</button></div></div>`;
      }

      function renderReferenceUnits(){ const armies=Object.keys(ARMIES).filter(a=>a!=='Select Army'); const filt=String(referenceFilter||'').toLowerCase(); const search=`<div style=\"display:flex;gap:8px;margin-bottom:8px\"><input id=\"ref-unit-search\" class=\"mini-input\" placeholder=\"Search units\" value=\"${referenceQuery}\" oninput=\"setReferenceFilter(this.value)\" onkeydown=\"if(event.key==='Enter'){commitReferenceFilter(this.value)}\"/><button class=\"btn btn-sm\" onclick=\"commitReferenceFilter(document.getElementById('ref-unit-search').value)\">Search</button><button class=\"btn btn-sm\" onclick=\"setReferenceFilter('')\">Clear</button></div>`; const order=['HQ','Synapse','Core','Support','Vanguard','Transport','BattleTank','HeavyArmor','AirSupport','Artillery','Knight','Biotitan','Flyer']; const cols=armies.map(a=>{ const key=armyKey(a); const list=(ARMY_UNIT_LIST[key]||[]); const list2=filt?list.filter(u=>u.name.toLowerCase().includes(filt)):list; const groups=order.map(role=>({ role, items: list2.filter(u=>u.slotType===role) })).filter(g=>g.items.length); const items=groups.length? groups.map(g=>`<div><div class=\"section-sub\">${g.role}</div>${g.items.map(u=>`<div style=\"padding:6px 8px;border-bottom:1px solid #243e46;cursor:pointer\" onclick=\"openReferenceUnit('${a}','${u.id}')\">${u.name}</div>`).join('')}</div>`).join('') : `<div class=\"small muted\" style=\"padding:8px\">No matches</div>`; return `<div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">${a}</div><div>${items}</div></div>`; }).join(''); return `<div style=\"padding:12px\">${renderCrumbs([{label:'Reference',on:'openReferenceHome()'},{label:'Units'}])}${search}<div style=\"display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px\">${cols}</div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"openReferenceHome()\">Back</button></div></div>`; }

      function buildWeaponUsageIndex(){ const usage={}; Object.keys(UNIT_LOADOUTS||{}).forEach(uid=>{ const load=UNIT_LOADOUTS[uid]||{}; (load.weapons||[]).filter(w=>w.base).forEach(w=>{ const name=w.name||w.src; usage[name]=usage[name]||{count:0,units:[]}; usage[name].count+=1; usage[name].units.push(uid); }); }); return usage; }

      function renderReferenceWeapons(){ const filt=String(referenceFilter||'').toLowerCase(); const usage=buildWeaponUsageIndex(); const list=Object.keys(WEAPON_LIBRARY||{}).sort((a,b)=>a.localeCompare(b)); const rows=list.filter(n=>{ if(!filt) return true; const s=WEAPON_LIBRARY[n]||{}; const cat=(s.traits||''); return n.toLowerCase().includes(filt)||String(cat).toLowerCase().includes(filt); }).map(n=>{ const s=WEAPON_LIBRARY[n]||{}; const u=usage[n]||{count:0,units:[]}; return `<tr onclick=\"openReferenceWeapon('${n.replace(/'/g,"\\'")}')\"><td>${n}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td><td class=\"small muted\">${u.count||0}</td></tr>`; }).join('') || `<tr><td colspan=\"7\" class=\"small muted\">No weapons</td></tr>`; const search=`<div style=\"display:flex;gap:8px;margin-bottom:8px\"><input id=\"ref-weapon-search\" class=\"mini-input\" placeholder=\"Search weapons\" value=\"${referenceQuery}\" oninput=\"setReferenceFilter(this.value)\" onkeydown=\"if(event.key==='Enter'){commitReferenceFilter(this.value)}\"/><button class=\"btn btn-sm\" onclick=\"commitReferenceFilter(document.getElementById('ref-weapon-search').value)\">Search</button><button class=\"btn btn-sm\" onclick=\"setReferenceFilter('')\">Clear</button></div>`; return `<div style=\"padding:12px\"><div class=\"crumbs small muted\">Reference  Weapons</div>${search}<div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">Weapons</div><table class=\"table\"><thead><tr><th>Name</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th><th>Used By</th></tr></thead><tbody>${rows}</tbody></table></div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"openReferenceHome()\">Back</button></div></div>`; }

      function renderReferenceWeaponDetail(){ const name=referenceWeapon; const s=WEAPON_LIBRARY[name]||{}; const usage=buildWeaponUsageIndex()[name]||{units:[]}; const unitNames=(usage.units||[]).map(id=>slugToName(id)).join(', '); return `<div style=\"padding:12px\"><div class=\"crumbs small muted\">Reference  Weapons  ${name}</div><div class=\"card\" style=\"padding:0\"><div class=\"section-bar\">${name}</div><div style=\"padding:8px\"><table class=\"table\"><thead><tr><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody><tr><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr></tbody></table><div class=\"section-sub\">Used By</div><div>${unitNames||'<span class=\\"small muted\\">Unknown</span>'}</div></div></div><div style=\"margin-top:8px\"><button class=\"btn\" onclick=\"setReferenceView('weapons')\">Back to Weapons</button><button class=\"btn\" style=\"margin-left:8px\" onclick=\"openReferenceHome()\">Reference Home</button></div></div>`; }

      function renderReferenceUnitDetail(){ const army=referenceDetail.army; const unitId=referenceDetail.unitId; const key=armyKey(army||selectedArmy); const list=(ARMY_UNIT_LIST[key]||[]); const base=list.find(u=>u.id===unitId)||{name:slugToName(unitId),slotType:'Core'}; const stats=UNIT_BASE[unitId]||{}; const load=UNIT_LOADOUTS[unitId]||{weapons:[],specialRules:[],upgrades:[]}; const weapons=(load.weapons||[]).filter(w=>w.base); const rows=weapons.length? weapons.map(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; return `<tr><td>${w.name}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`; }).join('') : `<tr><td colspan="6" class="small muted">No base weapons</td></tr>`; const rules=(load.specialRules||[]).join(', '); const ups=(load.upgrades||[]); const upsBlock=ups.length?`<div class=\"section-sub\">Upgrades</div><div><button class=\"btn btn-sm\" onclick=\"toggleReferenceUpgrades()\">${referenceShowUpgrades?'Hide':'Show'} Upgrades</button>${referenceShowUpgrades?ups.map(u=>`<div style=\"margin-top:4px\"><strong>${u.name}</strong> <span class=\"muted\">(+${u.points||0} pts)</span><div class=\"muted\">${u.desc||''}</div></div>`).join(''):''}</div>`:''; return `<div style="padding:12px"><div class="crumbs small muted">Reference  Units  ${base.name}</div><div class="card" style="padding:0"><div class="section-bar">${base.name}</div><div style="padding:8px"><div style="display:flex;justify-content:space-between"><div class="pill">${base.slotType}</div><div class="pill">${army||'-'}</div></div><table class="table" style="margin-top:8px"><thead><tr><th>Name</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th><th>Base</th></tr></thead><tbody><tr><td>${base.name}</td><td>${stats.movement||'-'}</td><td>${stats.save||'-'}</td><td>${stats.CAF||'-'}</td><td>${stats.morale||'-'}</td><td>${stats.wounds||'-'}</td><td>${stats.base_size||'-'}</td></tr></tbody></table><div class="section-sub">Weapons</div><table class="table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${rows}</tbody></table><div class="section-sub">Special Rules</div><div>${rules||'<span class=\"small muted\">None</span>'}</div>${upsBlock}${stats.unit_note ? `<div class="notes" style="margin-top:10px;font-style:italic;padding:8px;background:#071a21;border-radius:4px">${stats.unit_note}</div>` : ''}</div></div><div style="margin-top:8px"><button class="btn" onclick="setReferenceView('units')">Back to Units</button><button class="btn" style="margin-left:8px" onclick="openReferenceHome()">Reference Home</button></div></div>`; }

      function renderLists(){
        const lists = (savedLists||[]);
        const allSelected = lists.length>0 && selectedListIds.length === lists.length;
        const rows = lists.length ? lists.map(l=>{
          const pointsUsed = (l.formations||[]).reduce((s,f)=>s+formationPoints(f),0);
          const pointsCap = l.pointsCap||2000;
          const checked = selectedListIds.includes(l.id) ? 'checked' : '';
          const saved = formatDateTime(l.updatedAt || l.createdAt);
          return `<tr>
            <td style="width:28px;text-align:center"><input type="checkbox" data-action="list-select" data-id="${l.id}" ${checked}/></td>
            <td><div style="font-weight:800">${l.name||'Untitled'}</div></td>
            <td class="col-army">${l.faction||'-'}</td>
            <td class="col-saved">${saved}</td>
            <td class="col-points">${pointsUsed}/${pointsCap} pts <span class="header-actions" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px"><button class="btn btn-blue btn-xs" data-action="list-open" data-id="${l.id}">Build</button><button class="btn btn-green btn-xs" data-action="list-export" data-id="${l.id}">Export</button><button class="btn btn-red btn-xs" data-action="list-del" data-id="${l.id}">Delete</button></span></td>
          </tr>`;
        }).join('') : `<tr><td colspan="5" class="muted small">No saved lists</td></tr>`;
        const bulk = selectedListIds.length ? `<div class="small" style="display:flex;gap:8px;align-items:center;margin-bottom:8px"><span>Selected: ${selectedListIds.length}</span><button class="btn btn-red btn-sm" data-action="bulk-del">Delete Selected</button></div>` : '';
        const headerActions = selectedListIds.length ? `<span class="header-actions" style="display:inline-flex; gap:6px; align-items:center; margin-left:8px">${selectedListIds.length===1?`<button class=\"btn btn-blue btn-xs\" data-action=\"bulk-open\">Build</button>`:''}<button class="btn btn-blue btn-xs" data-action="bulk-export">Export</button><button class="btn btn-red btn-xs" data-action="bulk-del">Delete</button></span>` : '';
        const cloudBtn = (currentUserId && currentUserIsGoogle) ? `<button class="btn btn-blue" onclick="promptCloudSync()">Cloud Sync</button>` : '';
        return `
          <div style="padding:12px">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
              <button class="btn btn-green" onclick="createNewList()">Create List</button>
              ${cloudBtn}
            </div>
            ${bulk}
            <div class="table-responsive">
              <table class="table"><thead><tr><th style="width:28px;text-align:center"><input type="checkbox" data-action="select-all" ${allSelected?'checked':''}/></th><th>List Name</th><th class="col-army">Army</th><th class="col-saved">Saved</th><th class="col-points">Points ${headerActions}</th></tr></thead><tbody>${rows}</tbody></table>
            </div>
          </div>`;
      }

      function promptCloudSync(){
         const root=document.getElementById('modal-root');
         root.innerHTML = `
           <div class="modal-backdrop" onclick="if(this.dataset.blocking!=='true') closeModal()">
             <div class="modal-drawer" onclick="event.stopPropagation()" style="width:90%;max-width:500px;height:auto;max-height:80vh">
               <div id="sync-content">
                 <h3 style="margin:0 0 8px 0">Cloud Sync</h3>
                 <p>Syncing will merge your local lists with the cloud.</p>
                 <p class="small muted"><strong>Warning:</strong> Lists with the same ID will be overwritten by the version with the newest "Last Saved" timestamp (Last Save Wins).</p>
                 <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
                   <button class="btn" onclick="closeModal()">Cancel</button>
                   <button class="btn btn-green" onclick="performManualSync(this)">Sync Now</button>
                 </div>
               </div>
             </div>
           </div>`;
         // Trap focus in modal
         const firstInput = root.querySelector('button');
         if(firstInput) firstInput.focus();
      }

      async function performManualSync(btn){
        let debugLog = []; const log = (m) => { const t=new Date().toISOString().split('T')[1].slice(0,-1); console.log('[Sync]',m); debugLog.push(t+': '+m); };
        const content = document.getElementById('sync-content');
        if(!content) return;
        
        // 1. Lock Modal
        const backdrop = document.querySelector('.modal-backdrop');
        if(backdrop) backdrop.dataset.blocking = 'true';
        
        // 2. Show Spinner
        content.innerHTML = `
          <h3 style="margin:0 0 8px 0">Cloud Sync</h3>
          <div style="display:flex;flex-direction:column;align-items:center;gap:12px;padding:20px 0">
             <div class="spinner"></div>
             <div id="sync-status" class="small">Syncing your lists...</div>
          </div>
        `;
        
        try{
           // Wait a tick to allow UI to render
           await new Promise(r=>setTimeout(r, 100));
           
           log(`Host: ${window.location.hostname}`);
           log(`Proto: ${window.location.protocol}`);
           log(`Online: ${navigator.onLine}`);
           initCloudIfAvailable();
           log(`Cloud Init: App=${!!firebaseApp}, Auth=${!!firebaseAuth}, DB=${!!firebaseDb}, User=${currentUserId}`);
           log('Firestore Settings: ForceLongPolling=true');
           
           if(!firebaseDb || !currentUserId){ throw new Error(`Cloud unavailable (DB=${!!firebaseDb}, User=${currentUserId})`); }
           
           // Connectivity Check
           log('Checking connectivity...');
           try {
              await fetch('styles.css?t='+Date.now(), { method: 'HEAD', cache: 'no-store' });
              log('Connectivity: OK');
           } catch(e) {
              log('Connectivity: FAILED (' + e.message + ')');
              throw new Error('Internet connectivity check failed. You seem to be offline.');
           }

           // 1. Fetch Cloud Lists with Timeout
           if (!navigator.onLine) {
            throw new Error('No internet connection - check your network');
          }
          
           // Force connection reset to clear stuck sockets
           log('Resetting network connection...');
           try { await firebaseDb.disableNetwork(); } catch(e){}
           try { await firebaseDb.enableNetwork(); log('Network enabled'); } catch(e) { log('enableNetwork warning: '+e.message); }
 
           let cloudLists = [];
           
           // DIAGNOSTIC WRITE: Try to write a tiny timestamp to check DB health
           log('Ping: Writing test document...');
           const pingRef = firebaseDb.collection('users').doc(currentUserId).collection('sys').doc('ping');
           const pingTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Ping timeout (5s)')), 5000));
           
           try {
              await Promise.race([ pingRef.set({ t: Date.now() }), pingTimeout ]);
              log('Ping: SUCCESS (Write allowed)');
           } catch(e) {
              log('Ping: FAILED (' + e.message + ')');
              if(e.message.includes('timeout')) {
                 const err = new Error('Database connection failed (Timeout).');
                 err.helpAction = 'create_db';
                 throw err;
              }
              // If permission denied, we might still be able to read? Unlikely but let's try.
           }

           // Create a promise that rejects after 20s
           const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Network timeout (20s) - check connection or firewall')), 20000));
           
           log(`Fetching users/${currentUserId}...`);
           // Force server fetch to bypass potential cache locks
           const fetchOp = firebaseDb.collection('users').doc(currentUserId).get({ source: 'server' })
              .catch(e => { throw new Error('Firestore Get Error: ' + e.message); });
            
            const doc = await Promise.race([fetchOp, timeout]);
            log(`Fetch done. Exists: ${doc ? doc.exists : 'null'}`);
           
           if(doc && doc.exists){
             const data = doc.data()||{};
             if(Array.isArray(data.savedLists)){ cloudLists = data.savedLists; }
           }

           // 2. Merge Logic (ID based, Last Save Wins)
           const mergedMap = new Map();
           savedLists.forEach(l => mergedMap.set(l.id, l));
           
           cloudLists.forEach(cl => {
              if(mergedMap.has(cl.id)){
                 const localL = mergedMap.get(cl.id);
                 const localTime = localL.updatedAt || localL.createdAt || 0;
                 const cloudTime = cl.updatedAt || cl.createdAt || 0;
                 if(cloudTime > localTime){ mergedMap.set(cl.id, cl); }
              } else {
                 mergedMap.set(cl.id, cl);
              }
           });
           
           // 4. Update State
           savedLists = Array.from(mergedMap.values());
           
           // 5. Save to Local
           const key=storageKey('saved_lists');
           localStorage.setItem(key, JSON.stringify(savedLists));
           
           // 6. Save to Cloud
           log('Saving to cloud...');
           await Promise.race([
             firebaseDb.collection('users').doc(currentUserId).set({ savedLists }, { merge:true }),
             timeout
           ]);
           log('Save complete');
           
           // 7. Success UI
           renderContent();
           content.innerHTML = `
             <h3 style="margin:0 0 8px 0">Cloud Sync</h3>
             <div style="display:flex;flex-direction:column;align-items:center;gap:12px;padding:20px 0">
                <div style="color:#4ade80;font-size:24px"></div>
                <div>Sync Complete!</div>
             </div>
           `;
           setTimeout(closeModal, 1500);
           
        }catch(e){
           console.error('Manual Sync Error', e);
           if(typeof log === 'function') log('ERROR: ' + e.message);
           
           // Diagnosis hint
           if(e.message.includes('client is offline') || e.message.includes('unavailable')){
             if(typeof log === 'function') {
               log('-----------------------------------');
               log('POSSIBLE FIX:');
               log('1. Go to Firebase Console -> Auth -> Settings -> Authorized Domains');
               log('2. Add this domain: ' + window.location.hostname);
               log('3. Check if your network blocks "firestore.googleapis.com"');
               log('-----------------------------------');
             }
           }

           const debugText = (typeof debugLog !== 'undefined') ? debugLog.join('\n') : e.message;
           
           let helpBtn = '';
           if(e.helpAction === 'create_db'){
              helpBtn = `<a href="https://console.firebase.google.com/project/${window.XENOS_FIREBASE_CONFIG.projectId}/firestore" target="_blank" class="btn btn-blue" style="text-decoration:none">Create Database in Console</a>`;
           }

           content.innerHTML = `
             <h3 style="margin:0 0 8px 0">Sync Failed</h3>
             <p class="small text-red">${e.message}</p>
             ${e.helpAction === 'create_db' ? '<p class="small muted">The database may not exist yet. Click below to create it in "Production Mode".</p>' : ''}
             <div style="background:#222;color:#ccc;padding:8px;border-radius:4px;font-family:monospace;font-size:11px;height:120px;overflow-y:auto;white-space:pre-wrap;margin:8px 0;text-align:left">${debugText}</div>
             <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
               ${helpBtn}
               <button class="btn" onclick="closeModal()">Close</button>
               <button class="btn btn-green" onclick="performManualSync()">Retry</button>
             </div>
           `;
           if(backdrop) backdrop.dataset.blocking = 'false';
        }
      }


      function setListsSort(k){ listsSortBy = k; listsSortDir = (listsSortDir==='asc') ? 'desc' : 'asc'; renderContent(); }

      function createNewList(){ const now=Date.now(); const id=String(now); selectedArmy='Select Army'; selectedFormationName='Select a Formation'; armyFormations=[]; builderMeta={ name:'New List', gamemode:'Standard', allegiance:'Loyalist', pointsCap:2000 }; currentListId=id; setActiveTab('army-builder'); saveState(); }
      function viewList(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; const countForm=(l.formations||[]).length; const rows=(l.formations||[]).map(f=>{ const units=((f.compulsory||[]).reduce((s,slt)=>s+(slt.units||[]).length,0))+((f.optional||[]).reduce((s,slt)=>s+(slt.units||[]).length,0)) + (f.special && (f.special.units||[]).length || 0); return `<tr><td>${f.name}</td><td>${formationPoints(f)} pts</td><td>${units} units</td></tr>`; }).join('') || `<tr><td colspan="3" class="muted small">No formations</td></tr>`; const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${l.name}  Summary</h3><div class="small muted">Faction: ${l.faction||'-'}  Gamemode: ${l.gamemode||'Standard'}</div><div class="small" style="margin-top:6px">Points: <strong>${pointsUsed}/${pointsCap}</strong>  Formations: ${countForm}</div><div style="margin-top:8px"><div class="table-responsive"><table class="table"><thead><tr><th>Formation</th><th>Points</th><th>Units</th></tr></thead><tbody>${rows}</tbody></table></div></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px"><button class="btn" onclick="closeModal()">Close</button><button class="btn btn-green" onclick="openInBuilder('${id}')">Open in Builder</button></div></div></div>`; }
      function duplicateList(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const now=Date.now(); const copy={...l, id:String(now), name:(l.name||'List')+' (copy)', createdAt: now, updatedAt: now}; savedLists.push(copy); persistSavedLists(); renderContent(); }
      function deleteList(id){ const idx=savedLists.findIndex(x=>x.id===id); if(idx>-1){ savedLists.splice(idx,1); persistSavedLists(); renderContent(); } }
      function copyBuilderLink(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const text=JSON.stringify(l); if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text); } alert('Builder link copied to clipboard'); }

      function openExportModal(id) {
        const list = savedLists.find(l => l.id === id);
        if (!list) return;
        const root = document.getElementById('modal-root');
        root.innerHTML = `
        <div class="modal-backdrop" onclick="closeModal()">
            <div class="modal" onclick="event.stopPropagation()">
                <h3 style="margin:0 0 12px 0">Export List: ${list.name}</h3>
                <div style="display:flex; flex-direction:column; gap:8px">
                    <button class="btn btn-blue" onclick="exportListPDF('${id}'); closeModal();">PDF</button>
                    <button class="btn btn-blue" onclick="exportListPrint('${id}'); closeModal();">Print</button>
                    <button class="btn btn-blue" onclick="exportListCSV('${id}'); closeModal();">CSV</button>
                </div>
                <div style="display:flex;justify-content:flex-end;margin-top:12px">
                    <button class="btn" onclick="closeModal()">Cancel</button>
                </div>
            </div>
        </div>`;
      }

      function exportListPrint(idOrList) {
        const list = (typeof idOrList === 'string') ? savedLists.find(l => l.id === idOrList) : idOrList;
        if (!list) return;
        
        const pointsUsed = (list.formations || []).reduce((s, f) => s + formationPoints(f), 0);
        const pointsCap = list.pointsCap || 2000;
        
        let html = `<!doctype html><html><head><meta charset="utf-8"><title>${getExportFilename(list)}</title>
        <style>
            body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; margin: 40px; color: #333; }
            h1 { border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
            .meta { margin-bottom: 30px; font-size: 1.1em; color: #666; }
            .formation { margin-bottom: 30px; page-break-inside: avoid; border: 1px solid #ccc; border-radius: 8px; overflow: hidden; }
            .formation-header { background: #f4f4f4; padding: 10px 15px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; font-weight: bold; font-size: 1.1em; }
            .unit-row { padding: 8px 15px; border-bottom: 1px solid #eee; }
            .unit-row:last-child { border-bottom: none; }
            .unit-main { display: flex; width: 100%; align-items: baseline; justify-content: space-between; }
            .unit-name { font-weight: bold; }
            .unit-meta { font-size: 0.9em; color: #666; margin-left: 10px; }
            .unit-cost { font-weight: bold; white-space: nowrap; margin-left: 10px; }
            .unit-details { font-size: 0.9em; color: #555; margin-top: 4px; padding-left: 10px; border-left: 2px solid #ddd; }
            @media print {
                body { margin: 0; }
                .formation { border: 1px solid #999; }
            }
        </style>
        </head><body>
        <h1>${list.name}</h1>
        <div class="meta">
            Faction: ${list.faction || '-'} &bull; 
            Points: <strong>${pointsUsed} / ${pointsCap}</strong>
        </div>`;
    
        (list.formations || []).forEach(f => {
            html += `<div class="formation">
                <div class="formation-header">
                    <span>${f.name}</span>
                    <span>${formationPoints(f)} pts</span>
                </div>`;
            
            const processUnits = (units) => {
                 (units || []).forEach(slot => {
                    (slot.units || []).forEach(u => {
                        const weapons = (u.weapons || []).map(w => w.name).join(', ');
                        const upgrades = (u.upgrades || []).map(up => `${up.name}${up.count ? ' x'+up.count : ''}`).join(', ');
                        const details = [weapons, upgrades].filter(x=>x).join('; ');
                        
                        html += `<div class="unit-row">
                            <div class="unit-main">
                                <div>
                                    <span class="unit-name">${u.name}</span>
                                    <span class="unit-meta">Models: ${u.models || u.baseModels || 1}</span>
                                </div>
                                <div class="unit-cost">${unitPoints(u)} pts</div>
                            </div>
                            ${details ? `<div class="unit-details">${details}</div>` : ''}
                        </div>`;
                    });
                });
            };
            
            processUnits(f.compulsory);
            processUnits(f.optional);
            if(f.special && f.special.units) {
                 (f.special.units).forEach(u => {
                    const weapons = (u.weapons || []).map(w => w.name).join(', ');
                    const upgrades = (u.upgrades || []).map(up => `${up.name}${up.count ? ' x'+up.count : ''}`).join(', ');
                    const details = [weapons, upgrades].filter(x=>x).join('; ');
                    html += `<div class="unit-row">
                        <div class="unit-main">
                            <div>
                                <span class="unit-name">${u.name}</span>
                                <span class="unit-meta">Special</span>
                            </div>
                            <div class="unit-cost">${unitPoints(u)} pts</div>
                        </div>
                        ${details ? `<div class="unit-details">${details}</div>` : ''}
                    </div>`;
                 });
            }
    
            html += `</div>`;
        });
    
        html += `</body></html>`;
        const w=window.open('', '_blank');
        if(!w) return;
        w.document.open();
        w.document.write(html);
        w.document.close();
        setTimeout(()=>{ try{ w.print(); }catch(err){} }, 300);
      }

      function exportListCSV(id) {
        const list = savedLists.find(l => l.id === id);
        if (!list) return;

        let csv = `List Name,${list.name || 'Untitled'}\n`;
        csv += `Faction,${list.faction || '-'}\n`;
        csv += `Points Limit,${list.pointsCap || 2000}\n`;
        const totalPoints = (list.formations || []).reduce((s, f) => s + formationPoints(f), 0);
        csv += `Points Used,${totalPoints}\n\n`;

        csv += `Formation,Unit,Role,Size,Points,Weapons,Upgrades\n`;

        (list.formations || []).forEach(f => {
            const formationName = f.name;
            const processUnits = (units, role) => {
                (units || []).forEach(slot => {
                    (slot.units || []).forEach(u => {
                        const name = u.name;
                        const size = u.models || u.baseModels || 1;
                        const points = unitPoints(u);
                        const weapons = (u.weapons || []).map(w => w.name).join('; ');
                        const upgrades = (u.upgrades || []).map(up => `${up.name}${up.count ? ' x'+up.count : ''}`).join('; ');
                        const escape = (s) => `"${(s || '').replace(/"/g, '""')}"`;
                        csv += `${escape(formationName)},${escape(name)},${escape(role)},${size},${points},${escape(weapons)},${escape(upgrades)}\n`;
                    });
                });
            };

            processUnits(f.compulsory, 'Compulsory');
            processUnits(f.optional, 'Optional');
            if(f.special) {
                 (f.special.units || []).forEach(u => {
                        const name = u.name;
                        const size = u.models || u.baseModels || 1;
                        const points = unitPoints(u);
                        const weapons = (u.weapons || []).map(w => w.name).join('; ');
                        const upgrades = (u.upgrades || []).map(up => `${up.name}${up.count ? ' x'+up.count : ''}`).join('; ');
                        const escape = (s) => `"${(s || '').replace(/"/g, '""')}"`;
                        csv += `${escape(formationName)},${escape(name)},Special,${size},${points},${escape(weapons)},${escape(upgrades)}\n`;
                 });
            }
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `${getExportFilename(list)}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      function openRosterExportModal() {
        let list = null;
        if(currentListId) {
            list = savedLists.find(x => x.id === currentListId);
        }
        if(!list) {
            list = {
                id: 'temp',
                name: (typeof builderMeta!=='undefined' && builderMeta.name) || 'Current List',
                faction: selectedArmy,
                gamemode: (typeof builderMeta!=='undefined' && builderMeta.gamemode) || 'Standard',
                allegiance: (typeof builderMeta!=='undefined' && builderMeta.allegiance) || 'Loyalist',
                pointsCap: (typeof builderMeta!=='undefined' && builderMeta.pointsCap) || 2000,
                formations: armyFormations || []
            };
        }
        window.tempExportList = list;
        const root = document.getElementById('modal-root');
        root.innerHTML = `
        <div class="modal-backdrop" onclick="closeModal()">
            <div class="modal" onclick="event.stopPropagation()">
                <h3 style="margin:0 0 12px 0">Export Roster: ${list.name}</h3>
                <div style="display:flex; flex-direction:column; gap:8px">
                    <button class="btn btn-blue" onclick="exportRosterPDF([window.tempExportList]); closeModal();">PDF (Detailed)</button>
                    <button class="btn btn-blue" onclick="exportRosterPrint(window.tempExportList); closeModal();">Print (Detailed)</button>
                    <button class="btn btn-blue" onclick="exportListCSV(window.tempExportList); closeModal();">CSV</button>
                </div>
                <div style="display:flex;justify-content:flex-end;margin-top:12px">
                    <button class="btn" onclick="closeModal()">Cancel</button>
                </div>
            </div>
        </div>`;
      }
      function openInBuilder(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; l.updatedAt = Date.now(); persistSavedLists(); currentListId = l.id; builderMeta = { name: l.name||'New List', gamemode: l.gamemode||'Standard', allegiance: l.allegiance||'Loyalist', pointsCap: l.pointsCap||2000 }; selectedArmy=l.faction||'Select Army'; selectedFormationName='Select a Formation'; armyFormations=JSON.parse(JSON.stringify(l.formations||[])); closeModal(); setActiveTab('army-builder'); saveState(); }
      async function exportListPDF(id){ const prev = (selectedListIds||[]).slice(); selectedListIds = [id]; try{ await exportSelectedListsPDF(); } finally { selectedListIds = prev; } }
      function listModels(id){ const l=savedLists.find(x=>x.id===id); if(!l) return; const units=(l.formations||[]).flatMap(f=>[...f.compulsory,...f.optional].flatMap(s=>s.units||[])); const total=units.reduce((s,u)=>s+(u.models||u.baseModels||1),0); const root=document.getElementById('modal-root'); root.innerHTML = `<div class="modal-backdrop" onclick="closeModal()"><div class="modal" onclick="event.stopPropagation()"><h3 style="margin:0 0 8px 0">${l.name}  Models</h3><div class="small">Total models: ${total}</div></div></div>`; }
      function buildCompactTextForList(l){ const lines=[]; const pointsCap=l.pointsCap||2000; const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); lines.push(`${l.name||'Untitled'}  ${l.faction||'-'}  ${pointsUsed}/${pointsCap} pts`); (l.formations||[]).forEach(f=>{ lines.push(`- ${f.name}: ${formationPoints(f)} pts`); [f.compulsory,f.optional].forEach(arr=>arr.forEach(s=> (s.units||[]).forEach(u=>{ lines.push(`   ${u.name} (${unitPoints(u)} pts)`);}))); if(f.special) (f.special.units||[]).forEach(u=>lines.push(`   ${u.name} (${unitPoints(u)} pts)`)); }); return lines.join('\n'); }
      async function ensureJsPDF(){ 
        if(window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.API.autoTable) return;
        
        if(!window.jspdf || !window.jspdf.jsPDF) {
            const s=document.createElement('script'); 
            s.src='https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'; 
            document.head.appendChild(s); 
            await new Promise(r=>{ s.onload=r; s.onerror=r; });
        }

        if(!window.jspdf.jsPDF.API.autoTable) {
             const s2=document.createElement('script');
             s2.src='https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js';
             document.head.appendChild(s2);
             await new Promise(r=>{ s2.onload=r; s2.onerror=r; });
        }
      }

      function getUnitStats(unitId) {
          const base = UNIT_BASE[unitId] || {};
          return {
              m: base.movement || '-',
              sv: base.save || '-',
              caf: base.CAF || '-',
              mor: base.morale || '-',
              w: base.wounds || '-',
              type: base.type || '-',
              scale: base.scale || 1
          };
      }

      function getWeaponStats(weaponName) {
          // Handle custom/suffixed names (e.g. "Weapon (Harpy)")
          let cleanName = weaponName;
          let stats = WEAPON_LIBRARY[cleanName];
          if(!stats && cleanName.includes('(')) {
              // Try removing suffix
              cleanName = cleanName.replace(/\s*\(.*?\)\s*/g, '').trim();
              stats = WEAPON_LIBRARY[cleanName];
          }
          return stats || { range:'-', dice:'-', toHit:'-', AP:'-', traits:'-' };
      }

      function getExportFilename(list) {
          const pts = (list.formations||[]).reduce((s,f)=>s+formationPoints(f),0);
          const safeName = (list.name || 'Untitled').replace(/[^a-z0-9\-\s]/gi, '_').trim();
          const safeFaction = (list.faction || 'Army').replace(/[^a-z0-9\-\s]/gi, '_').trim();
          return `${safeName} - ${safeFaction} - ${pts}pts`;
      }

      async function exportRosterPDF(explicitLists){
        const chosen = explicitLists || (savedLists||[]).filter(l=> selectedListIds.includes(l.id)); 
        if(!chosen.length) return; 
        
        try {
            await ensureJsPDF(); 
            const jsPDF = window.jspdf.jsPDF;
            const doc = new jsPDF({ unit:'pt', format:'a4' });
            
            chosen.forEach((list, listIdx) => {
                if(listIdx > 0) doc.addPage();
                
                // Header
                doc.setFontSize(18);
                doc.setFont('helvetica', 'bold');
                doc.text((list.name || 'Army Roster').toUpperCase(), 40, 40);
                
                doc.setFontSize(12);
                doc.setFont('helvetica', 'normal');
                const totalPts = (list.formations||[]).reduce((s,f)=>s+formationPoints(f),0);
                doc.text(`Faction: ${list.faction || '-'}   |   Points: ${totalPts} / ${list.pointsCap || 2000}`, 40, 60);

                let y = 80;

                (list.formations || []).forEach(f => {
                    // Check page break
                    if(y > 750) { doc.addPage(); y = 40; }

                    // Formation Header
                    doc.setFillColor(220, 220, 220);
                    doc.rect(40, y, 515, 20, 'F');
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(0,0,0);
                    doc.text(`${f.name} (${formationPoints(f)} pts)`, 45, y + 14);
                    y += 30;

                    // Collect Units
                    const allUnits = [];
                    const collect = (arr) => (arr||[]).forEach(s => (s.units||[]).forEach(u => allUnits.push(u)));
                    collect(f.compulsory);
                    collect(f.optional);
                    if(f.special && f.special.units) f.special.units.forEach(u => allUnits.push(u));

                    // Group by ID + Loadout to avoid duplicates? 
                    // User wants "Full Expanded", but readable. 
                    // Distinct unit types + unique loadouts seems best.
                    const groups = {};
                    allUnits.forEach(u => {
                        const weapons = (u.weapons||[]).map(w=>w.name).sort().join('|');
                        const upgrades = (u.upgrades||[]).map(up=>up.name).sort().join('|');
                        const key = `${u.id}__${weapons}__${upgrades}`;
                        if(!groups[key]) groups[key] = { unit: u, count: 0 };
                        groups[key].count++;
                    });

                    Object.values(groups).forEach(g => {
                        const u = g.unit;
                        const stats = getUnitStats(u.id);
                        
                        if(y > 700) { doc.addPage(); y = 40; }

                        // Unit Title Row
                        doc.setFontSize(11);
                        doc.setFont('helvetica', 'bold');
                        doc.text(`${u.name}`, 40, y);
                        doc.setFont('helvetica', 'normal');
                        doc.text(`Qty: ${g.count}`, 400, y);
                        doc.text(`${unitPoints(u)} pts/model`, 480, y);
                        y += 5;

                        // Stats Table
                        doc.autoTable({
                            startY: y,
                            head: [['Type', 'Speed', 'Save', 'CAF', 'Morale', 'Wounds']],
                            body: [[
                                `${stats.type} (${stats.scale})`, 
                                stats.m, 
                                stats.sv, 
                                stats.caf, 
                                stats.mor, 
                                stats.w
                            ]],
                            theme: 'grid',
                            headStyles: { fillColor: [50, 50, 50], textColor: 255, fontSize: 9 },
                            bodyStyles: { fontSize: 9 },
                            margin: { left: 40, right: 40 },
                            tableWidth: 515
                        });
                        y = doc.lastAutoTable.finalY + 10;

                        // Weapons Table
                        const weaponRows = (u.weapons||[]).map(w => {
                            const ws = getWeaponStats(w.name);
                            return [w.name, ws.range, ws.dice, ws.toHit, ws.AP, ws.traits];
                        });

                        if(weaponRows.length > 0) {
                            doc.autoTable({
                                startY: y,
                                head: [['Weapon', 'Range', 'Dice', 'To Hit', 'AP', 'Traits']],
                                body: weaponRows,
                                theme: 'striped',
                                headStyles: { fillColor: [100, 100, 100], textColor: 255, fontSize: 9 },
                                bodyStyles: { fontSize: 9 },
                                margin: { left: 40, right: 40 },
                                tableWidth: 515
                            });
                            y = doc.lastAutoTable.finalY + 10;
                        }

                        // Special Rules & Upgrades
                        const baseRules = UNIT_BASE[u.id]?.specialRules || [];
                        const upgradeRules = (u.upgrades||[]).filter(up => !up.type || up.type!=='BROOD_SIZE').map(up => up.name);
                        const allRules = [...new Set([...baseRules, ...upgradeRules])];

                        if(allRules.length > 0) {
                            doc.setFontSize(9);
                            doc.setFont('helvetica', 'bold');
                            doc.text('Special Rules: ', 40, y);
                            doc.setFont('helvetica', 'normal');
                            const rulesText = doc.splitTextToSize(allRules.join(', '), 430);
                            doc.text(rulesText, 110, y);
                            y += (rulesText.length * 10) + 10;
                        }
                        
                        y += 10; // Spacing between units
                    });
                    
                    y += 10; // Spacing between formations
                });
            });

            // Use name of first list
            const fName = chosen.length ? getExportFilename(chosen[0]) : 'Army_Roster';
            doc.save(`${fName}.pdf`);

        } catch(e) {
            console.error(e);
            alert('Error generating PDF: ' + e.message);
        }
      }

      function exportRosterPrint(idOrList) {
         const list = (typeof idOrList === 'string') ? savedLists.find(l => l.id === idOrList) : idOrList;
         if (!list) return;
 
         let html = `<!doctype html><html><head><title>${getExportFilename(list)}</title>
         <style>
            body { font-family: 'Helvetica Neue', Arial, sans-serif; color: #333; margin: 0; padding: 20px; }
            h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
            .meta { margin-bottom: 20px; color: #666; font-size: 1.1em; }
            .formation { margin-bottom: 30px; border: 1px solid #ccc; page-break-inside: avoid; }
            .formation-header { background: #eee; padding: 10px; font-weight: bold; border-bottom: 1px solid #ccc; display:flex; justify-content:space-between; }
            .unit-card { padding: 10px; border-bottom: 1px solid #eee; page-break-inside: avoid; }
            .unit-card:last-child { border-bottom: none; }
            .unit-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 8px; }
            .unit-name { font-weight: bold; font-size: 1.1em; }
            table { width: 100%; border-collapse: collapse; margin-bottom: 8px; font-size: 0.9em; }
            th, td { border: 1px solid #ddd; padding: 4px 8px; text-align: left; }
            th { background: #f9f9f9; font-weight: bold; }
            .rules { font-size: 0.9em; color: #444; }
            .label { font-weight: bold; color: #222; }
            @media print {
                body { padding: 0; }
                .formation { border: 1px solid #000; }
                .formation-header { background: #ddd; color: #000; }
            }
         </style>
         </head><body>
         <h1>${list.name}</h1>
         <div class="meta">Faction: ${list.faction || '-'} &bull; Points: ${(list.formations||[]).reduce((s,f)=>s+formationPoints(f),0)} / ${list.pointsCap}</div>`;

         (list.formations || []).forEach(f => {
             html += `<div class="formation">
                <div class="formation-header"><span>${f.name}</span><span>${formationPoints(f)} pts</span></div>`;
             
             const allUnits = [];
             const collect = (arr) => (arr||[]).forEach(s => (s.units||[]).forEach(u => allUnits.push(u)));
             collect(f.compulsory);
             collect(f.optional);
             if(f.special && f.special.units) f.special.units.forEach(u => allUnits.push(u));

             const groups = {};
             allUnits.forEach(u => {
                const weapons = (u.weapons||[]).map(w=>w.name).sort().join('|');
                const upgrades = (u.upgrades||[]).map(up=>up.name).sort().join('|');
                const key = `${u.id}__${weapons}__${upgrades}`;
                if(!groups[key]) groups[key] = { unit: u, count: 0 };
                groups[key].count++;
             });

             Object.values(groups).forEach(g => {
                 const u = g.unit;
                 const stats = getUnitStats(u.id);
                 const baseRules = UNIT_BASE[u.id]?.specialRules || [];
                 const upgradeRules = (u.upgrades||[]).filter(up => !up.type || up.type!=='BROOD_SIZE').map(up => up.name);
                 const allRules = [...new Set([...baseRules, ...upgradeRules])];

                 html += `<div class="unit-card">
                    <div class="unit-header">
                        <span class="unit-name">${u.name} ${g.count > 1 ? `(x${g.count})` : ''}</span>
                        <span>${unitPoints(u)} pts/model</span>
                    </div>
                    
                    <table>
                        <thead><tr><th>Type</th><th>Speed</th><th>Save</th><th>CAF</th><th>Morale</th><th>Wounds</th></tr></thead>
                        <tbody><tr>
                            <td>${stats.type} (${stats.scale})</td>
                            <td>${stats.m}</td>
                            <td>${stats.sv}</td>
                            <td>${stats.caf}</td>
                            <td>${stats.mor}</td>
                            <td>${stats.w}</td>
                        </tr></tbody>
                    </table>

                    ${(u.weapons && u.weapons.length) ? `
                    <table>
                        <thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead>
                        <tbody>
                            ${u.weapons.map(w => {
                                const ws = getWeaponStats(w.name);
                                return `<tr>
                                    <td>${w.name}</td>
                                    <td>${ws.range}</td>
                                    <td>${ws.dice}</td>
                                    <td>${ws.toHit}</td>
                                    <td>${ws.AP}</td>
                                    <td>${ws.traits}</td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>` : '<div style="font-style:italic; font-size:0.9em; margin-bottom:8px">No Weapons</div>'}

                    ${allRules.length ? `<div class="rules"><span class="label">Special Rules:</span> ${allRules.join(', ')}</div>` : ''}
                 </div>`;
             });

             html += `</div>`;
         });

         html += `</body></html>`;
         
         const w = window.open('', '_blank');
         if(w) {
             w.document.open();
             w.document.write(html);
             w.document.close();
             setTimeout(() => { try{ w.print(); }catch(e){} }, 500);
         }
      }

      async function exportSelectedListsPDF(explicitLists){ const chosen=explicitLists || (savedLists||[]).filter(l=> selectedListIds.includes(l.id)); if(!chosen.length) return; try{ await ensureJsPDF(); const jsPDF = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : null; if(!jsPDF) throw new Error('jsPDF unavailable'); const doc=new jsPDF({ unit:'pt', format:'a4' }); const pageW=doc.internal.pageSize.getWidth(); const pageH=doc.internal.pageSize.getHeight(); const margin=36; const lineH=14; const colText=[31,41,55]; const colHeader=[63,58,54]; const colLight=[211,207,201]; const drawHeader=(title, meta)=>{ doc.setFillColor(colHeader[0],colHeader[1],colHeader[2]); doc.rect(0,0,pageW,42,'F'); doc.setTextColor(255,255,255); doc.setFont('times','bold'); doc.setFontSize(15); doc.text(String(title||'Army Lists').toUpperCase(), margin, 26); doc.setFillColor(colLight[0],colLight[1],colLight[2]); doc.rect(0,42,pageW,28,'F'); doc.setTextColor(colText[0],colText[1],colText[2]); doc.setFont('times','normal'); doc.setFontSize(12); if(meta){ doc.text(meta, margin, 60); } }; const drawSectionHead=(label)=>{ const y=doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : null; }; const ensureSpace=(needed)=>{ const y=state.y; if(y + needed > pageH - margin){ doc.addPage(); drawHeader('Army Lists',''); state.y = 42 + 28 + margin/2; } }; const state={ y: 42 + 28 + margin/2 }; const lists=chosen.slice(); lists.forEach((l,idx)=>{ if(idx===0){ const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; drawHeader(l.name||'Untitled', `Army: ${l.faction||'-'}  Points: ${pointsUsed}/${pointsCap}`); state.y = 42 + 28 + margin/2; } else { doc.addPage(); const pointsUsed=(l.formations||[]).reduce((s,f)=>s+formationPoints(f),0); const pointsCap=l.pointsCap||2000; drawHeader(l.name||'Untitled', `Army: ${l.faction||'-'}  Points: ${pointsUsed}/${pointsCap}`); state.y = 42 + 28 + margin/2; }
        const fms=(l.formations||[]); fms.forEach(f=>{ ensureSpace(28); doc.setFillColor(colLight[0],colLight[1],colLight[2]); doc.rect(margin, state.y, pageW - margin*2, 22, 'F'); doc.setTextColor(colText[0],colText[1],colText[2]); doc.setFont('times','bold'); doc.setFontSize(12); doc.text(`${f.name}: ${formationPoints(f)} pts`, margin+8, state.y+15); state.y += 38; doc.setFont('times','normal'); doc.setFontSize(11); 
        
        const units = [];
        const collect = (arr) => (arr||[]).forEach(s => (s.units||[]).forEach(u => units.push(u)));
        collect(f.compulsory);
        collect(f.optional);
        if(f.special && f.special.units) f.special.units.forEach(u => units.push(u));

        units.forEach(u => {
            const weapons = (u.weapons || []).map(w => w.name).join(', ');
            const upgrades = (u.upgrades || []).map(up => `${up.name}${up.count ? ' x'+up.count : ''}`).join(', ');
            const details = [weapons, upgrades].filter(x=>x).join('; ');
            const models = u.models || u.baseModels || 1;
            
            const line1 = ` ${u.name} (${models} models, ${unitPoints(u)} pts)`;
            ensureSpace(lineH);
            doc.text(line1, margin, state.y);
            state.y += lineH;
            
            if(details) {
                doc.setFontSize(10);
                doc.setTextColor(60,60,60);
                const detailLines = doc.splitTextToSize(details, pageW - margin*2 - 16);
                detailLines.forEach(l => {
                    ensureSpace(12);
                    doc.text(l, margin + 12, state.y);
                    state.y += 12;
                });
                doc.setFontSize(11);
                doc.setTextColor(colText[0],colText[1],colText[2]);
                state.y += 6;
            } else {
                state.y += 4;
            }
        });
        state.y += 12;
        }); }); 
        
        const fName = chosen.length ? getExportFilename(chosen[0]) : 'Army_Lists';
        doc.save(`${fName}.pdf`);
        
        }catch(e){ console.error(e); const chosenText=(savedLists||[]).filter(l=> selectedListIds.includes(l.id)).map(buildCompactTextForList).join('\n\n'); const html=`<!doctype html><html><head><meta charset=\"utf-8\"><title>Export</title><style>body{font-family:Georgia,Times,serif;margin:24px;color:#1f2937}h1{font-size:18px;margin:0 0 12px}pre{white-space:pre-wrap;font-size:13px;line-height:1.45;border:1px solid #c6c2bd;padding:12px;border-radius:6px;background:#f7f7f7}</style></head><body><h1>Army Lists</h1><pre>${chosenText.replace(/</g,'&lt;')}</pre></body></html>`; const w=window.open('', '_blank'); if(!w) return; w.document.open(); w.document.write(html); w.document.close(); setTimeout(()=>{ try{ w.print(); }catch(err){} }, 300); } }



      function openAutoGenerateModal(){
        const root = document.getElementById('modal-root');
        const armyOptions = Object.keys(ARMIES).map(a => `<option value="${a}" ${a === selectedArmy ? 'selected' : ''}>${a}</option>`).join('');
        const styleOptions = Object.keys(ARMY_STYLES).map(s => `<option value="${s}" ${s === selectedAutoStyle ? 'selected' : ''}>${s}</option>`).join('');

        if(!styleComposition || Object.keys(styleComposition).length === 0) {
           styleComposition = JSON.parse(JSON.stringify(ARMY_STYLES[selectedAutoStyle] || ARMY_STYLES['All Round']));
        }
        
        // Initial Name Check
        let initialName = builderMeta.name || 'Auto Army';
        if (initialName === 'Auto Army' || initialName === 'New List' || Object.keys(ARMY_STYLES).includes(initialName)) {
             initialName = selectedAutoStyle;
        }

        root.innerHTML = `
          <div class="modal-backdrop" onclick="closeModal()">
            <div class="modal" onclick="event.stopPropagation()">
              <h3>Auto Generate Army</h3>
              <div style="margin-bottom:16px; color:#cbd5e1">
                Configure your army settings below. This will generate a random valid list based on your criteria.
              </div>
              
              <div class="form-group">
                <label>Faction</label>
                <select id="auto-gen-faction" class="form-control" style="background:#1f2937; color:#fff; border:1px solid #374151; padding:8px; width:100%; border-radius:4px">
                  ${armyOptions}
                </select>
              </div>

              <div class="form-group" style="margin-top:12px">
                <label>Army Tactic</label>
                <select id="auto-gen-style" class="form-control" style="background:#1f2937; color:#fff; border:1px solid #374151; padding:8px; width:100%; border-radius:4px" onchange="updateAutoGenerateStyle(this.value)">
                  ${styleOptions}
                </select>
              </div>

              <div class="form-group" style="margin-top:12px">
                <label>Unit Composition Weights</label>
                <div id="auto-gen-composition" style="max-height: 200px; overflow-y: auto; border: 1px solid #374151; padding: 8px; border-radius: 4px; background: rgba(0,0,0,0.2);">
                  <!-- Composition inputs go here -->
                </div>
              </div>

              <div class="form-group" style="margin-top:12px">
                <label>List Name</label>
                <input id="auto-gen-name" type="text" class="form-control" value="${initialName}" style="background:#1f2937; color:#fff; border:1px solid #374151; padding:8px; width:100%; border-radius:4px"/>
              </div>

              <div class="form-group" style="margin-top:12px">
                <label>Points Limit</label>
                <input id="auto-gen-points" type="number" class="form-control" value="${builderMeta.pointsCap || 2000}" min="500" max="5000" step="500" style="background:#1f2937; color:#fff; border:1px solid #374151; padding:8px; width:100%; border-radius:4px" onchange="const v=Number(this.value); if(v<500)this.value=500; if(v>5000)this.value=5000;"/>
              </div>

              <div class="modal-actions" style="margin-top:24px; display:flex; justify-content:flex-end; gap:12px">
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn btn-green" onclick="handleAutoGenerateConfirm()">Generate</button>
              </div>
            </div>
          </div>
        `;
        updateAutoGenerateCompositionView();
      }

      function updateAutoGenerateStyle(val) {
        selectedAutoStyle = val;
        styleComposition = JSON.parse(JSON.stringify(ARMY_STYLES[val] || ARMY_STYLES['All Round']));
        updateAutoGenerateCompositionView();
        
        // Auto-update name
        const nameInput = document.getElementById('auto-gen-name');
        if(nameInput) {
            const current = nameInput.value;
            // Only update if it's the default or matches a previous style name
            if(current === 'Auto Army' || Object.keys(ARMY_STYLES).includes(current)) {
                nameInput.value = val;
            }
        }
      }

      function updateAutoGenerateCompositionView() {
        const container = document.getElementById('auto-gen-composition');
        if(!container) return;
        
        const html = Object.entries(styleComposition).map(([role, weight]) => `
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px">
                <label style="font-size:12px; color:#cbd5e1; width: 100px;">${role}</label>
                <input type="range" min="0" max="10" value="${weight}" 
                    oninput="this.nextElementSibling.value = this.value; styleComposition['${role}'] = Number(this.value)"
                    style="flex-grow: 1; margin: 0 8px;" />
                <input type="number" min="0" max="10" value="${weight}" 
                    onchange="this.previousElementSibling.value = this.value; styleComposition['${role}'] = Number(this.value)"
                    style="width:40px; background:#1f2937; color:#fff; border:1px solid #374151; padding:4px; border-radius:4px; text-align:center" />
            </div>
        `).join('');
        
        container.innerHTML = html;
      }

      function generateRandomArmy(faction, pointsCap, styleWeights) {
          // 1. Initialize
          armyFormations = [];
          const MAX_RETRIES = 10;
          const TOLERANCE = 50;
          let currentPoints = 0;
          
          // Helper to get formation definitions for faction
          const availForms = ARMIES[faction]?.formations || [];
          if (!availForms.length) {
              alert('No formations available for this faction.');
              return;
          }

          // 2. Add Primary Formation
          // Pick based on style? For now random from available
          const primaryName = availForms[Math.floor(Math.random() * availForms.length)];
          // addFormationByName(primaryName); // REMOVED: Caused ReferenceError, using manual creation below
          
          // We will manipulate armyFormations directly.
          
          // Reset formations for clean generation
          armyFormations = [];
          
          function createFormation(name) {
              const rules = FORMATIONS[name];
              if (!rules) return null;
              
              // Deep copy structure
              return {
                  name: name,
                  army: faction,
                  compulsory: JSON.parse(JSON.stringify(rules.compulsory || [])),
                  optional: JSON.parse(JSON.stringify(rules.optional || [])),
                  special: rules.special ? JSON.parse(JSON.stringify(rules.special)) : null,
                  rules: rules.rules || [],
                  collapsed: false
              };
          }

          const f1 = createFormation(primaryName);
          if(f1) armyFormations.push(f1);
          
          // 3. Fill Compulsory Slots
          armyFormations.forEach(f => {
              (f.compulsory || []).forEach(slot => {
                  const valid = unitsFor(slot.type); // unitsFor uses selectedArmy global
                  if (valid.length) {
                      // Strategy: Balance cheapness with tactical fit
                      // 1. Calculate tactical score for each unit
                      const scored = valid.map(u => {
                          const tac = analyzeUnitTactics(u.id);
                          const styleScore = tac[selectedAutoStyle] || 0;
                          return { u, score: styleScore, points: Number(UNIT_BASE[u.id]?.points)||0 };
                      });

                      // 2. Filter out overly expensive units (e.g. > 25% of points cap for a single compulsory slot)
                      // unless it's the only option.
                      const threshold = pointsCap * 0.25;
                      let candidates = scored.filter(x => x.points < threshold);
                      if (candidates.length === 0) candidates = scored; // Fallback

                      // 3. Sort by Score descending, then Points ascending
                      candidates.sort((a,b) => {
                          if (Math.abs(b.score - a.score) > 20) return b.score - a.score; // Significant tactical advantage wins
                          return a.points - b.points; // Otherwise save points
                      });
                      
                      const pick = candidates[0].u;
                      // Create unit instance
                      const uInstance = createUnitInstance(pick.id);
                      slot.units = [uInstance];
                  }
              });
          });

          // Recalculate points
          currentPoints = armyFormations.reduce((s,f) => s + formationPoints(f), 0);

          // 4. Fill Loop
          let loopCount = 0;
          while (currentPoints < pointsCap - TOLERANCE && loopCount < 100) {
              loopCount++;
              
              // Identify Candidates
              const candidates = [];
              
              // A. Add Unit to Optional Slot
              armyFormations.forEach((f, fIdx) => {
                  (f.optional || []).forEach((slot, sIdx) => {
                      // Check if slot is empty (assuming 1 unit per slot for now unless merged)
                      // Logic: standard slots take 1 unit.
                      if (!slot.units || slot.units.length === 0) {
                          const valid = unitsFor(slot.type);
                          valid.forEach(uDef => {
                              const cost = Number(UNIT_BASE[uDef.id]?.points) || 0;
                              if (currentPoints + cost <= pointsCap) {
                                  // Analyze Tactics
                                  const tac = analyzeUnitTactics(uDef.id);
                                  const tacticalScore = tac[selectedAutoStyle] || 0;
                                  
                                  candidates.push({
                                      type: 'ADD_UNIT',
                                      fIdx, sIdx, slotType: 'optional',
                                      unitId: uDef.id,
                                      cost: cost,
                                      role: uDef.slotType, // e.g. Core, HQ
                                      tacticalScore: tacticalScore
                                  });
                              }
                          });
                      }
                  });
              });

              // B. Upgrade Existing Units (Brood size)
              armyFormations.forEach((f, fIdx) => {
                 ['compulsory','optional'].forEach(sec => {
                     (f[sec]||[]).forEach((slot, sIdx) => {
                         (slot.units||[]).forEach((u, uIdx) => {
                             // Check for BROOD_SIZE upgrades
                             const loadout = UNIT_LOADOUTS[u.id];
                             if(!loadout) return;
                             (loadout.upgrades||[]).forEach(up => {
                                 if(up.type === 'BROOD_SIZE') {
                                     // Check if we can add more
                                     // Current models
                                     const currentModels = u.models || u.baseModels || UNIT_DEFAULT_MODELS[u.id] || 1;
                                     const max = up.maxModels || UNIT_MAX_MODELS[u.id] || 100;
                                     if (currentModels < max) {
                                         const cost = up.points; // Per step
                                         if (currentPoints + cost <= pointsCap) {
                                              // Tactical score for upgrade? 
                                              // Assume adding more of a "good" unit is good.
                                              const tac = analyzeUnitTactics(u.id);
                                              const tacticalScore = tac[selectedAutoStyle] || 0;

                                              candidates.push({
                                                  type: 'UPGRADE_SIZE',
                                                  fIdx, sec, sIdx, uIdx,
                                                  unitId: u.id,
                                                  cost: cost,
                                                  role: slot.type,
                                                  upgradeId: up.id,
                                                  delta: up.modelsDelta || 1,
                                                  tacticalScore: tacticalScore
                                              });
                                         }
                                     }
                                 }
                             });
                         });
                     });
                 });
              });
              
              // C. Add New Formation (if we have lots of points)
              if (pointsCap - currentPoints > 600) { // arbitrary threshold
                  availForms.forEach(fname => {
                       // Estimate min cost of formation
                       // For simplicity, assume ~200-300.
                       // We'll just add candidate.
                       candidates.push({
                           type: 'ADD_FORMATION',
                           name: fname,
                           cost: 300, // Estimate
                           role: 'Formation',
                           tacticalScore: 0 // Formations themselves don't have score yet, maybe avg of compulsory?
                       });
                  });
              }

              if (candidates.length === 0) break;

              // Synergy Cache
              const existingKeywords = new Set();
              armyFormations.forEach(f => {
                  ['compulsory','optional','special'].forEach(k => {
                      if(f[k] && Array.isArray(f[k])) {
                          f[k].forEach(slot => {
                              (slot.units||[]).forEach(u => {
                                  (UNIT_LOADOUTS[u.id]?.specialRules || []).forEach(r => existingKeywords.add(r.split('(')[0].trim().toLowerCase()));
                                  existingKeywords.add(u.type); // e.g. INFANTRY
                              });
                          });
                      } else if(f.special && f.special.units) {
                          f.special.units.forEach(u => {
                              (UNIT_LOADOUTS[u.id]?.specialRules || []).forEach(r => existingKeywords.add(r.split('(')[0].trim().toLowerCase()));
                          });
                      }
                  });
              });

              // Scoring
              candidates.forEach(c => {
                  let score = 0;
                  
                  // 1. Role Weight (Base)
                  const roleWeight = styleWeights[c.role] || styleWeights['Core'] || 1; 
                  score += roleWeight * 10;
                  
                  // 2. Tactical Bonus (The big new feature)
                  // If unit fits archetype, boost significantly
                  score += (c.tacticalScore || 0) * 1.5;

                  // 3. Synergy/Variety
                  // Prefer filling empty slots over upgrades slightly
                  if (c.type === 'ADD_UNIT') {
                      score += 5;
                      
                      // Synergy Check
                      if(c.unitId) {
                          const rules = (UNIT_LOADOUTS[c.unitId]?.specialRules || []).map(r => r.split('(')[0].trim().toLowerCase());
                          let synergy = 0;
                          rules.forEach(r => {
                              if(existingKeywords.has(r)) synergy += 1;
                          });
                          score += Math.min(synergy, 5); // Cap synergy bonus
                      }
                  }
                  
                  // Random Factor (keep it interesting)
                  score += Math.random() * 15;
                  
                  c.score = score;
              });

              // Pick Winner
              candidates.sort((a,b) => b.score - a.score);
              const winner = candidates[0];

              // Execute
              if (winner.type === 'ADD_UNIT') {
                  const uInstance = createUnitInstance(winner.unitId);
                  armyFormations[winner.fIdx].optional[winner.sIdx].units = [uInstance];
              } else if (winner.type === 'UPGRADE_SIZE') {
                  const u = armyFormations[winner.fIdx][winner.sec][winner.sIdx].units[winner.uIdx];
                  // Mark upgrade as applied?
                  // The system uses u.upgrades array {id, count}
                  u.upgrades = u.upgrades || [];
                  const existing = u.upgrades.find(x => x.id === winner.upgradeId);
                  if (existing) {
                      existing.count = (existing.count || 0) + 1;
                  } else {
                      u.upgrades.push({ id: winner.upgradeId, count: 1 });
                  }
                  
                  // Update models count on instance for quick calculation
                  u.models = (u.models || (u.baseModels || UNIT_DEFAULT_MODELS[u.id] || 1)) + winner.delta;
              } else if (winner.type === 'ADD_FORMATION') {
                  const nf = createFormation(winner.name);
                  if(nf) {
                      // Must fill compulsory immediately to be valid?
                      // Yes, let's fill compulsory for new formation immediately
                      // If points exceed, we revert.
                      let tempCost = 0;
                      nf.compulsory.forEach(slot => {
                          const valid = unitsFor(slot.type).sort((a,b) => (Number(UNIT_BASE[a.id]?.points)||0) - (Number(UNIT_BASE[b.id]?.points)||0));
                          if(valid.length) {
                              const pick = valid[0];
                              tempCost += (Number(UNIT_BASE[pick.id]?.points)||0);
                              slot.units = [createUnitInstance(pick.id)];
                          }
                      });
                      
                      if (currentPoints + tempCost <= pointsCap) {
                          armyFormations.push(nf);
                      }
                  }
              }
              
              // Recalc
              currentPoints = armyFormations.reduce((s,f) => s + formationPoints(f), 0);
          }
          
          renderContent();
          saveState();
      }

      function createUnitInstance(unitId) {
          // Helper to create a fresh unit object
          const base = UNIT_BASE[unitId] || {};
          const defModels = UNIT_DEFAULT_MODELS[unitId] || 1;
          return {
              id: unitId,
              name: base.name || unitId, // Should use slugToName if name missing
              models: defModels,
              baseModels: defModels,
              points: base.points,
              upgrades: [],
              _uuid: Math.random().toString(36).substr(2, 9) // Unique ID for UI handling
          };
      }

      function handleAutoGenerateConfirm(){
        const faction = document.getElementById('auto-gen-faction').value;
        const name = document.getElementById('auto-gen-name').value;
        const points = Number(document.getElementById('auto-gen-points').value);

        if(faction === 'Select Army'){
          alert('Please select a faction.');
          return;
        }

        // Update Builder State
        selectedArmy = faction;
        builderMeta.name = name;
        builderMeta.pointsCap = points;

        // Ensure data is loaded
        loadConsolidatedArmyMaster(faction).then(() => {
             console.log('Generating army for:', faction, name, points);
             console.log('Selected Style:', selectedAutoStyle);
             console.log('Composition:', styleComposition);
             
             generateRandomArmy(faction, points, styleComposition);
             
             closeModal();
             // renderContent handled in generate
        });
      }

      function renderArmyBuilder(){
        const armyOptions = Object.keys(ARMIES).map(a => `<option value="${a}" ${a === selectedArmy ? 'selected' : ''}>${a}</option>`).join('');
        const formationList = ARMIES[selectedArmy]?.formations || [];
        const formationOptions = ['Select a Formation', ...formationList].map(n => `<option value="${n}" ${n === selectedFormationName ? 'selected' : ''}>${n}</option>`).join('');
        const listTotal = armyFormations.reduce((s,f)=>s + formationPoints(f), 0);
        const listModels = (armyFormations||[]).reduce((s,f)=> s + totalModelsInFormation(f), 0);
        const formsHtml = armyFormations.length ? armyFormations.map((f,i)=>renderFormationCard(f,i)).join('') : `<div class="muted small p-4">No formations yet.</div>`;
        const allegianceOptions = ['Loyalist','Traitor'].map(a=>`<option value="${a}" ${a===builderMeta.allegiance?'selected':''}>${a}</option>`).join('');
        
        const cap = builderMeta.pointsCap || 2000;
        const diff = listTotal - cap;
        const autoGenBtn = (armyFormations.length === 0) ? `<button class="btn btn-sm btn-blue" style="margin-left:12px" onclick="openAutoGenerateModal()">Auto Generate</button>` : '';
        let warnHtml = '';
        if(diff > 0) {
          warnHtml = `<span style="color:#ef4444;margin-left:8px;font-weight:bold">Game Size Exceeded: +${diff}</span>`;
        } else {
          warnHtml = `<span style="color:#22c55e;margin-left:8px;font-weight:bold">Points Remaining: ${Math.abs(diff)}</span>`;
        }

        return `
          <div style="padding:12px">
            <div class="crumbs small muted">Lists  Builder</div>
            <div class="builder-bar">
              <div class="builder-controls-row"><label class="small muted">Faction</label><select class="select-compact" onchange="handleArmySelection(this.value)">${armyOptions}</select><label class="small muted">Name</label><input class="mini-input" value="${builderMeta.name}" onchange="setBuilderName(this.value)"/><label class="small muted">Game size</label><input type="number" class="mini-input" value="${builderMeta.pointsCap}" onchange="setBuilderPoints(this.value)"/> pts ${autoGenBtn}</div>
              <div class="summary small">Formations: ${armyFormations.length}  Total: ${listTotal} pts  Total models: ${listModels}${warnHtml}</div>
            </div>
            <div class="builder-controls"><select id="formation-select" class="select-compact" onchange="handleFormationSelection(this.value)">${formationOptions}</select><button class="btn btn-green btn-sm" onclick="addFormation()">+ Add Formation</button></div>
            ${formsHtml}
            <div class="builder-footer">List total: ${listTotal} pts  ${selectedArmy!=='Select Army'?selectedArmy+': '+listTotal+' pts':'Faction: -'}  Formations: ${armyFormations.length}</div>
          </div>`;
      }



      function formationHasMinViolations(f){

        if(!f || !f.compulsory) return false;

        return f.compulsory.some(slot => (slot.min || 0) > (slot.units ? slot.units.length : 0));

      }



      function renderFormationCard(f, idx){
        const total = formationPoints(f);
        const baseName = getBaseFormationName(f.name);
        const fRules = (FORMATIONS[baseName] && FORMATIONS[baseName].rules) || f.rules || [];
        const rulesHtml = fRules.length ? 
          `<div style="margin-top:4px;padding-top:4px;border-top:1px solid rgba(0,0,0,0.1);display:flex;flex-wrap:wrap;gap:8px">
            ${fRules.map(r => {
               if(typeof r === 'string' && r.indexOf(':') > -1){
                 const idx = r.indexOf(':');
                 const title = r.substring(0, idx).trim();
                 return `<span class="badge" onclick="event.preventDefault();event.stopPropagation();openRuleDialog('${title.replace(/'/g,"\\'")}')" style="cursor:pointer;background:rgba(255,255,255,0.1);padding:2px 6px;border-radius:4px;font-size:11px;color:#e6eef8;border:1px solid rgba(255,255,255,0.2)">${title}</span>`;
               }
               return `<span class="badge" onclick="event.preventDefault();event.stopPropagation();openRuleDialog('${r.replace(/'/g,"\\'")}')" style="cursor:pointer;background:rgba(255,255,255,0.1);padding:2px 6px;border-radius:4px;font-size:11px;color:#e6eef8;border:1px solid rgba(255,255,255,0.2)">${r}</span>`;
            }).join('')}
          </div>` : '';

        const header = `
          <div class="formation-header" onclick="toggleCollapse(${idx})" style="cursor:pointer">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div>
                <strong class="roster-title">${f.name}</strong>
                <div class="small muted">${f.army}</div>
                ${rulesHtml}
              </div>
              <div class="mini-icons"><button class="btn btn-xs btn-blue" title="Clone" onclick="event.stopPropagation();cloneFormation(${idx})"></button><button class="btn btn-xs btn-red" title="Delete" onclick="event.stopPropagation();removeFormation(${idx})"></button></div>
            </div>
          </div>`;
        if(f.collapsed) return header;
        const compHtml = f.compulsory.map((slot,sIdx)=>renderSlotBlock(f,idx,'compulsory',sIdx,slot)).join('');
        const optHtml = f.optional.map((slot,sIdx)=>renderSlotBlock(f,idx,'optional',sIdx,slot)).join('');
        const specialHtml = f.special ? renderSpecialBlock(f,idx,f.special) : `<div class="muted small">No special slots</div>`;
        const hasEmptyComp = (f.compulsory||[]).some(s => (s.min||0) > ((s.units||[]).length));
        const grid = `
          <div class="section-bar">~ COMPULSORY SLOTS ~</div>
          <div class="slot-row">${compHtml}</div>
          <div class="section-bar alt">~ OPTIONAL SLOTS ~</div>
          <div class="slot-row">${optHtml}</div>
          <div class="section-bar">~ SPECIAL ~</div>
          <div class="slot-row">${specialHtml}</div>`;
        return header + grid;
      }



      function renderSlotBlock(f,fIdx,section,sIdx,slot){

        const allowed = unitsFor(slot.type);
        const selectedId = (slot._selectedUnitId || (((slot.units||[])[0]||{}).id) || '');
        const options = `<option value="">Select unit</option>` + allowed.map(u=>`<option value="${u.id}" ${u.id===selectedId?'selected':''}>${u.name}</option>`).join('');

        const selectedUnit = (slot.units||[])[0] || null;
        const unitSize = selectedUnit ? (selectedUnit.models || selectedUnit.baseModels || '-') : 0;
        const slotPts = selectedUnit ? unitPoints(selectedUnit) : 0;
        const base = selectedUnit ? (UNIT_BASE[selectedUnit.id]||{}) : {};
        const uType = base.type ? String(base.type).toUpperCase() : '';
        const uScale = base.scale || 1;
        const baseSize = base.base_size ? ` | ${base.base_size}` : '';
        const typeStr = (uType ? ` | ${uType} (${uScale})` : '') + baseSize;
        const unitsHtml = selectedUnit ? `
          <div class="unit-item"><div class="u-actions"><button class="btn btn-xs btn-blue" onclick="window.openEditModal(${fIdx},'${section}',${sIdx},0)">Upgrades</button><button class="btn btn-xs btn-red" title="Remove" onclick="window.removeUnit(${fIdx},'${section}',${sIdx},0)"></button></div></div>
        ` : `<div class="small muted" style="margin-top:6px">Select unit</div>`;
        const loadList = selectedUnit && (selectedUnit.weapons||[]).length ? `<div class="slot-details"><span class="label">Loadout</span> ${(selectedUnit.weapons||[]).map(w=>w.name).join(', ')}</div>` : '';
        const upItems = selectedUnit ? ([]).concat(
          (selectedUnit.upgrades||[]).map(u=>{ const cnt=Number(u.count||0); if(u.type==='BROOD_SIZE'){ const step=(UNIT_BROOD_STEP&&UNIT_BROOD_STEP[selectedUnit.id])||1; const delta=cnt? step*cnt : (u.modelsDelta||0); return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}${delta? ' (+'+delta+' models)':''}`; } else { return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}`; } }),
          (selectedUnit.psychic||[]).map(p=>`${p.name}${p.points? ' +'+p.points+'pts':''}`)
        ) : [];
        const upList = selectedUnit && upItems.length ? `<div class="slot-details"><span class="label">Upgrades</span> ${upItems.join(', ')}</div>` : '';
        const selectHtml = `<select class="select-compact" onchange="setSlotSelection(${fIdx},'${section}',${sIdx}, this.value)">${options}</select>`;
        return `<div class="slot-compact"><div class="slot-pill">${slot.label}${slot._group?` #${slot._group.index}`:''}</div><div class="slot-meta-row">Unit size: ${unitSize}${typeStr} <span class="cost">${slotPts} PTS</span></div><div class="slot-select">${selectHtml}</div>${unitsHtml}${loadList}${upList}</div>`;

      }



      function renderSpecialBlock(f,fIdx,special){
        const key = armyKey(selectedArmy);
        const list = ARMY_UNIT_LIST[key] || [];
        const allowedUnits = list.filter(u => special.allowedTypes.includes(u.slotType));
        const selectedId = (armyFormations[fIdx].special._selectedUnitId || (((special.units||[])[0]||{}).id) || '');
        const options = `<option value="">Select unit</option>` + allowedUnits.map(u=>`<option value="${u.id}" ${u.id===selectedId?'selected':''}>${u.name}</option>`).join('');
        const selectedUnit = (special.units||[])[0] || null;
        const unitSize = selectedUnit ? (selectedUnit.models || selectedUnit.baseModels || '-') : 0;
        const slotPts = selectedUnit ? unitPoints(selectedUnit) : 0;
        const base = selectedUnit ? (UNIT_BASE[selectedUnit.id]||{}) : {};
        const uType = base.type ? String(base.type).toUpperCase() : '';
        const uScale = base.scale || 1;
        const baseSize = base.base_size ? ` | ${base.base_size}` : '';
        const typeStr = (uType ? ` | ${uType} (${uScale})` : '') + baseSize;
        const unitsHtml = selectedUnit ? `
          <div class="unit-item"><div class="u-actions"><button class="btn btn-xs btn-blue" onclick="window.openEditModal(${fIdx},'special',0,0)">Upgrades</button><button class="btn btn-xs btn-red" title="Remove" onclick="window.removeSpecialUnit(${fIdx},0)"></button></div></div>
        ` : `<div class="small muted" style="margin-top:6px">Select unit</div>`;
        const loadList = selectedUnit && (selectedUnit.weapons||[]).length ? `<div class="slot-details"><span class="label">Loadout</span> ${(selectedUnit.weapons||[]).map(w=>w.name).join(', ')}</div>` : '';
        const upItems = selectedUnit ? ([]).concat(
          (selectedUnit.upgrades||[]).map(u=>{ const cnt=Number(u.count||0); if(u.type==='BROOD_SIZE'){ const step=(UNIT_BROOD_STEP&&UNIT_BROOD_STEP[selectedUnit.id])||1; const delta=cnt? step*cnt : (u.modelsDelta||0); return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}${delta? ' (+'+delta+' models)':''}`; } else { return `${u.name}${cnt? ' x'+cnt:''}${u.points? ' +'+u.points+'pts':''}`; } }),
          (selectedUnit.psychic||[]).map(p=>`${p.name}${p.points? ' +'+p.points+'pts':''}`)
        ) : [];
        const upList = selectedUnit && upItems.length ? `<div class="slot-details"><span class="label">Upgrades</span> ${upItems.join(', ')}</div>` : '';
        const selectHtml = `<select class="select-compact" onchange="addUnitToSpecial(${fIdx}, this.value)">${options}</select>`;
        return `<div class="slot-compact"><div class="slot-pill">${special.label}</div><div class="slot-meta-row">Unit size: ${unitSize}${typeStr} <span class="cost">${slotPts} PTS</span></div><div class="slot-select">${selectHtml}</div>${unitsHtml}${loadList}${upList}</div>`;
      }



      const FACTION_RULES = {
        Tyranids: [
          { title: 'Tactics: New Orders', items: [
            'Rampage: Must move at double rate toward the nearest enemy model. If it contacts an enemy model it stops and fights in close combat during the combat phase. If the closest path would pass through impassable terrain, move around it following the shortest path.',
            'Hunt: Moves at normal rate toward the nearest enemy model not already in close combat, moving into close combat if possible. If not pinned and not in close combat during the combat phase, it shoots at the nearest enemy model in the advance fire segment.',
            'Nest: Does not move but shoots at the nearest enemy model in the first fire segment of the combat phase.'
          ]},
          { title: 'Tactics: Objectives', items: [
            'Tyranid armies do not score victory points from holding objective counters. Their aim is to bring enemy forces to battle and crush resistance for biomass consumption.'
          ]},
          { title: 'Tactics: Victory Points', items: [
            '1 Victory Point for each detachment destroyed.',
            '1 Victory Point for each quadrant of the playing field not occupied by any enemy forces each turn.',
            'No victory points for controlling objectives.'
          ]},
          { title: 'Tactics: Brood & Detachments', items: [
            'In Tyranid forces, the term Brood is used and has the exact same rules meaning as Detachment.'
          ]},
          { title: 'Psychic Powers', items: [
            'Models with Psychic Powers may use them irrespective of other actions they have taken.',
            'A model must generally make a Morale check to use psychic powers; Synapse (X") does not auto-pass Psychic Tests.',
            { name:'Psychic Scream', desc:'During the First Fire phase, make a Morale check. If passed, all units within 8" of the unit with Psychic Scream must take a morale test and, if failed, must fall back.' },
            { name:'Catalyst', desc:'During the Combat Phase, the unit may perform a morale test; if passed, a single brood within 8" gains Feel No Pain.' },
            { name:'The Horror', desc:'Before rolling dice for being engaged, the unit may perform a morale check. If passed, the enemy unit rolls one additional die and discards the highest; apply CAF as normal.' }
          ]},
          { title: 'Special Rules', items: [
            { name:'Synapse (X")', desc:'Models with Synapse are conduits to the Hive Mind. Units within range automatically pass morale checks except those used to test for Psychic Power abilities.' },
            { name:'Instinct: X', desc:'At the end of the Imitative Phase, models with Instinct: X must take a Morale check. If failed, they automatically receive the corresponding order. Where a brood has multiple Instinct values, use the majority; on a tie, roll a die to determine precedence.' },
            { name:'Regeneration', desc:'When a model with Regeneration reaches 0 wounds, do not remove it; the unit may still return. In the end phase, if the unit has fewer than full wounds, roll one D6 for each wound suffered; each 6+ restores one wound.' },
            { name:'Chameleon Skin (X)', desc:'Models with Chameleon Skin blend into the environment. They may not be targeted by enemy units if engaged outside of value X (e.g., 10").' },
            { name:'Winged', desc:'Units with Winged may partake in close combat even if they have the Flyer special rule.' },
            { name:'Burrow', desc:'Instead of moving, a unit with Burrow may return to reserves to be deployed again using deep strike in subsequent turns.' },
            { name:'Spawn (X, Y)', desc:'A model may spawn Y units of type X. If the spawned units share the same formation type they are added to the Brood; otherwise they form a new Brood acting independently. Place spawned units as close as possible to the spawning unit. Example: Spawn(Termagant, D3). If insufficient models are available, ignore extra results.' },
            { name:'Miasma', desc:'Units with Miasma are covered in toxic gases that distort aim. Attacks against a unit with Miasma suffer -1 to To Hit; enemy units engaged with a unit that has Miasma suffer -1 CAF.' }
          ]},
          { title: 'Gear: Weapon Traits', items: [
            { name:'Attract', desc:'On a hit against a model of equal or lesser category (Infantry, Walker, Super-Heavy Vehicle, Knight, Titan designated by value) that does not have Implacable, if the attack fails to kill the target move the closest model D6" toward the attacking unit. If this enters close combat the units are now Engaged. No effect if blocked by shields such as Void Shields or Ion Shields.' },
            { name:'Hunger', desc:'Each time an enemy is slain by a weapon with this trait, the attacker regains a wound up to its maximum.' },
            { name:'Beam', desc:'The attack traces a straight line from firer to target; any formation under this line is a target and is affected as if fired upon directly.' },
            { name:'Parry', desc:'When a model with Parry fights in Close Combat it may force the opponent to re-roll one die.' },
            { name:'Pinning', desc:'Infantry units hit by this weapon take an extra Blast marker.' },
            { name:'Web', desc:'Units hit by this weapon may not move in their next activation.' }
          ]},
          { title: 'Gear: Spore Mines & Launcher', items: [
            { name:'Spore Mines', desc:'Tokens that follow the rules of a lone model; can be targeted; have no save or special rules; if killed, they detonate. At the start of the end phase each spore mine moves randomly: roll a scatter die and move D6" in that direction (use the arrow on Hit). If contacting a non-Tyranid unit or impassable terrain they detonate; if entering a building they enter as per building rules and may move away next turn. On detonation place a Blast (3") marker; all models covered suffer a hit with profile: Spore Mine Explosion, AP -1, Traits: Blast (3"), Light AT.' },
            { name:'Spore Launcher', desc:'Choose a target as per normal targeting rules; the Spore Mine targets the closest model in that detachment. Roll 2D6 and a scatter die; place the Spore Mine as indicated. On Hit use the arrow; if the new location is in base contact or impassable terrain, detonate immediately as per Spore Mines.' }
          ]},
          { title: 'The Army List', items: [
            'As the Tyranids do not conform to the strict hierarchies of the Imperium the Army list follows a slightly different format than those found in the core Legions Imperialis rulebook.'
          ]},
          { title: 'Army List: Unit Types', items: [
            { lead: 'Unit Types' },
            { name:'Synapse', desc:'Broods. in. this. category. are. the. conduits. to. the. Hive. Mind,.without.these.the.Swarm.would.be.little.more.than. mindless. beasts. easily. tricked,. trapped. and. destroyed. the. foes.of.the.Great.Devourer.' },
            { name:'Core', desc:'Core.units.are.all.the.units.regularly.seen.in.the.Tyranid. Army,. these. include. Broods. such. as. the. lowly. Termagant. up.to.mighty.beasts.such.as.the.Carnifex.or.Tervigon..The. majority.of.the.units.in.a.Tyranid.army.will.be.comprised. of.these.Core.Broods..It.is.up.to.you.as.the.player.to.mix.and. match.and.either.create.a.massive.swarm.with.thousands. of. critters. or. build. a. massive. horde. full. of. unstoppable. monsters.' },
            { name:'Bio-Titans', desc:'Bio-Titans.cover.a.range.of.units.from.large.Bio-Constructs. up. to. the. massive. Bio-Titans. that. the. Hive. Mind. can. conjure. up.. These. include. units. from. the. Trygons. up. to. the.massive.Hierophant.titans..While.rare.in.the.context.of. the. untold. millions,. Bio-Titans. are. a. formidable. addition. to.any.swarm.and.creatures.that.can.sway.the.tide.of.battle. of.their.own.' },
            { name:'Flyers', desc:'The.Hive.Mind.is.ever.present,.when.it.is.set.on.devouring. a.world.it.engulfs.it.in.space,.in.the.warp,.on.the.surface.but. also.in.the.skies..The.Flyers.of.the.Tyranids.are.formidable. foes.that.echo.the.mythical.dragons.of.antiquity.and.many. are.the.Imperial.pilots.undone.by.their.overconfidence.in. the.technology.of.their.flying.machines. Flyers. are. a. strong. supporting. element. to. any. Tyranid. swarm.from.the.winged.Harpies.to.the.massive.Harridans' }
          ]},
          { title: 'Army Special Rules', items: [
            'Commander',
            'Invulnerable Save (5+)',
            'Synapse (12")',
            'Shadow in the Warp',
            'Synaptic Relay',
            'Synaptic Control'
          ]},
          { title: 'Army Special Rules: Descriptions', items: [
            { name:'Commander', desc:'Represents the nodal dominance of a major organism within the swarm; the detachment can issue and receive orders effectively even when other synaptic conduits are disrupted.' },
            { name:'Invulnerable Save (5+)', desc:'A resilient outer carapace or bio-field that grants a 5+ save which cannot be modified by AP or similar effects.' },
            { name:'Synapse (12")', desc:'A synaptic aura emanates from key organisms. Friendly Tyranid units within 12" automatically pass morale checks except those used when testing for Psychic Powers.' },
            { name:'Shadow in the Warp', desc:'The ambient psychic pressure of the swarm distorts the immaterium. Enemy units suffer penalties to psychic reliability and may find their morale shaken by its oppressive presence.' },
            { name:'Synaptic Relay', desc:'Orders and behavioral directives propagate through synapse-linked organisms, allowing commands to be relayed across broods without direct line of command.' },
            { name:'Synaptic Control', desc:'Under tight synaptic dominance the swarms behavior can be overridden to execute coordinated maneuvers beyond instinctive patterns.' }
          ]},
          { title: 'Psychic Powers', items: [
            'The Horror (+15 points)',
            'Catalyst (+15 points)',
            'Paroxysm',
            'Psychic Scream'
          ]},
          { title: 'Options', items: [
            'Add Wings (+20 points): Change movement profile to 10" and add Flying to Special Rules.',
            'Upgrade to Swarm Lord (+25 points): Change CAF to +14; Change Wounds to 3; Remove Venom Cannon / Barbed Strangler.'
          ]}
        ],
        Eldar: [
          { title: 'Army Special Rules', items: [
            'Dedicated Transports: Any Eldar detachment in the formation with only Infantry may upgrade with Wave Serpents as Dedicated Transports.',
            'Wraith Constructs: Compulsory Core detachments must be filled with Wraithlords or Wraithguard only; HQ must be Farseer or Warlock only.',
            'Dire Needs: All models increase Tactical Strength by 1 when contesting an Objective with Wraithguard or Wraithlord also contesting.'
          ]},
          { title: 'Psychic Powers', items: [
            'Guide',
            'Doom'
          ]},
          { title: 'Formation Options', items: [
            'Wraithgate Assault: All models must have Move >10" or be mounted in a Transport; all detachments gain Forward Deployment.',
            'Tank Commander: One model from a Compulsory detachment must be upgraded with Commander for +10 pts.'
          ]}
        ],
        Orks: [
          { title: 'Army Special Rules', items: [
            'Sneaky Now: Each mob must take a Nob if able to.',
            'Taktiks: All units gain Outflank and must deploy using the special rule.',
            'Primitive: May not take any detachment of size 2 or more unless it also has Clan(Snakebites).',
            'Wierdboy Shamans: While at least 1 Wierdboy in this formation, generate +2 dice for Psychic Powers.',
            'Mob Rule',
            'Ramshackle'
          ]},
          { title: 'Sub-faction Notes', items: [
            'Blood Axes: One of Air Support/Heavy Armor/Artillery may be selected for Special.',
            'Snakebites: One of Battle Tank/Core/Vanguard for Special.'
          ]}
        ]
      };

      function openReferenceArmyRules(){ setReferenceView('army-rules'); try{ ensureFactionRules(); }catch(e){} updateReferenceHash(); requestRender(); }
      function openReferenceGameRules(){ setReferenceView('game-rules'); updateReferenceHash(); requestRender(); }
      function setArmyRulesFactionTab(name){ armyRulesFaction = name; updateReferenceHash(); requestRender(); }
      function renderArmyRuleTabs(){ const armies=Object.keys(ARMIES).filter(a=>a!=='Select Army'); return `<div class="subtabs">${armies.map(a=>`<button class="pill ${a===armyRulesFaction?'active':''}" onclick="setArmyRulesFactionTab('${a}')">${a}</button>`).join('')}</div>`; }
      function renderReferenceArmyRules(){ 
        const rules=(FACTION_RULES[armyRulesFaction]||[]); 
        const list = rules.length ? rules.map(entry=>{ 
          const title = (typeof entry==='string') ? armyRulesFaction : (entry.title||armyRulesFaction);
          let content = '';
          if(typeof entry==='string'){
             content = `<p class="pdf-paragraph">${entry}</p>`;
          } else {
             content = (entry.items||[]).map(r=>{ 
               if(typeof r==='string'){ return `<p class="pdf-paragraph">${r}</p>`; } 
               if(r && r.lead){ return `<p class="pdf-lead">${r.lead}</p>`; } 
               if(r && r.name){ 
                 const key=String(r.name||''); 
                 const known = (typeof RULES_INDEX === 'object') && (RULES_INDEX[_normKey(key)] !== undefined); 
                 const head = known ? `<div class="pdf-subhead rule-key" data-rule="${key}" onclick="openRuleDialog('${key}')">${key}</div>` : `<div class="pdf-subhead">${key}</div>`; 
                 return head + `<p class="pdf-paragraph">${r.desc||''}</p>`; 
               } 
               return ''; 
             }).join('');
          }
          return `<div class="card" style="padding:0;margin-bottom:12px"><div class="section-bar">${title}</div><div style="padding:12px">${content}</div></div>`;
        }).join('') : `<div class="muted small">No rules available</div>`; 
        const tabs=renderArmyRuleTabs(); 
        return `<div style="padding:12px">${renderCrumbs([{label:'Reference',on:'openReferenceHome()'},{label:'Army Rules'}])}${tabs}${list}<div style="margin-top:8px"><button class="btn" onclick="openReferenceHome()">Back</button></div></div>`; 
      }

      async function ensureFactionRules(){ try{ if(window._factionRulesLoaded) return; const resp1 = await fetch('data/faction_rules.json',{cache:'no-store'}); if(resp1 && resp1.ok){ const data = await resp1.json(); Object.keys(data||{}).forEach(f=>{ const sections = data[f]||[]; if(Array.isArray(sections) && sections.length){ const existing = Array.isArray(FACTION_RULES[f]) ? FACTION_RULES[f] : []; const incoming = sections.map(s=> (typeof s==='string' ? { title:'Army Special Rules', items:[s] } : s)); if(existing.length===0){ FACTION_RULES[f] = incoming; } else { incoming.forEach(sec=>{ const title = sec && sec.title ? sec.title : 'Army Special Rules'; const has = existing.some(e=> (typeof e==='object') && (e.title===title)); if(!has){ existing.push(sec); } }); FACTION_RULES[f] = existing; } } }); }
      const resp2 = await fetch('PDF/MainRules.json',{cache:'no-store'}); if(resp2 && resp2.ok){ const json = await resp2.json(); const traits = json.traitLibrary||{}; if(FACTION_RULES.Tyranids && !FACTION_RULES.Tyranids.some(e=>typeof e==='object' && e.title==='Traits (Reference)')){ FACTION_RULES.Tyranids.push({ title:'Traits (Reference)', items: Object.keys(traits).slice(0,10).map(k=>`${k}: ${traits[k]}`) }); }
      }
      window._factionRulesLoaded=true; }catch(e){} }



      function renderArmyRulesSection(faction){
        const rules = FACTION_RULES[faction];
        if(!rules || !rules.length) return '';
        
        const list = rules.map(entry=>{ 
          const title = (typeof entry==='string') ? faction : (entry.title||faction);
          let content = '';
          if(typeof entry==='string'){
             content = `<p class="pdf-paragraph">${entry}</p>`;
          } else {
             content = (entry.items||[]).map(r=>{ 
               if(typeof r==='string'){ return `<p class="pdf-paragraph">${r}</p>`; } 
               if(r && r.lead){ return `<p class="pdf-lead">${r.lead}</p>`; } 
               if(r && r.name){ 
                 const key=String(r.name||''); 
                 const known = (typeof RULES_INDEX === 'object') && (RULES_INDEX[_normKey(key)] !== undefined); 
                 const head = known ? `<div class="pdf-subhead rule-key" style="color:var(--accent);cursor:pointer" data-rule="${key}" onclick="openRuleDialog('${key}')">${key}</div>` : `<div class="pdf-subhead" style="color:var(--accent)">${key}</div>`; 
                 return head + `<p class="pdf-paragraph">${r.desc||''}</p>`; 
               } 
               return ''; 
             }).join('');
          }
          return `<div class="card" style="padding:0;margin-bottom:12px;border:1px solid #374151"><div class="section-bar">${title}</div><div style="padding:12px">${content}</div></div>`;
        }).join('');

        return `
          <details class="roster-panel" style="padding:8px;margin-bottom:8px;background:#0d2b36;border-radius:8px;border:1px solid #243e46">
            <summary style="cursor:pointer">
              <div class="roster-header" style="display:inline-flex;justify-content:space-between;align-items:center;width:100%">
                <div><strong class="roster-title" style="color:#fff">Army Rules: ${faction}</strong></div>
                <div class="small muted">View Rules</div>
              </div>
            </summary>
            <div style="margin-top:10px;padding:12px;background:var(--panel);border-radius:4px;color:#cbd5e1">
              ${list}
            </div>
          </details>
        `;
      }

      function renderRosterFormation(f, padding, margin){
        const fRules = (FORMATIONS[f.name] && FORMATIONS[f.name].rules) || f.rules || [];
        const rulesHtml = fRules.length ? 
          `<div class="formation-rules" style="margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,0.1);display:flex;flex-wrap:wrap;gap:6px">
            ${fRules.map(r => {
              if(typeof r === 'string' && r.indexOf(':') > -1){
                const idx = r.indexOf(':');
                const title = r.substring(0, idx).trim();
                return `<span style="cursor:pointer;background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;font-size:11px;color:#fff;font-weight:600;border:1px solid rgba(255,255,255,0.3)" onclick="event.preventDefault();event.stopPropagation();openRuleDialog('${title.replace(/'/g,"\\'")}')">${title}</span>`;
              }
              return `<span style="cursor:pointer;background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;font-size:11px;color:#fff;font-weight:600;border:1px solid rgba(255,255,255,0.3)" onclick="event.preventDefault();event.stopPropagation();openRuleDialog('${r.replace(/'/g,"\\'")}')">${r}</span>`;
            }).join('')}
          </div>` 
          : '';
        const cuPairs=(f.compulsory||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Compulsory',type:s.type,index:(s._group&&s._group.index)||undefined}})));
        const ouPairs=(f.optional||[]).flatMap(s=> (s.units||[]).map(u=>({u,slotInfo:{label:s.label,section:'Optional',type:s.type,index:(s._group&&s._group.index)||undefined}})));
        const suPairs=(f.special && f.special.units)||[];
        return `<details class="roster-panel" style="padding:${padding};margin-bottom:${margin};background:#071a21;border-radius:8px"><summary><div class="roster-header"><div><strong class="roster-title">${f.name}</strong>${ formationHasMinViolations(f) ? `<span class="form-alert"> Compulsory Unit Missing</span>` : '' }<div class="small muted">${f.army}</div>${rulesHtml}</div><div class="roster-points">Total: ${formationPoints(f)} pts</div></div></summary><div style="margin-top:${padding==='12px'?'10px':'8px'}">${cuPairs.length? `<div class="section-sub">Compulsory</div>`+cuPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''}${ouPairs.length? `<div class="section-sub">Optional</div>`+ouPairs.map(p=>renderRosterUnit(p.u,p.slotInfo)).join('') : ''}${suPairs.length? `<div class="section-sub">Special</div>`+suPairs.map(u=>renderRosterUnit(u,{label:(f.special&&f.special.label)||'Special',section:'Special',type:(f.special&&f.special.type)||'Special'})).join('') : ''}</div></details>`;
      }

      function renderRoster(){
        const hasSaved = (savedLists||[]).length > 0;
        const active = currentListId ? (savedLists||[]).find(x=>x.id===currentListId) : null;
        const working = (armyFormations||[]).length > 0;

        if(!hasSaved && !working){
          return `<div style="padding:12px"><div class="hero"><button class="btn btn-green hero-cta" onclick="createNewList()">Create List</button></div><div class="muted small" style="margin-top:8px">No saved lists yet.</div></div>`;
        }

        if(active){
          const formations = active.formations||[];
          const pointsUsed = formations.reduce((s,f)=>s+formationPoints(f),0);
          const pointsCap = active.pointsCap||2000;
          const header = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong class="roster-title">${active.name}</strong><div class="small muted">${active.faction||'-'}</div></div><div style="display:flex;gap:8px;align-items:center"><div class="small muted">${pointsUsed}/${pointsCap} pts</div><button class="btn btn-blue btn-sm" onclick="setActiveTab('army-builder')">Open in Builder</button><button class="btn btn-blue btn-sm" onclick="openRosterExportModal()">Export</button></div></div>`;
          const armyRulesHtml = renderArmyRulesSection(active.faction || selectedArmy);
          const body = formations.length ? formations.map(f=>renderRosterFormation(f, '12px', '12px')).join('') : `<div class=\"muted small p-4\">No formations yet.</div>`;
          return `<div style="padding:8px"><div class="crumbs small muted">Roster  ${active.name}</div><div class="card" style="padding:8px">${header}</div>${armyRulesHtml}${body.replace(/padding:12px/g,'padding:8px').replace(/margin-bottom:12px/g,'margin-bottom:8px')}</div>`;
        }

        if(!working){
          return renderLists();
        }

        if(!armyFormations.length) return `<div style="padding:12px" class="muted small">No formations added.</div>`;

        const armyRulesHtml = renderArmyRulesSection(selectedArmy);
        return `<div style="padding:8px"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><div class="crumbs small muted">Roster</div><div style="display:flex;gap:8px;align-items:center"><button class="btn btn-blue btn-sm" onclick="setActiveTab('army-builder')">Open in Builder</button><button class="btn btn-blue btn-sm" onclick="openRosterExportModal()">Export</button></div></div>${armyRulesHtml}${armyFormations.map((f,fi)=>renderRosterFormation(f, '8px', '8px')).join('')}</div>`;

      }



      function renderRosterUnit(u, slotInfo){ return renderUnitReference(u, slotInfo); }

      function renderUnitReference(u, slotInfo){
        let caf = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].baseCAF) || (UNIT_BASE[u.id] && UNIT_BASE[u.id].CAF) || '';
        let wounds = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].baseWounds) || (UNIT_BASE[u.id] && UNIT_BASE[u.id].wounds) || '-';
        let move = (UNIT_BASE[u.id] && UNIT_BASE[u.id].movement) || '-';
        let save = (UNIT_BASE[u.id] && UNIT_BASE[u.id].save) || '-';
        let morale = (UNIT_BASE[u.id] && UNIT_BASE[u.id].morale) || '-';
        const applied = u._appliedEffects || {};
        const swarm = applied.swarmLord;
        const upgStats = (u.upgrades||[]).reduce((acc,up)=>{ const e=UPGRADE_EFFECTS[up.id]; if(!e) return acc; if(e.stats && e.stats.CAF) acc.CAF=e.stats.CAF; if(e.stats && e.stats.Wounds) acc.Wounds=e.stats.Wounds; if(e.stats && e.stats.Movement) acc.Movement=e.stats.Movement; return acc; }, { CAF:caf, Wounds:wounds, Movement:move });
        if(swarm){ caf = swarm.CAF; wounds = swarm.Wounds; } else { caf = upgStats.CAF || caf; wounds = upgStats.Wounds || wounds; move = upgStats.Movement || move; }
        const dynRules=[]; (u.upgrades||[]).forEach(up=>{ const e=UPGRADE_EFFECTS[up.id]; (e&&e.rules||[]).forEach(r=>{ if(!dynRules.includes(r)) dynRules.push(r); }); });
        const baseRules = (UNIT_LOADOUTS[u.id] && UNIT_LOADOUTS[u.id].specialRules) ? UNIT_LOADOUTS[u.id].specialRules.slice() : [];
        const mergedRules = baseRules.concat(dynRules.filter(r=>!baseRules.includes(r)));
        const weaponsHtml = (u.weapons||[]).length ? `<div class="table-responsive"><table class="table weapons-table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>ToHit</th><th>AP</th><th>Traits</th><th class="text-end" style="width:80px">Cost</th></tr></thead><tbody>` + (u.weapons||[]).map(w => { const stat = WEAPON_LIBRARY[w.src] || {}; return `<tr><td data-label="Weapon">${w.name}</td><td data-label="Range">${stat.range||'-'}</td><td data-label="Dice">${stat.dice||'-'}</td><td data-label="ToHit">${stat.toHit||'-'}</td><td data-label="AP">${stat.AP===undefined?'-':stat.AP}</td><td data-label="Traits">${renderTraitsCell(stat.traits)}</td><td class="cost text-end" data-label="Cost">${w.points||0} pts</td></tr>`; }).join('') + `</tbody></table></div>` : `<div class="small muted">No weapons selected</div>`;
        const upgradesHtml = (u.upgrades||[]).length ? (u.upgrades||[]).map(up=>`<div><strong>${up.name}</strong> <span class="muted">Cost: ${up.points||0} pts</span><div class="muted">${up.desc||''}</div></div>`).join('') : `<div class="small muted">No upgrades</div>`;
        const psychicHtml = (u.psychic||[]).length ? (u.psychic||[]).map(p=>`<div><strong>${p.name}</strong> <span class="muted">Cost: ${p.points||0} pts</span><div class="muted">${p.desc||''}</div></div>`).join('') : '';
        const effectHtml = swarm ? `<div class="effect-pill" style="display:inline-block;margin-top:6px">Swarm Lord: CAF ${swarm.CAF}; W ${swarm.Wounds}</div>` : '';
        const specialRules = mergedRules.length ? mergedRules.map(r=>renderRuleText(r)).join('') : '';

        const headerHtml = `
          <div class="roster-header">
            <div class="roster-info">
              <div class="roster-name">${u.name} <span class="muted">(${u.models || u.baseModels || '-'})</span></div>
              ${(()=>{ const sec=(slotInfo&&slotInfo.section)||''; const lab=(slotInfo&&slotInfo.label)||((UNIT_BASE[u.id]&&UNIT_BASE[u.id].type)||u.slotType||''); return `<span class="pill roster-pill">${sec?sec+': ':''}${lab}</span>`; })()}
            </div>
            <div class="roster-points">
              <div>${unitPoints(u)} pts</div>
            </div>
          </div>`;

        const bodyHtml = `
          <div style="margin-top:8px"><strong>Unit</strong>${(()=>{ const base=UNIT_BASE[u.id]||{}; const typeVal=base.type||u.slotType; const uType=base.type?String(base.type).toUpperCase():''; const uScale=base.scale||1; const typeLabel=uType?`<span class="small muted" style="margin-left:8px">${uType} (${uScale})</span>`:''; return `${typeLabel}<table class="table"><thead><tr><th>Type</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th></tr></thead><tbody><tr><td>${typeVal||'-'}</td><td>${move}</td><td>${save}</td><td>${caf}</td><td>${morale}</td><td>${wounds}</td></tr></tbody></table>`; })()}</div>
          ${effectHtml}
          ${specialRules ? `<div style="margin-top:8px"><strong>Special rules</strong>${specialRules}</div>` : ''}
          <div style="margin-top:8px"><strong>Weapons</strong>${weaponsHtml}</div>
          <div style="margin-top:8px"><strong>Upgrades</strong>${upgradesHtml}</div>
          ${psychicHtml ? `<div style="margin-top:8px"><strong>Psychic powers</strong>${psychicHtml}</div>` : ''}
          ${u.notes && u.notes.length ? `<div class="notes" style="margin-top:8px">${u.notes.join('; ')}</div>` : ''}`;

        return `
          <details class="roster-unit">
            <summary>${headerHtml}</summary>
            <div>${bodyHtml}</div>
          </details>
        `;

      }

      function printRoster(){
        try{
          const root=document.getElementById('content');
          if(!root){ window.print(); return; }
          const details=Array.from(root.querySelectorAll('details'));
          const states=details.map(d=>d.open);
          details.forEach(d=>{ d.open=true; });
          setTimeout(()=>{ try{ window.print(); }finally{ setTimeout(()=>{ details.forEach((d,i)=>{ d.open = states[i]; }); },300); } },50);
        }catch(e){
          try{ window.print(); }catch(_) {}
        }
      }

      function renderReferenceUnitDetail(){ const army=referenceDetail.army; const unitId=referenceDetail.unitId; const key=armyKey(army||selectedArmy); const list=(ARMY_UNIT_LIST[key]||[]); const base=list.find(u=>u.id===unitId)||{name:slugToName(unitId),slotType:'Core'}; const stats=UNIT_BASE[unitId]||{}; const load=UNIT_LOADOUTS[unitId]||{weapons:[],specialRules:[],upgrades:[]}; const weapons=(load.weapons||[]).filter(w=>w.base); const rows=weapons.length? weapons.map(w=>{ const s=WEAPON_LIBRARY[w.src]||{}; return `<tr><td>${w.name}</td><td>${s.range||'-'}</td><td>${s.dice||'-'}</td><td>${s.toHit||'-'}</td><td>${s.AP===undefined?'-':s.AP}</td><td>${renderTraitsCell(s.traits)}</td></tr>`; }).join('') : `<tr><td colspan="6" class="small muted">No base weapons</td></tr>`; const rulesHtml=(load.specialRules||[]).length?(load.specialRules||[]).map(r=>renderRuleText(r)).join(''):`<div class="muted small">No special rules listed</div>`; const ups=(load.upgrades||[]); const upsBlock=ups.length?`<div class="section-sub">Upgrades</div><div><button class="btn btn-sm" onclick="toggleReferenceUpgrades()">${referenceShowUpgrades?'Hide':'Show'} Upgrades</button>${referenceShowUpgrades?ups.map(u=>`<div style="margin-top:4px"><strong>${u.name}</strong> <span class="muted">Cost: ${u.points||0} pts</span><div class="muted">${u.desc||''}</div></div>`).join(''):''}</div>`:''; return `<div style="padding:12px"><div class="crumbs small muted">Reference  Units  ${base.name}</div><div class="card" style="padding:0"><div class="section-bar">${base.name}</div><div style="padding:8px"><div style="display:flex;justify-content:space-between"><div class="pill">${base.slotType}</div><div class="pill">${army||'-'}</div></div><table class="table" style="margin-top:8px"><thead><tr><th>Name</th><th>Move</th><th>Save</th><th>CAF</th><th>Morale</th><th>W</th></tr></thead><tbody><tr><td>${base.name}</td><td>${stats.movement||'-'}</td><td>${stats.save||'-'}</td><td>${stats.CAF||'-'}</td><td>${stats.morale||'-'}</td><td>${stats.wounds||'-'}</td></tr></tbody></table><div class="section-sub">Weapons</div><table class="table"><thead><tr><th>Weapon</th><th>Range</th><th>Dice</th><th>To Hit</th><th>AP</th><th>Traits</th></tr></thead><tbody>${rows}</tbody></table><div class="section-sub">Special Rules</div><div>${rulesHtml}</div>${upsBlock}</div></div><div style="margin-top:8px"><button class="btn" onclick="setReferenceView('units')">Back to Units</button><button class="btn" style="margin-left:8px" onclick="openReferenceHome()">Reference Home</button></div></div>`; }



      // ---------- Bootstrap ----------

      document.addEventListener('DOMContentLoaded', ()=>{ loadState(true); document.body.classList.add('rb-theme'); document.body.addEventListener('click',(e)=>{ const btn=e.target.closest('.icon-btn[data-action]'); if(btn){ const act=btn.getAttribute('data-action'); if(act==='delete-list') deleteCurrentList(); e.preventDefault(); }
        const fbtn=e.target.closest('.mini-icons .icon-btn[data-action]'); if(fbtn){ const act=fbtn.getAttribute('data-action'); const fi=Number(fbtn.getAttribute('data-fi')); if(act==='formation-toggle') toggleCollapse(fi); else if(act==='formation-clone') cloneFormation(fi); else if(act==='formation-remove') removeFormation(fi); e.preventDefault(); }
        const lbtn=e.target.closest('td button[data-action]'); if(lbtn){ const act=lbtn.getAttribute('data-action'); const id=lbtn.getAttribute('data-id'); if(act==='list-models') listModels(id); else if(act==='duplicate-list') duplicateList(id); else if(act==='view-list') viewList(id); else if(act==='copy-link') copyBuilderLink(id); else if(act==='delete-list') deleteList(id); e.preventDefault(); }
        const bulkBtn=e.target.closest('button[data-action]'); if(bulkBtn){ const act=bulkBtn.getAttribute('data-action'); if(act==='bulk-del'){ if(selectedListIds.length){ savedLists = (savedLists||[]).filter(l=> !selectedListIds.includes(l.id)); selectedListIds = []; persistSavedLists(); renderContent(); } e.preventDefault(); } else if(act==='bulk-export'){ if(selectedListIds.length){ exportSelectedListsPDF(); } e.preventDefault(); } else if(act==='bulk-open'){ if(selectedListIds.length===1){ const id=selectedListIds[0]; openInBuilder(id); setActiveTab('army-builder'); } e.preventDefault(); } else if(act==='list-open'){ const id=bulkBtn.getAttribute('data-id'); if(id){ openInBuilder(id); setActiveTab('army-builder'); } e.preventDefault(); } else if(act==='list-export'){ const id=bulkBtn.getAttribute('data-id'); if(id){ openExportModal(id); } e.preventDefault(); } else if(act==='list-del'){ const id=bulkBtn.getAttribute('data-id'); if(id){ deleteList(id); } e.preventDefault(); } }
        const mh=e.target.closest('#modal-unit-summary .btn[data-action]'); if(mh){ const act=mh.getAttribute('data-action'); if(act==='unit-dec') window.headerModelBump(-1); else if(act==='unit-inc') window.headerModelBump(1); e.preventDefault(); }
        const dd=e.target.closest('#account-menu .dropdown-item[data-action]'); if(dd){ const act=dd.getAttribute('data-action'); if(act==='open-profile') openProfile(); else if(act==='logout') handleLogout(); e.preventDefault(); }
        const a=e.target.closest('a[href=\"#\"]'); if(a){ e.preventDefault(); } });
        document.body.addEventListener('change',(e)=>{ const sel=e.target.closest('[data-action]'); if(!sel) return; const act=sel.getAttribute('data-action'); if(act==='army-select') handleArmySelection(sel.value); else if(act==='formation-select') handleFormationSelection(sel.value); else if(act==='add-formation') addFormation(); else if(act==='builder-name') setBuilderName(sel.value); else if(act==='points-cap') setBuilderPoints(sel.value); else if(act==='slot-select'){ const fi=Number(sel.getAttribute('data-fi')); const sec=sel.getAttribute('data-sec'); const si=Number(sel.getAttribute('data-si')); setSlotSelection(fi,sec,si,sel.value); } else if(act==='special-select'){ const fi=Number(sel.getAttribute('data-fi')); addUnitToSpecial(fi, sel.value); } else if(act==='list-select'){ const id=sel.getAttribute('data-id'); const isChecked=sel.checked; const set=new Set(selectedListIds); if(isChecked) set.add(id); else set.delete(id); selectedListIds = Array.from(set); renderContent(); } else if(act==='select-all'){ const all=(savedLists||[]).map(l=>l.id); const isChecked=sel.checked; selectedListIds = isChecked ? all : []; renderContent(); } });
        document.addEventListener('click',()=>{}, true);
        document.addEventListener('keydown',(e)=>{ if(e.key==='Escape'){ closeModal(); } });
        loadConsolidatedArmyMaster(selectedArmy).then(ref=>{ setActiveTab('home'); if(ref){ window._lastMasterRef = ref; applyMasterBroodDefaults(ref); applyUpgradeConstraintsFromMaster(ref);
        buildUpgradeEffectsFromMaster(ref);
        buildArmyUnitsFromMaster(ref, selectedArmy);
        updateFormationsFromMaster(ref);
        
        // Populate FACTION_RULES from master
        if(ref.faction_info && ref.faction_info.faction_rules){
          if(!FACTION_RULES[selectedArmy]) FACTION_RULES[selectedArmy] = [];
          // Filter out old "Army Special Rules" to avoid duplication
          FACTION_RULES[selectedArmy] = FACTION_RULES[selectedArmy].filter(s => s.title !== 'Army Special Rules');
          
          const mappedRules = ref.faction_info.faction_rules.map(r => ({
            name: r.name,
            desc: r.effect || r.description || ''
          }));
          
          if(mappedRules.length){
            FACTION_RULES[selectedArmy].push({
              title: 'Army Special Rules',
              items: mappedRules
            });
          }
        }

        // Ensure re-render if we are already viewing roster
        if(activeTab==='roster') renderContent();
      }
      initRulesIndex();
          const doPDF = (window.ENABLE_PDF_INGEST===true) || (localStorage.getItem('enable_pdf_ingest')==='1');
          const ingest = doPDF ? ingestPDFDocs() : Promise.resolve();
          return ingest.then(()=>{ buildUpgradeEffects(); runValidation(ref||{}); validateFormationRules(); dataStatus.validationIssues = (window._latestValidationIssues||[]).length; updateStatusBanner(); try{ if((location.hash||'').startsWith('#ref')) location.hash=''; }catch(e){} setActiveTab('home'); requestRender(); refreshAuthButton(); }); }); });





      // expose for quick debugging

      window._app = { armyFormations, renderContent, setActiveTab, UNIT_LOADOUTS, WEAPON_LIBRARY };
      window.openEditModal = openEditModal;
      window.closeModal = closeModal;
      window.removeUnit = removeUnit;
      window.removeSpecialUnit = removeSpecialUnit;

  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(reg => console.log('SW registered:', reg.scope))
          .catch(err => console.log('SW registration failed:', err));
      });
    }
  </script>

</body>



</html>
